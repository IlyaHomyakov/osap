<HTML>

<Head>
<Meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<Title>Электронный ресурс по учебной дисциплине ОСАПр. AutoLISP</Title>
<Meta Name="Description" http-equiv="description" Content="Электронный ресурс по учебной дисциплине ОСАПр. AutoLISP">
<Link Rel="stylesheet" Type="text/css" Href="../Оболочка/acad.css">
<style>
pre{
width: 53%;
}


</style>
<Script Language="JavaScript">
function mOver(num) {
if (document.images) {
document.images['link'+num].src=eval('active'+num+'.src');
}
}
function mOut(num) {
if (document.images) {
document.images['link'+num].src=eval('normal'+num+'.src');
}
}
</Script>

<Script Type="text/javascript" Src="../Оболочка/jquery.pack.js"></Script>

<Script Type="text/javascript">
var hidePostImg =false;

function initPost(context)
{
initSpoilers(context);
}
function initPostImages(context)
{
if (hidePostImg) return;
var $in_spoilers = $('div.sp-body var.postImg', context);
$('var.postImg', context).not($in_spoilers).each(function(){
var $v = $(this);
var src = $v.attr('title');
var $img = $('<img src="'+ src +'" class="'+ $v.attr('className') +'" alt="pic" />');
$img = fixPostImage($img);
var maxW = ($v.hasClass('postImgAligned')) ? postImgAligned_MaxWidth : postImg_MaxWidth;
$img.bind('click', function(){ return imgFit(this, maxW); });
if (user.opt_js.i_aft_l) {
$('#preload').append($img);
$v.html(loading_icon);
if ($.browser.msie) {
$v.after('<wbr>');
}
$img.one('load', function(){
imgFit(this, maxW);
$v.empty().append(this);
});
}
else {
$img.one('load', function(){ imgFit(this, maxW) });
$v.empty().append($img);
if ($.browser.msie) {
$v.after('<wbr>');
}
}
});
}
function initSpoilers(context)
{
$('div.sp-body', context).each(function(){
var $sp_body = $(this);
var name = $.trim(this.title);
this.title = '';
var $sp_head = $('<div class="sp-head folded clickable">'+ name +'</Div>');
$sp_head.insertBefore($sp_body).click(function(e){
if (!$sp_body.hasClass('inited')) {
initPostImages($sp_body);
var $sp_fold_btn = $('<div class="sp-fold clickable"></Div>').click(function(){
$.scrollTo($sp_head, { duration:200, axis:'y', offset:-200 });
$sp_head.click().animate({opacity: 0.1}, 500).animate({opacity: 1}, 700);
});
$sp_body.prepend('<div class="clear"></Div>').append('<div class="clear"></Div>').append($sp_fold_btn).addClass('inited');
}
if (e.shiftKey) {
e.stopPropagation();
e.shiftKey = false;
var fold = $(this).hasClass('unfolded');
$('div.sp-head', $($sp_body.parents('td')[0])).filter( function(){ return $(this).hasClass('unfolded') ? fold : !fold } ).click();
}
else {
$(this).toggleClass('unfolded');
$sp_body.slideToggle('fast');
}
});
});
}
$(function(){
$('div.post_body, div.signature').each(function(){ initPost( $(this) ) });
});
</Script>
</Head>

<Body Bgcolor=#E6E6E6 TopMargin=1 LeftMargin=1 MarginWidth=0 MarginHeight=0>
<Div Class=max>

<Script Language="JavaScript">
if (document.images) {
normal1=new Image(190,29);normal1.src="../Оболочка/images/01a.gif";
active1=new Image(190,29);active1.src="../Оболочка/images/01p.gif";
normal2=new Image(190,29);normal2.src="../Оболочка/images/02a.gif";
active2=new Image(190,29);active2.src="../Оболочка/images/02p.gif";
normal31=new Image(170,40);normal31.src="../Оболочка/images/031a.gif";
active31=new Image(170,40);active31.src="../Оболочка/images/031p.gif";
normal32=new Image(170,40);normal32.src="../Оболочка/images/032a.gif";
active32=new Image(170,40);active32.src="../Оболочка/images/032p.gif";
normal33=new Image(170,40);normal33.src="../Оболочка/images/033a.gif";
active33=new Image(170,40);active33.src="../Оболочка/images/033p.gif";
normal34=new Image(170,40);normal34.src="../Оболочка/images/034a.gif";
active34=new Image(170,40);active34.src="../Оболочка/images/034p.gif";
normal4=new Image(190,29);normal4.src="../Оболочка/images/04a.gif";
active4=new Image(190,29);active4.src="../Оболочка/images/04p.gif";
normal5=new Image(190,29);normal5.src="../Оболочка/images/05a.gif";
active5=new Image(190,29);active5.src="../Оболочка/images/05p.gif";
normal6=new Image(159,46);normal6.src="../Оболочка/images/06a.gif";
active6=new Image(159,46);active6.src="../Оболочка/images/06p.gif";
normal7=new Image(159,54);normal7.src="../Оболочка/images/07a.gif";
active7=new Image(159,55);active7.src="../Оболочка/images/07p.gif";
}
</Script>

<A Name="Top"></A>
<Table Border=0 Width=100% CellSpacing=0 CellPadding=0>
<Tr>
 <Td BackGround=../Оболочка/images/bg01.gif Width=190 Height=91>&nbsp;</Td>
 <Td RowSpan=2 BackGround=../Оболочка/images/bg02.gif Height=120 Valign=Bottom>
<Table BackGround=../Оболочка/images/raspor.gif Border=0 CellSpacing=0 CellPadding=0>
 <Tr>
<Td Width=180></Td>
  <Td Valign=top Height=60><P Class=h6>AutoLISP</P></Td>
 </Tr>
</Table>

</Td></Tr>
<Tr>
  <Td BackGround=../Оболочка/images/bg03.gif>
    <A Href=../Программа/!rabprog.html onMouseOver="mOver(1)" onMouseOut="mOut(1)"><Img Src=../Оболочка/images/01a.gif Border=0 Width=190 Height=29 Alt="Рабочая программа" name="link1"></A><Br>
 </Td>
</Tr>
<Tr>
 <Td Height=100% RowSpan="2" Valign=Top BackGround=../Оболочка/images/bg00.gif>

<Table Border=0 CellSpacing=0 CellPadding=0>
<Tr><Td BackGround=../Оболочка/images/bg03.gif Valign=Top>
  <A Href=../Теория/!lekcii.html onMouseOver="mOver(2)" onMouseOut="mOut(2)"><Img Src=../Оболочка/images/02a.gif Width=190 Height=29 Border=0 Alt="Лекции" name="link2"></A><Br>
 </Td>
</Tr>
<Tr><Td BackGround=../Оболочка/images/bg04.gif Width=190 Valign=Top>
  <Img Src=../Оболочка/images/03p.gif Border=0 Width=190 Height=29 Alt="Лабораторные работы"><Br></Td>
<Tr><Td BackGround=../Оболочка/images/bg05.gif Width=190 Valign=Top>
  <A href="!acad.html" onMouseOver="mOver(31)" onMouseOut="mOut(31)"><Img Src=../Оболочка/images/031a.gif Width=170 Height=40 Border=0 Alt="Лабораторная работа 1" name="link31"></A><Br></Td></Tr>
<Tr><Td BackGround=../Оболочка/images/bg06.gif Width=190 Height=36 Valign=Top>
  <A href="!mechanic.html" onMouseOver="mOver(32)" onMouseOut="mOut(32)"><Img Src=../Оболочка/images/032a.gif Width=170 Height=40 Border=0 Alt="Лабораторная работа 2" name="link32"></A><Br>
  <A href="!mechanic.html" onMouseOver="mOver(33)" onMouseOut="mOut(33)"><Img Src=../Оболочка/images/033a.gif Width=170 Height=40 Border=0 Alt="Лабораторная работа 3" name="link33"></A><Br>
  <A href="!lisp.html" onMouseOver="mOver(34)" onMouseOut="mOut(34)"><Img Src=../Оболочка/images/034a.gif Width=170 Height=40 Border=0 Alt="Лабораторная работа 4" name="link34"></A><Br>
<Img Src=../Оболочка/images/bg07.gif Width=190 Height=23><Br></Td></Tr>
 
 <Tr><Td BackGround=../Оболочка/images/bg03.gif Valign=Top>
 <A Href=../Заочнику/!zaochnoe.html onMouseOver="mOver(4)" onMouseOut="mOut(4)"><Img Src=../Оболочка/images/04a.gif Width=190 Height=29 Border=0 Alt="Самоконтроль" name="link4"></A><Br>
 <A Href=../Контроль_знаний/!samocontrol.html onMouseOver="mOver(5)" onMouseOut="mOut(5)"><Img Src=../Оболочка/images/05a.gif Width=190 Height=29 Border=0 Alt="Самоконтроль" name="link5"></A><Br>
 <Img Src=../Оболочка/images/bg08.gif Width=190 Height=13><Br>
</Table></Td>
 
 <Td Valign=Сenter>
 <Br><Br>

<A Name=1></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=99% BgColor=#9CA6CE>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../оболочка/images/raspor.gif></Td><Td align=left><span Class=h>Язык AutoLISP</span></Td></Tr>
<Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<Ul>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Введние в AutoLISP" style="display: none;"></a>
<P>Всё или почти всё, что делается в Автокаде вручную, можно реализовать программно. Для этого предусмотрены средства создания сценариев и использование языков программирования, таких как AutoLISP, С++ и Visual Basic. Разработка программного обеспечения в настоящее время ведётся почти исключительно при помощи языков высокого уровня. Данные языки представляют собой систему мнемонических обозначений с жёстко заданными синтаксисом и семантикой, которые понятны человеку и преобразуются в последовательность машинных команд при помощи специальной программы-транслятора. Различают следующие стили языков программирования:</P>

<Ul>
 <Li>Неструктурное программирование допускает использование в явном виде команды безусловного перехода (в большинстве языков GOTO). Типичные представители неструктурных языков – ранние версии Бейсика и Фортрана.</Li>
 <Li>В основе структурного стиля лежат две идеи:<Br>
  • задача разбивается на большое число мелких подзадач, каждая из которых решается своей процедурой или функцией;<Br>
  • любой алгоритм можно реализовать, используя лишь последовательное выполнение, ветвление и цикл, что позволяет при наличии соответствующих операторов исключить из языка команду перехода GOTO.</Li>
 <Li>Логическое программирование представляет собой попытку возложить на программиста только постановку задачи, а поиски путей её решения предоставить транслятору. Логические языки  (Пролог, Симула) имеют специальные конструкции для описания объектов и связей между ними.</Li>
 <Li>Объектно-ориентированное (ОО) программирование, реализованное в ОО-версиях языков C, Pascal представляет собой отображение объектов реального мира, их свойств и связей между ними Для объекта создается своя структура данных (класс), содержащая как свойства объекта (поля), так и процедуры для управления объектом (методы).</Li>
 <Li>В основе функционального стиля лежит понятие функции как "чёрного ящика", имеющего вектор параметров (аргументов) на входе и результат (скаляр) на выходе:</Li>
</Ul>

<P>В функциональных языках программирования отсутствуют операторы: все действия, в том числе и управляющие конструкции, выполняются при помощи вызовов функций. Поскольку каждая функция возвращает значение, её можно подставить в качестве аргумента другой функции, что позволяет записывать сложные выражения в функциональной форме. Одним из первых функциональных языков стал язык Лисп, созданный в конце 50-х гг. как язык искусственного интеллекта. Название языка официально означает LISt Processing.</P>

<P>К языкам искусственного интеллекта относят языки, способные в зависимости от набора исходных данных модифицировать алгоритм работы, т.е. “на ходу” менять программу.</P>

<P>AutoCAD сам по себе является графическим редактором, при помощи которого конструктор создает чертежи проектируемого изделия. Однако механическая замена кульмана на компьютер с AutoCAD чаще всего приводит не к росту производительности труда, а к замедлению работы в 2…4 раза. Подобное использование AutoCAD “в лоб” оправдано только при создании автоматизированных графических баз данных, для чего и требуется перевод чертежей в электронный вид.</P>

<P>Для эффективной работы AutoCAD следует адаптировать под проектирование изделий определённого класса. Тогда работа конструктора будет сведена к вводу параметров изделия, а всю черновую работу по отрисовке чертежа возьмет на себя программа, написанная на встроенном в AutoCAD языке программирования – AutoLISP. Выбор столь экзотического языка в качестве встроенного для столь популярной САПР вызван тем, что список – оптимальный способ представления графической информации, а также легкостью реализации и небольшими размерами интерпретатора. Однако следует признать относительно большую трудоемкость разработки программ на AutoLISP. Зато программы на AutoLISP отличаются чрезвычайно высокой надёжностью; за многие годы работы ошибок в работе интерпретатора не выявлено.</P>

<P>Программы AutoLISP позволяют создавать настроенные на конкретную предметную область применения функции, включающие в себя запросы к пользователю (диалог), возможность выбора по условию из нескольких вариантов или использования значений по умолчанию. Хотя макроопределения, которые можно создавать при написании меню AutoLISP, могут быть достаточно сложными и мощными, без AutoLISP они представляют собой всего лишь комбинации стандартных команд Автокада. Включением в макроопределения меню функций AutoLISP можно превратить меню AutoCAD в интеллектуальное средство автоматизации проектирования. AutoLISP позволяет:</P>

<Ul>
 <Li>использовать переменные и выражения при ответах на запросы команд AutoCAD;</Li>
 <Li>читать и писать внешние файлы, таким образом, обмениваясь с внешними программами, которые можно запускать из AutoCAD;</Li>
 <Li>создавать различные функции и новые команды AutoCAD, настраивая и расширяя, таким образом, графические возможности Автокада;</Li>
 <Li>осуществлять программный доступ (считывание и изменение) к данным, относящимся к объектам рисунка, а также таблицам AutoCAD, в которых хранится информация о блоках, слоях, видах, стилях и типах линий;</Li>
 <Li>осуществлять программное управление графическим экраном AutoCAD и вводом/выводом с различных устройств.</Li>
</Ul>
<Br>
<Hr Width="90%" Color="#7685C6" Align="Right"><Br>
</Div>
</Div>




<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Типы данных, переменные, выражения AutoLISP " style="display: none;"></a>
<Br>

<P>Как и любой другой язык программирования, AutoLISP при работе с переменной должен знать, к какому типу данных она относится: типом данных определяются операции, которые можно проделать с переменной (например, одно число поделить на другое число, но нельзя поделить одну строку на другую).</P>

<P>Тип данных - ключевое понятие в программировании. "Качество" языка программирования, т. е. его потенциальные, возможности, определяются во многом тем, какие типы данных им поддерживаются. AutoLISP имеет следующие типы данных:</P>

<Ul>
 <Li>целые числа;</Li>
 <Li>действительные числа;</Li>
 <Li>символы;</Li>
 <Li>строки;</Li>
 <Li>дескрипторы файлов;</Li>
 <Li>списки;</Li>
 <Li>"имена" примитивов AutoCAD;</Li>
 <Li>наборы AutoCAD;</Li>
 <Li>встроенные функции (subr);</Li>
 <Li>внешние функции.</Li>
</Ul>

<P>Целые числа в AutoLISP могут быть положительными или отрицательными (без дробей и десятичной точки). Для определения того, включен какой-то режим или нет, AutoCAD часто использует значения О и 1, например если режим ORTHO включен, то системная переменная ORTHOMODE установлена в единицу. Заметим, что целые числа представлены двумя байтами в диапазоне (-32768, 32767).</P>

<P>Действительные числа - это положительные или отрицательные числа с десятичной точкой. В отличие от других языков программирования в AutoLISP не разрешается начинать или заканчивать число десятичной точкой. Это связано с существованием в AutoLISP специфического типа данных - точечной пары, разделителем которой является точка. Поэтому, если значение меньше единицы, необходимо явно указать 0 перед десятичной точкой (0.123), иначе AutoLISP воспримет ошибку (error: invalid dotted pair (ошибка: неверная точечная пара). В качестве примеров действительных системных переменных можно указать переменные FILLETRAD, LTSCALE и AREA. Диапазон представления действительных чисел зависит от типа вашего компьютера и в любом случае достаточно велик. Правильно записанными действительными числами являются числа 2.12, 3.11592652543, -92722.121344, и 1.23544Е+17.</P>

<P>Символ - это имя, состоящее из букв, цифр и специальных знаков за исключением <B>( )</B>&nbsp;- круглых скобок, <B>.</B>&nbsp;- точки,
<B>'</B>&nbsp;- апострофа, <B>" "</B>&nbsp;- кавычек, <B>;</B>&nbsp;- точки с запятой. Имя символа обрывается круглыми скобками, апострофом, кавычками,
точкой с запятой, пробелом или концом строки.</P>

<P>Строковая константа выглядит как набор печатных символов, заключенных в кавычки.</P>

<P>Список представляет собой упорядоченную последовательность атомов или списков, заключённых в круглые скобки и разделённые пробелами. Список всегда
начинается с открывающейся скобки и заканчивается закрывающейся. Атом - это неделимый элемент списка. Понятия списка и атома являются ключевыми понятиями
языков семейства LISP. Любые другие типы данных являются либо атомами, либо списками.</P>

<P Class=h55>Примеры списков:</P>
<pre><code> (12.645 777.8)
 ("CAT" "EATS" "MOUSE")
 (1 (12 6.78) ("Иван" "Грозный"))
 (* 2 5)
 (setq point '(1.0 5.0 6.7))</code></pre>

<P Class=h55>Примеры атомов:</P>
<pre><code> 12.45
 "True Love"</code></pre>

<P>Требование принадлежности переменной к какому-либо типу данных - бич для программиста, и вообще требование, чуждое обыденному человеческому мышлению.
Ведь тип данных - чистая абстракция, соглашение - уступка вычислительной технике, которая пока еще не слишком-то совершенна. Человек не оперирует
понятием "тип данных", для него данные не имеют фиксированного типа (как говорится, с какой точки зрения посмотреть), а скорее имеют все типы
одновременно: написанное на бумаге число - это одновременно и группа символов, и число, и вообще что угодно, например художественное произведение
абстрактной живописи. AutoLISP был создан как язык, предназначенный для разработок в области искусственного интеллекта, и проблема типа данных в нем в
какой-то степени решена. Переменные в AutoLISP не надо описывать - тип данных AutoLISP определяет автоматически при присвоении переменной значения.</P>

<P>Как уже ясно из примеров, списки - идеальное средство работы со сложным образом организованной геометрической информацией. Точка, например, не что иное,
как список трех действительных чисел. Отрезок - список двух точек. Полилиния - список многих вершин (как видим, полилиния - геометрический объект,
органически вытекающий из "идеологии" описания данных AutoLISP). Практически любую структурированную информацию можно представить в виде списка, что и
делается в AutoLISP. Более того, любая определяемая пользователем функция AutoLISP (это соответствует подпрограмме в операторных языках программирования),
вообще говоря, тоже список.</P>

<P>Типы данных AutoLISP с помощью функции (type) идентифицируются следующим образом:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
<Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Идентификатор</P></Td>
 <Td><P Class=tcb>Тип данных</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>INT</P></Td> <Td><P Class=tl>Целые величины</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>REAL</P></Td> <Td><P Class=tl>Числа с плавающей точкой</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>STR</P></Td> <Td><P Class=tl>Строковые константы</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>FILE</P></Td> <Td><P Class=tl>Дескрипторы файлов</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>SYM</P></Td> <Td><P Class=tl>Символы</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>LIST</P></Td> <Td><P Class=tl>Списки и функции пользователя</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>SUBR</P></Td> <Td><P Class=tl>Внутренние функции AutoLISP</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>EXSUBR</P></Td> <Td><P Class=tl>Внешние функции</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>ENAME</P></Td> <Td><P Class=tl>Имена примитивов AutoCAD</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>PICKSET</P></Td> <Td><P Class=tl>Наборы примитивов AutoCAD</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>PAGETB</P></Td> <Td><P Class=tl>Таблица диспетчера страниц</P></Td>
</Tr>
</Table>
</Center>

<P>Итак, переменная в AutoLISP может быть атомом (целого, вещественного или строкового типа), а может быть списком. Приведем пример, в котором формируется список координат точки.</P>


 <pre><code> command:(setq a '(100 200 300))
 AutoLISP возвращает: (100 200 300)</code></pre>

<P>В этом примере создается переменная А, которая является списком. В AutoLISP имеются мощные средства работы со списками.</P><Br>

<P><B>Переменная в AutoLISP</B> создаётся при присвоении идентификатору, т.е. имени переменной какого-либо значения. При этом автоматически фиксируется её тип.
Переменные AutoLISP совершенно независимы от системных переменных AutoCAD и могут повторять их по именам. Имя переменной может состоять из любых печатных
символов (в том числе и цифр), однако не должно включать в себя зарезервированные AutoLISP символы, поскольку их AutoLISP интерпретирует специальным
образом. Не рекомендуется использовать для имен переменных следующие символы:</P>

<Ul>
 <Li>Зарезервированные символы:<Br>
., ', ", ;, (, ) или пробел.</Li>
 <Li>Знаки операций AutoLISP:<Br>
~, *, =, >, <, +, -, /.</Li>
</Ul>

<P>Нельзя также использовать в качестве имен переменных имена функций AutoLISP. Все имена функций AutoLISP, а также созданные пользователем имена
переменных хранятся в переменной AutoLISP ATOMLIST. Если вывести на экран содержимое переменной ATOMLIST, то можно увидеть, какие имена нельзя
использовать в программах. (Это можно сделать вводом с командной строки AutoCAD команды !ATOMLIST).</P>

<P>Заметим, что AutoLISP не различает строчные и прописные буквы. Поскольку имя переменной длиной более шести символов требует для хранения больше
памяти, не рекомендуется превышать этот предел. Не следует также начинать имя переменной с цифры.</P>
<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>неверные</P></Td> <Td><P Class=tcb>Имена переменных</P></Td> <Td><P Class=tcb>верные</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>123</P></Td> <Td><P Class=tl>- целое число</P></Td> <Td><P Class=tl>PT1</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>10.5</P></Td> <Td><P Class=tl>- действительная константа</P></Td> <Td><P Class=tl>txt</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>ANGLE</P></Td> <Td><P Class=tl>- конфликтует с функцией ANGLE</P></Td> <Td><P Class=tl>ANGL</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>А(1)</P></Td> <Td><P Class=tl>- содержит запрещенные символы</P></Td> <Td><P Class=tl>А1</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>OLD SUM</P></Td> <Td><P Class=tl>- содержит пробел</P></Td> <Td><P Class=tl>OLDSUM</P></Td>
</Tr>
</Table>
</Center>
<Br><Br>

<P>Если с точки зрения AutoLISP всё, что заключено в круглые скобки, считается списком, то как AutoLISP отличает данные от управляющих
конструкций&nbsp;- объект, который оперирует данными, от самих данных? Дело в том, что любая управляющая конструкция AutoLISP содержит объекты
специального типа&nbsp;- функции. Функции AutoLISP могут быть встроенными или определёнными пользователем. Встроенная функция AutoLISP (subr) - это
тип данных, являющийся на самом деле ссылкой на некую подпрограмму, которая выполняет над передаваемыми параметрами некоторые действия. Функция,
определённая пользователем,&nbsp;- это обычный сложный список, но всё равно он в конечном итоге содержит встроенные функции AutoLISP. Для того чтобы
AutoLISP было проще искать среди элементов списка функции, их принято писать на первом месте.</P>

<P>Список, в котором первым элементом является имя функции, называется <B>выражением</B>. Любая функция AutoLISP состоит из выражений и сама
является выражением. Перечислим основные свойства выражений (многие из этих свойств обусловлены просто тем, что любое выражение&nbsp;- это
список).</P>

<Ul>
 <Li>Каждая открывающая круглая скобка должна иметь закрывающую.</Li>
 <Li>Сразу после открывающей круглой скобки должен стоять идентификатор операции, выполняемой при вычислении выражения (имя функции).</Li>
 <Li>Каждое выражение вычисляется (выполняется), и результат возвращается. Результатом может быть нуль (nil) или результат вычисления последнего подвыражения.</Li>
 <Li>С логической точки зрения любое возвращаемое значение либо истинно, либо ложно. Если значение выражения не может быть вычислено и возвращается пустое место (nil), то оно считается ложным. Если значение вычисляется, то выражение считается истинным - не-пусто (non-nil). Выражение AutoLISP имеет вид</Li>
</Ul>

<P Class=h5>(функция аргумент1 аргумент2 ... аргументN)</P>

<P>Здесь <I>функция</I> - имя операции, которая должна быть выполнена. К операциям относятся в том числе и арифметические операции (сложение, вычитание, умножение, деление), а также операция присвоения. Записывать имя функции нужно сразу же после открывающей скобки без пробела. <I>Аргументы</I> представляют собой средство передачи значений функции. Аргументами могут быть переменные, константы или выражения. Число аргументов функции может быть переменным. Например, операция перемножения трёх чисел запишется так: (*&nbsp;2&nbsp;5&nbsp;8).</P>

<P>Аргументы могут быть обязательными и необязательными. Если при создании функции была определено, что ее аргументы являются обязательными, то AutoLISP выдаст ошибку при попытке вызвать функцию без указания этого аргумента. Однако аргументы могут быть и необязательными, в этом случае их при вызове функции можно не передавать. Следует также внимательно следить за типом аргументов: если функция производит операции над числами, то ей нельзя передать строку, и наоборот. Иначе говоря, если функция (или команда AutoCAD) должна принять в качестве аргумента строку, все символы, введенные в ответ на запрос, считаются элементами строки a priori. На первый взгляд это не позволяет передать AutoCAD выражение AutoLISP в ответ на запрос, требующий ввода строки (например, при использовании команды TEXT). Указанную трудность помогает преодолеть системная переменная AutoCAD TEXTEVAL. Установка этой переменной в единицу (оценка текста включена) приводит к тому, что AutoCAD передает выражение в AutoLISP и печатает возвращаемый результат, а не само выражение. Другими словами, если оценка текста включена, то в ответ на запрос AutoCAD можно вводить не только сам ответ, но и выражение на AutoLISP для его вычисления, используя круглые скобки или восклицательный знак.</P>

<P>Выражение анализируется AutoLISP слева направо, пока не встретится закрывающая или открывающая скобка. Если встречается закрывающая скобка, то AutoLISP завершает анализ выражения, выполняет функцию и передает ее значение на более старший уровень вложенности или в AutoCAD. Если встречается открывающая скобка, AutoLISP переходит к анализу выражения более младшего уровня вложенности и, пока не завершит его анализ, не перейдет к дальнейшему анализу выражения предыдущего уровня. Таким образом, порядок анализа выражений в AutoLISP задан жестко раз и навсегда, что исключает путаницу.</P>

<P>При описании функций необязательные параметры заключаются в квадратные скобки.</P>
<Br>
<Hr Width="90%" Color="#7685C6" Align="Right">
</Div>
</Div>




<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Создание функции в AutoLISP" style="display: none;"></a>
<P>В AutoLISP можно определять свои собственные функции. Функция DEFUN определяет функцию посредством создания структурированного списка операторов программы. Определенная таким образом функция создает свою собственную замкнутую область локальных переменных. При вызове функции в эту замкнутую область передаются данные, выполняются операторы программы, после чего осуществляется передача данных обратно в среду AutoLISP - AutoCAD.</P>

<P>Формат функции DEFUN следующий:</P>

<Pre><code> (defun имя (аргументы / локальные параметры)
тело функции
)</code></Pre>

<P>Правила именования функций те же, что и правила именования переменных. Если переопределить встроенную функцию AutoLISP, то она останется недоступной до тех пор, пока не будет создан новый чертёж. Строки программы составляют ядро функции. Порядок оценки их вычислителем AutoLISP уже обсуждался. Последнее возвращаемое значение передается в среду AutoCAD - AutoLISP.</P>

<P>При запуске графического редактора AutoCAD загружает файл acad.lsp (если он существует) автоматически. В этот файл можно внести определения наиболее часто используемых функций, и они будут загружаться автоматически при вызове графического редактора. При этом на экране появится сообщение</P>

<P Class=h5>Loading acad.lsp...loaded.<Br>
Загружаю acad.lsp...загружен.</P>

<P>При определении функции при помощи DEFUN можно указать, что она должна выполняться автоматически сразу же после загрузки. Для этого её нужно назвать S::STARTUP. Если поместить определённую таким образом функцию в файл acad.lsp, то она будет автоматически загружаться и выполняться сразу же после вызова AutoCAD.</P>

<P>Определенные пользователем функции могут быть использованы так же, как и команды AutoCAD. Это позволяет сделать программу модульной, многократно использующей подпрограммы. Чтобы пользоваться вновь созданными командами AutoCAD, функции, определённые с помощью DEFUN, должны удовлетворять следующим условиям:</P>

<Ul>
 <Li>Имя функции должно быть вида С:ХХХ. Причем, если вы работаете в русском AutoCAD, все буквы должны быть прописными. Буква "С" набирается в латинском регистре. Часть имени "С:" должна присутствовать всегда, а часть имени ''XXX" может быть любой, но не должна дублировать какую-либо команду AutoCAD, внешнюю или встроенную функцию.</Li>
 <Li>Функция должна быть определена без аргументов. Допускаются только локальные символы.</Li>
</Ul><Br><Br>
<Hr Width="90%" Color="#7685C6" Align="Right">
</Div>
</Div>




<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Функции присвоения" style="display: none;"></a>
<P>Присвоение переменным значений осуществляется в AutoLISP не так, как в других языках программирования. Для присвоения переменным значений в AutoLISP имеется специальная функция SETQ, которая присваивает переменной нужное нам значение, т. е. заносит указанное нами значение в ячейку с именем переменной. Алгебраическая запись присвоения - х = 3. В AutoLISP то же действие записывается как (setq х 3). Это связано с тем, что, как уже отмечалось, AutoLISP -функциональный язык и в нем нет операторов (в том числе и оператора присвоения), а есть функции, производящие определенные действия над своими параметрами.</P>
<P>После того как вы присвоили некоторой переменной значение, вы можете в любое время посмотреть ее значение с командной строки AutoCAD. Восклицательный знак "!", введенный с командной строки, сообщает интерпретатору командной строки AutoCAD, что следующий за ним идентификатор является именем переменной AutoLISP. Встретив восклицательный знак, интерпретатор командной строки передает следующее за ним имя AutoLISP, который возвращает обратно значение переменной с этим именем.</P>

<P>Что такое SET - понятно: "положить", а что означает SETQ? Загадочная буква "q" в функции присвоения SETQ происходит от сокращения английского слова "quote" - буквально "цитировать". Функция SETQ является мнемоническим сокращением английского словосочетания "SET by Quote" - "присвоить по ссылке". Прежде чем разобраться, что это означает, нужно понять, как хранятся в машине значения переменной. Дело в том, что переменная и ее значение не одно и то же. На первый взгляд такое утверждение кажется тривиальным, однако когда мы говорим "переменная", то чаще всего подразумеваем "значение, которое хранится в переменной". Специфика AutoLISP заключается в.том, что в переменной может храниться не только значение, но и целое, выражение, а если быть точным, то его адрес. Функция SETQ позволяет об этом не задумываться и считает, что мы обращаемся к значению переменной. В одной функции SETQ можно осуществить несколько присваиваний:</P>

<pre><code> (setq a "Новый" b 3.14 с '(34.0 77.6 55.4))</code></pre>

<P>Однако в AutoLISP есть также функция SET, которая считает, что мы обращаемся к самой переменной. Прежде чем проиллюстрировать сказанное на примерах, отметим, что для обращения к значению переменной в AutoLISP существует специальная функция '(quote выражение), которая возвращает само выражение, не выполняя его (фактически возвращает ссылку на выражение). Эта функция очень часто используется в AutoLISP и поэтому имеет сокращенную запись: 'выражение. Так, (quote А) эквивалентно 'А.</P>

<P>Теперь продемонстрируем работу функций SETQ и SET:</P>

<pre><code> (set 'A 5.0)</code></pre>

<P>Возвращает 5.0 и присваивает это значение А.</P>
<P>Эта запись эквивалентна записи (setq a 5.0)</P>

<pre><code> (set 'В '(+ А С))</code></pre>

<P>Возвращает выражение (А+С) и присваивает его В.</P>
<P>Итак, в переменной хранится выражение! Причем это именно выражение, а не текстовая константа - изменяя значения переменных А и С, мы изменяем тем самым значение переменной В. Эта запись эквивалентна записи</P>

<pre><code> (setq В '(+ А С))</code></pre>

<P>Обратившись к специальной функции EVAL ("evaluate" -."оценивать"), можно в любой момент вычислить выражение В. Предположим, что перед выполнением предыдущей строки мы положили (setq A 3) и (setq С 6). Тогда</P>

<pre><code> (eval В)</code></pre>
<P>Возвращает 9.</P>
<P>Если две переменные "вложены" друг в друга, то к младшей можно обращаться через старшую, т. е. косвенно. Выполните следующую последовательность функций:</P>

<pre><code> (set  'В 'А)</code></pre>

<P>Устанавливает А в В и возвращает А.</P>

<pre><code> (set В 640)</code></pre>

<P>Устанавливает А в 640 и возвращает 640.</P>
<P>По сути, в функции (set В 640) сначала вычисляется значение В, потом результату этого вычисления присваивается 640.</P>
<Br><Br>
<Hr Width="90%" Color="#7685C6" Align="Right">
</Div>
</Div>




<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Работа со списками" style="display: none;"></a>
<P>Список - это группа элементов любого допустимого в AutoLISP типа. Список AutoLISP может содержать любое количество действительных и целых чисел, строк, переменных или других списков. Все, что находится между открывающей и закрывающей круглыми скобками, - список. Списки удобно использовать для организации и обработки больших массивов связанных данных. AutoLISP имеет развитые средства работы со списками. Они вкратце описаны ниже.</P>
<pre><code> (list выражение 1 выражение2)</code></pre>


<P>Эта функция просто составляет список из своих аргументов. Например, выражение (list 5.5 8.0) возвращает список, содержащий два действительных числа: (5.5 8.0); этот способ часто используется в AutoLISP для создания новых точек из известных координат. Подчеркнем, что при составлении списка функция list оценивает выражения-элементы.</P>
<pre><code> (quote выражение) или 'выражение</code></pre>


<P>Функция quote (буквально - "цитировать") подавляет оценку своего выражения. Это бывает нужно при формировании списка. Например, выражение (list 'а 'Ь 'с) формирует список (a b с).</P>
<P>Поскольку список представляет собой группу элементов, может возникнуть необходимость извлечения одного элемента из списка. Существует две простейшие функции извлечения элементов списка:</P>
<pre><code> (car список)</code></pre>


<P>Возвращает первый элемент списка. Если список пуст, возвращается nil;</P>
<pre><code> (cdr список)</code></pre>


<P>Возвращает все элементы списка, кроме первого. Если список пуст, возвращается nil. Если элементом списка является точечная пара, функция возвращает последний элемент, не заключая его в список.</P>
<P>Из этих простейших функций, как из кирпичиков, составлены сцепления функций извлечения элементов списка вплоть до четырех уровней вложенности:</P>
<pre><code> (сааr х)эквивалентно(car (car x))
 (cdar х)эквивалентно(cdr (car x))
 (cadar х)эквивалентно(car (cdr (car x)))
 (cadr x)эквивалентно(car (cdr х))
 (cddr х)эквивалентно(cdr (cdr х))
 (caddr х)эквивалентно(car (cdr (cdr х)))</code></pre>

<P>В AutoLISP CADR часто используется для "извлечения" координаты Y двумерной или трехмерной точки, а CADDR - для извлечения координаты Z. Для этой же цели можно воспользоваться функцией nth:</P>

<pre><code> (nth номер список)</code></pre>


<P>Извлекает элемент списка с нужным номером.</P>
<P>Однако будьте осторожны при работе с этой функцией: первый элемент списка имеет номер 0, а не 1 (функция nth считает не 1, 2, 3,..., а 0, 1, 2, 3, ...). Так считает машина, однако вам-то от этого не легче - учтите, что в счете элементов списков у функций AutoLISP нет единообразия, поэтому нужно быть внимательным. Кроме того, к средствам поддержки списков относятся функции:</P>

<pre><code> (last список)</code></pre>


<P>Возвращает последний элемент списка, причем список не должен быть равен nil. HE РЕКОМЕНДУЕТСЯ использовать эту функцию для извлечения Y- или Z-координаты точки, поскольку это требует дополнительных усилий по поддержке правильной размерности точек;</P>
<pre><code> (reverse список)</code></pre>


<P>Возвращает список с элементами, переставленными в обратном порядке;</P>
<pre><code> (length список)</code></pre>

<P>Возвращает целое число, равное числу элементов в списке;</P>
<pre><code> append выражение1 выражение 2 ...)</code></Pre>
<P>Берет любое число выражений (списков) и сливает их в один список;</P>
<pre><code> (cons выражение список)</code></pre>


<P>Эта функция, наряду с функцией list, используется для создания списков. Она добавляет в начало списка новый элемент, которым может быть также и выражение.</P>
<P>Кроме этих простейших функций существуют функции assoc и subst, позволяющие работать со структурированными списками, подобно структурам в других языках программирования.</P>

<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>
</Div>




<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Математические функции" style="display: none;"></a>
<P>AutoLISP включает в себя достаточно широкий набор встроенных функций, позволяющих производить математические вычисления. Аргументами математических функций являются числа, которые могут быть как целыми, так и вещественными. Если все аргументы - целые числа, то результат операции также будет целым числом, а любая дробная часть будет опущена. Если хотя бы один аргумент - вещественное число, то результат операции будет вещественным числом. (Следует отметить, например, что число 2.0 считается вещественным, поскольку в нем присутствует десятичная точка.) К математическим функциям относятся:</P>


<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td Width=151><P Class=tcb>Функция</P></Td>
 <Td><P Class=tcb>Назначение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(+ число1 число2 ...)</P></Td>
 <Td><P Class=tl>Возвращает сумму всех аргументов</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(- число1 число2 ...)</P></Td>
 <Td><P Class=tl>Вычитает число2 из числа1 и возвращает разность. Если задано более двух аргументов, то из первого аргумента вычитается сумма всех остальных. Если задан один аргумент, то он вычитается из нуля (инвертируется его знак)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(* число1 число2 ...)</P></Td>
 <Td><P Class=tl>Возвращает произведение всех чисел</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(/ число1 число2 ...)</P></Td>
 <Td><P Class=tl>Делит число 1 на число2 и возвращает частное. Если задано более двух аргументов, то первое число делится на произведение всех остальных</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(1+ число)</P></Td>
 <Td><P Class=tl>Увеличение целого или действительного аргумента на единицу</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(1- число)</P></Td>
 <Td><P Class=tl>Уменьшение целого или действительного аргумента на единицу</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(atan число1 [число2])</P></Td>
 <Td><P Class=tl>Если не задано число2, то возвращает арктангенс переменной число1 в радианах, область допустимых значений - [pi,-pi] радиан. Если заданы оба числа, то возвращается арктангенс переменной число 1/число2 в радианах. Если число2 - нуль, то в зависимости от знака переменной число1 возвращается + или -1.570796 радиан (+90 или -90)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(abs число)</P></Td>
 <Td><P Class=tl>Вычисление абсолютного значения действительного или целого числа</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(sin число)</P></Td>
 <Td><P Class=tl>Возвращает значение синуса угла, заданного аргументом в радианах</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(cos число)</P></Td>
 <Td><P Class=tl>Возвращает значение косинуса угла, заданного аргументом в радианах</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(ехр степень)</P></Td>
 <Td><P Class=tl>Вычисляет значение экспоненциальной функции с основанием е и аргументом, равным числу</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(expt основание степень)</P></Td>
 <Td><P Class=tl>Вычисляет значение экспоненциальной функций с указанными основанием и степенью</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(gcd число1 число2)</P></Td>
 <Td><P Class=tl>Возвращает наибольший общий делитель (Greatest Соmmon Denominator) указанных аргументов</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(log число)</P></Td>
 <Td><P Class=tl>Возвращает натуральный логарифм аргумента</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(max число1 число2 ...)</P></Td>
 <Td><P Class=tl>Возвращает наибольший аргумент. Эта функция в отличие от многих других не изменяет типов чисел</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(min число1 число2 ...)</P></Td>
 <Td><P Class=tl>Возвращает наименьший аргумент. Не изменяет типов чисел</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(rem число1 число2 ...)</P></Td>
 <Td><P Class=tl>Возвращает остаток (Remainder) от деления переменной число1 на переменную число2 (математическая запись: число1 mod число2)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(sqrt число)</P></Td>
 <Td><P Class=tl>Извлекает квадратный корень из аргумента. Возвращаемый результат всегда вещественный</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(lsh число1 числобит)</P></Td>
 <Td><P Class=tl>Возвращает побитовый сдвиг числа1 на число числобит. Оба аргумента должны быть целыми, результат тoжe будет целым. Если числобит положительно, то число1 сдвигается влево (оно умножается на 2 в степени числобит), если отрицательно - сдвигается вправо (делится на 2 степени числобит нацело с отбрасыванием остатка). В каждом случае "нулевые" биты добавляются, а сдвигаемые биты сбрасываются. Если "единичный" бит сдвигается в высший, 1б-й разряд целого числа, знак числа меняется</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>pi</P></Td>
 <Td><P Class=tl>Константа, равная 3.1415926</P></Td>
</Tr>
</Table></Center><Br>

<P>Функции AutoLISP могут быть, за очень редким исключением, вложенными. Например, чтобы вычислить корень квадратный из суммы квадратов двух чисел, можно записать</P>
<pre><code> (setq a (sqrt (+ (*c c) (*b b))))</code></pre>

<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>
</Div>




<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Логические функции AutoLISP" style="display: none;"></a>

<P>AutoLISP предоставляет богатые возможности конструирования логических выражений и выполнения над ними логических операций.</P>
<P>Логический оператор - это функция, сравнивающая между собой два или больше аргумента. Результат сравнения (т. е. некоторое утверждение, касающееся двух аргументов) может быть либо истиной (Т), либо ложью (nil). Основные логические функции&nbsp;- это И (AND), ИЛИ (OR) и НЕ (NOT):</P>

<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Логическое выражение</P></Td>
 <Td><P Class=tcb>Результат</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(and выражение1 выражение2 ...)</P></Td>
 <Td><P Class=tl>Возвращает результат выполнения логического И над списком выражений. Возвращается nil, если любое (хотя бы одно) из выражений имеет значение nil, в противном случае - Т</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(not элемент)</P></Td>
 <Td><P Class=tl>Возвращает результат выполнения логического НЕ над своим аргументом</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(or выражение 1 выражение2 ...)</P></Td>
 <Td><P Class=tl>Возвращает результат выполнения логического ИЛИ над списком выражений. Возвращается nil, если все аргументы имеют значение nil; если при оценке аргументов слева направо встречается выражение не - nil, возвращается Т</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(= атом1 атом2 ...)</P></Td>
 <Td><P Class=tl>Возвращает Т, если все атомы равны, в противном случае возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(/= атом1 атом2)</P></Td>
 <Td><P Class=tl>Возвращает Т, если атом1 не равен атому 2. В противном случае возвращается nil. Функция не определена для числа аргументов большего двух</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(&lt; атом1 атом2...)</P></Td>
 <Td><P Class=tl>Возвращается Т в том случае, если каждый последующий атом меньше предыдущего. В противном случае возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(&lt;= атом1 атом2 ...)</P></Td>
 <Td><P Class=tl>Возвращается Т в том случае, если каждый последующий атом меньше или равен предыдущему. В противном случае возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(> атом1 атом2 ...)</P></Td>
 <Td><P Class=tl>Возвращается Т в том случае, если каждый последующий атом больше предыдущего. В противном случае возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(>= атом1 атом2 ...)</P></Td>
 <Td><P Class=tl>Возвращается Т в том случае, если каждый последующий атом больше или равен предыдущему. В противном случае возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(eq выражение1 выражение2)</P></Td>
 <Td><P Class=tl>Определяет, идентичны ли выражение1 и выражение2, т. е. являются ли они фактически одним объектом или нет (т. е. порожден ли один из другого при помощи функции SETQ). EQ возвращает Т, если оба выражения идентичны, в противном случае - nil. Обычно функция применяется для определения, являются ли два списка фактически одним или нет. Например, пусть<Br>
(setq f1 '(а b с))<Br>
(setq f2 '(a b c))<Br>
(setq f3 f2)<Br>
Тогда (eq fl f3) возвращает nil (f1 и f3 - разные списки), a (eq f3 f2) возвращает Т (f3 и f2 - один и тот же список) (См. также ниже функцию EQUAL.)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(equal выражение1 выражение2 [допуск])</P></Td>
 <Td><P Class=tl>Определяет, равны ли выражение 1 и выражение2, т. е. равны ли их значения. Например, пусть<Br>
(setq f1 '(a b с))<Br>
(setq f2 '(a b с))<Br>
(setq f3 f2)<Br>
Тогда (equal fl f3) возвращает Т (значением fl и f3 является одно и то же ), a (equal f3 f2) возвращает Т (f3 и f2 - в точности один и тот же список). Заметим, что, если оба списка EQUAL, они могут не быть EQ. Атомы, которые EQUAL, всегда к тому же EQ. Добавим, что два списка, которые EQ, всегда EQUAL.<Br>
При сравнении двух действительных чисел (или двух списков действительных чисел, например точек) важно осознавать, что два "идентичных" числа могут незначительно отличаться друг от друга, если они вычислялись различными методами. Однако факультативный численный аргумент допуск позволяет задать максимальную точность, с которой могут отличаться друг от друга выражение1 и выражение2, оставаясь при этом EQUAL. Например, пусть<Br>
(setq a 1.123456)<Br>
(setq b 1.123457)<Br>
Тогда<Br>
(equal а Ь)возвращает nil<Br>
(equal a b 0.000001) возвращает Т</P></Td>
</Tr>
</Table>
<Br >


<P>Кроме логических операций, производимых над выражениями как над целыми объектами, AutoLISP включает в себя встроенные функции, производящие логические операции побитово над целыми числами:</P>

<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Логическая операция</P></Td>
 <Td><P Class=tcb>Результат</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(~ целое)</P></Td>
 <Td><P Class=tl>Возвращает логическое НЕТ (дополнение до единицы) своего аргумента. Аргумент должен быть целым числом</P></Td>
</Tr>


<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(Boole кодфункции целое1 целое2 ...)</P></Td>
 <Td><P Class=tl>Определяет битовую функцию Булевой алгебры, производимой над двумя целыми аргументами. Функции кодируются следующим образом:
<Table Border="1" CellPadding="2" CellSpacing="1">
<Tr BgColor="#D1D6E9">
 <Td><P Class=tcb><I>Целое1</I></P></Td>
 <Td><P Class=tcb><I>Целое2</I></P></Td>
 <Td><P Class=tcb><I>Функция</I></P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tc>8</P></Td>
</Tr>
<Tr>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>4</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tc>2</P></Td>
</Tr>
<Tr>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>1</P></Td>
</Tr>
</Table>
<P>Некоторые значения этой функции эквивалентны стандартным булевым операциям:</P>
<Table Border="1" CellPadding="2" CellSpacing="1">
<Tr BgColor="#D1D6E9">
 <Td><P Class=tcb><I>Код функции</I></P></Td>
 <Td><P Class=tcb><I>Булева функция</I></P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>И</P></Td>
</Tr>
<Tr>
 <Td><P Class=tc>6</P></Td>
 <Td><P Class=tc>Исключающее ИЛИ</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>7</P></Td>
 <Td><P Class=tc>ИЛИ</P></Td>
</Tr>
<Tr>
 <Td><P Class=tc>8</P></Td>
 <Td><P Class=tc>НЕТ</P></Td>
</Tr>
</Table>
</P></Td>
</Tr>


<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(minusp элемент)</P></Td>
 <Td><P Class=tl>Функция возвращает Т, если элемент является целым или действительным отрицательным числом. В противном случае возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(zerop элемент)</P></Td>
 <Td><P Class=tl>Функция возвращает Т, если элемент является целым или действительным нулем. Иначе возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(numberp элемент)</P></Td>
 <Td><P Class=tl>Функция возвращает Т, если элемент является целым или действительным числом. Иначе возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(logand число число ...)</P></Td>
 <Td><P Class=tl>Функция возвращает результат действия побитового И над списком чисел. Числа должны быть целыми, и результат будет целым. Работает функция следующим образом. Каждое число представляется в двоичном виде; затем соответствующие разряды чисел собираются в список. Если в этом списке находится хотя бы один нуль, соответствующий разряд результирующего числа будет нулем; если в списке все единицы, разряд результирующего числа равен единице</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(logior число число ...)</P></Td>
 <Td><P Class=tl>Функция возвращает результат действия побитового ИЛИ над списком чисел. Числа должны быть целыми, и результат будет тоже целым. В этой функции каждое число также представляется в двоичном виде; затем соответствующие разряды чисел собираются в список. Если в этом списке находится хотя бы одна единица, соответствующий разряд результирующего числа будет единицей; если в списке все нули, разряд результирующего числа равен нулю</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(listp элемент)</P></Td>
 <Td><P Class=tl>Возвращает Т, если элемент является списком, в противном случае - nil</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(atom элемент)</P></Td>
 <Td><P Class=tl>Возвращает nil, если элемент является списком, в противном случае - Т. Любой элемент, который не является списком, считается атомом</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(null элемент)</P></Td>
 <Td><P Class=tl>Функция возвращает Т, если элемент вычисляется в nil, в противном случае - nil</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(boundp атом)</P></Td>
 <Td><P Class=tl>Функция возвращает Т, если атом имеет некоторое значение, в противном случае - nil</P></Td>
</Tr>
</Table>
<Br>
<hr width="90%" color="#7685C6" align="Right">
</Div>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Условное ветвление программ" style="display: none;"></a>
<P>Каждая программа имеет свою логическую структуру. Ветвление&nbsp;- это способ управления ходом выполнения программы. Условные операторы&nbsp;- это
средство управления ветвлением программ. AutoLISP имеет две функции ветвления, if и COND. Условное ветвление подразумевает проверку какого-то условия, по
результатам которой осуществляется переход. Условия содержатся в условных выражениях, использующих операторы отношения и логические операторы. Условные
выражения могут содержать любые выражения AutoLISP.</P>
<pre><code> (if c f1 [f2])</code></pre>

<p>Здесь<Br>
с - условие (простое или сложное);<Br>
f1 - функция, выполняемая, если условие истинно (выражение-тогда),<Br>
f2 - функция, выполняемая, когда условие ложно (выражение-иначе).</P>

<P>Эта функция использует выражение по условию. Если условие не nil, то исполняется выражение-тогда, в противном случае - выражение-иначе. Последнее
выражение не обязательно. Возвращает значение выполненного по условию выражения; если выражение-иначе отсутствует и тест-выражение - nil, то if
возвращает nil.</P>

<P>Пример:</p>

<pre><code> (if ( < a 0 ) 
  ( prompt "\nПеременная a меньше нуля" )
  ( prompt "\n"Переменная a больше или рана нулю" ))</code></pre>

<P>А как быть, если нужно в случае выполнения (или невыполнения) условия выполнить не одну, а сразу несколько функций? Ведь синтаксис функции if
разрешает записать только одну. Проблема решается так же, как в языке Паскаль: там используются операторные скобки begin..end, а в Лиспе - функция
(progn f1 f2 .. fn). Она всего лишь объединяет функции f1 f2 .. fn в один блок, который можно подставить в функцию if. </p>
<P>Например, мы решаем квадратное уравнение и в переменную d записали дискриминант. Теперь нужно посчитать действительные корни и вывести их на экран:</P>

<pre><code> (if ( >= d 0 )
   ( progn
     ( setq x1 ( / ( + ( * b -1 ) ( sqrt d ) )
     ( * 2 a ) )
     ( setq x2 ( / ( - ( * b -1 ) ( sqrt d ) )
     ( * 2 a ) )
     ( prompt "\nX1=" )
     ( print x1 )
     ( prompt "\nX2=" )
     ( print x2 )
     ); конец progn
   ( prompt "\nДействительных корней нет" ); "иначе"
 )</code></pre>

<P>Иногда требуется по условию выполнить не одно, а несколько выражений, в то время как функция if не позволяет этого. В этом случае используют функцию
PROGN, которая последовательно вычисляет каждое выражение и возвращает значение последнего: (progn выражение1 выражение2 ...). Например:</P>


<pre><code> (if (= a b)
  (progn
   (setq a (+ а 10))
   (setq b (- b 10))
  )
 )</code></pre>
<pre><code>(cond (тест1 результат1 ...)...) </code></pre>

<P>Воспринимает в качестве аргументов любое число списков. Она оценивает по очереди первые элементы списков до тех пор, пока не встретится элемент,
отличный от nil. Затем вычисляется то выражение, которое следует за тестом, и возвращается значение последнего выражения в субсписке. Если в субсписке
только одно выражение (например, результат отсутствует), то возвращается значение выражения тест. COND - основная функция условия в AutoLISP. Как видно
из следующего примера, в котором функция COND возвращает нуль или единицу в зависимости от введенной пользователем строковой переменной s, эта функция
может использоваться в качестве условного оператора переключения ("case" во многих языках программирования):</P>
<pre><code> (cond
  ((= s "Y") 1)
  ((= s "y") 1)
  ((= s "Д") 1)
  ((= s "д") 1)
  ((= s "N") 0)
  ((= s "n") 0)
  ((= s "Н") 0)
  ((= s "н") 0) </code></pre>

<P>Продолжая рассматривать параллели с Паскалем, обратимся к функции cond, обеспечивающей множественное ветвление аналогично паскалевскому оператору CASE. Ее общий вид:</P>
<pre><code> ( cond 
 ( c1 f11 f12 ... f1n1 )
 ( c2 f21 f22 ... f2n1 )
 ...
 ( cm fm1 fm2 ... fmnm )
 )</code></pre>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=95%>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<p>Здесь с1 ..cm - логические условия, fnm - функции, выполняемые при выполнении того или иного условия.</p>
<Tr><Td Valign=ToP><P Class=pr>Замечание:&nbsp;&nbsp;</P></Td>
<Td Valign=Center><P Class=prt>Условия проверяются последовательно до первого истинного. Если истинно сразу несколько условий, то выполняются только функции, относящиеся к первому из них, а остальные условия даже не проверяются.</P></Td></Tr>

<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<P>Основное назначение функции cond - обработка ввода пользователя, например, так:</P>
<pre><code> ( setq a ( getint "\n1 - фаска, 2 - галтель, 3 - выточка" ) )
 ( cond
  ( ( = a 1 ) .... ); фаска
  ( ( = a 2 ) .... ); галтель
  ( ( = a 3 ) .... ); выточка
 )</code></pre>

<p>А вот пример неправильного применения  функции cond. Пусть мы хотим присвоить переменной flag значение nil, если хотя бы одна из сторон треугольника a, b, c оказалась отрицательной. Неопытному программисту вместо очевидного</p>
<pre><code> ( setq flag ( not
 ( or ( <= a 0 ) ( <= b 0 ) ( <= c 0 ) ) ) )</code></pre>

<p>может прийти в голову следующая пагубная идея:</p>
<pre><code> ( setq flag nil )
 ( cond
  ( ( > a 0 ) ( setq flag T ) )
  ( ( > b 0 ) ( setq flag T ) )
  ( ( > c 0 ) ( setq flag T ) )
 )</code></pre>
<P>Программа выглядит работоспособной, но представим себе, что будет происходить при следующих исходных данных: a=10, b=-5, c=2. Функция COND проверит первое условие a>0, убедится в его истинности, установит переменную flag в T и остальные условия вообще проверять не будет! Поэтому тот прискорбный факт, что сторона b меньше нуля, останется незамеченным.</P>

</Div>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Организация циклов" style="display: none;"></a>

<P>Как и многие языки программирования, AutoLISP имеет средства организации повтора выполнения групп операторов. Циклы полезны, например:</P>
<Ul>
 <Li>для уменьшения числа операторов в программе (в случае повтора однотипных действий);</Li>
 <Li>для повтора выполнения процедуры до отмены ее пользователем;</Li>
 <Li>для получения решения математической задачи со сходимостью;</Li>
 <Li>для пакетной обработки списков данных (например, при работе DXF-файлом).</Li>
</Ul>

<P>Операторы организации циклов AutoLISP аналогичны командам циклов в других структурных языках. Следует отметить, однако, определенную бедность AutoLISP в этом отношении, обусловленную, вероятно, его спецификой.</P>
<P>Простейшим оператором повтора является оператор REPEAT. Эта функция повторяет любое число операторов указанное число раз. Возвращается последнее значение последнего выражения цикла. Синтаксис:</P>

<P Class=h5>(repeat число выражение1 выражение2 ...)</P>
<pre><code>(setq a 10 b 100)
 (repeat 4
  (setq a (+ a 10))
  (setq b (+ b 100))
 )</code></pre>
<P>Функция WHILE похожа на функцию REPEAT, однако число повтора не определено, а выход из цикла осуществляется по условию. В отличие от структуры IF оператор WHILE не включает в себя выполнение какого-либо выражения в том случае, если условие не выполняется. Как COND, REPEAT и PROGN, WHILE позволяет включать в свое тело неограниченное число операторов. В начале выполнения каждого цикла проверяется условие и, если оно выполняется, выполняется тело цикла, после чего опять проверяется условие, и так до тех пор, пока выражение-условие не станет ложным. Будьте внимательными: неаккуратное использование цикла WHILE может привести к зацикливанию программы. Цикл WHILE возвращает значение последнего вычисленного перед выходом из цикла выражения. Если выражение-условие изначально было ложным и вхождения в тело цикла не было, WHILE возвращает nil. Функцию WHILE удобно использовать для проверки правильности ввода, зацикливая ввод до тех пор, пока введенные данные не будут удовлетворять каким-то условиям (прежде чем использовать для этих целей функцию WHILE, убедитесь, что ту же задачу нельзя решить обычными средствами AutoLISP - getkword). Цикл WHILE можно использовать также для организации итераций. Итерация - это процесс повторения группы вычислений до тех пор, пока результат вычисления одного или более выражений не станет удовлетворять какому-то условию. Условное выражение итерационного цикла WHILE обычно содержит некоторую переменную, значение которой изменяется в процессе выполнения тела цикла. Синтаксис WHILE:</P>

<pre><code> (while тест-выражение выражение1 выражение2 ...)</code></pre>
<Br>
<pre class="lisp"><code> (setq test 1)
 (while (<= test 10)
  (some-func test)
  (setq test (1+ test))
 )</code></pre>
<P>Еще одним типом функции-организатора цикла является функция FOREACH (буквально "для каждого"). Это специальное средство AutoLISP, предназначенное для работы со списками. Синтаксис:</P>

<pre><code> (foreach имя список выражение1 выражение2 ...)</code></pre>

<P>Эта функция, проходя по списку, присваивает каждому элементу имя и вычисляет каждое выражение для каждого элемента списка. Может быть задано неограниченное число выражений. Возвращается результат последнего вычисленного выражения. Например,</P>

<pre><code> (foreach n '(а b с) (print n))

 эквивалентно

 (print a)
 (print b)
 (print с)</code></pre>
<P>с той разницей, что FOREACH возвращает только значение последнего вычисленного выражения.</P>
<pre><code>(apply функция список)</code></pre>

<P>Данная функция выполняет функцию с аргументом, заданным списком.</P>
<P>Для выполнения какой-либо одной операции над всеми элементами одного или нескольких списков служит функция</P>
<pre><code> (mapcar функция список1 список2 ...списокN)</code></pre>

<P>Число списков должно соответствовать числу аргументов, требующихся для функции. Функции возвращают список результатов.</P>
<P>Если вам необходимо использовать свою функцию, она должна быть заранее определена с помощью DEFUN. Однако в AutoLISP есть механизм создания так называемой анонимной функции</P>
<pre><code> (lambda аргументы выражение ....)</code></pre>

<P>Она применяется вместе с MAPCAR и APPLY.</P>

<P>Примеры:</P>
<pre><code> (apply '+ '(1 2 3))
 возвращает 6

 (apply '(lambda (x у z)
  (* x (-y z))
  )
  '(5 20 14)
 )
 возвращает 30

 (mapcar '(lambda (x у)
  (/ (+ x y) 2.0))
  '(1 2 3) '(5 6 7)
 )
 возвращает (3.0 4.0 5.0)</code></pre>

<P>Самым значительным отличием языков семейства LISP от других языков высокого уровня является возможность конструирования функций языка самой программой. Сначала вы можете составить выражение, а затем его выполнить. Для выполнения сконструированного выражения служит функция</P>

<P Class=h5>(eval выражение)</P>
<P Class=h5>Пример:</P>
<pre><code> (setq a '(max))
 (while (not (setq b (getreal "\Введите число: ")))
 (setq a (cons b a)))
 (setq a (reverse a))
 (eval a)</code></pre>

<P>В этом достаточно сложном примере последовательно вводятся числа, заносимые в список до тех пор, пока их ряд не закончится пустым вводом. В конце списка оказалось имя функции МАХ. Затем этот список переворачивается так, чтобы имя функции оказалось на первом месте. Применение функции EVAL к полученному списку возвращает максимальное из введенных чисел.</P>

<hr width="90%" color="#7685C6" align="Right">
</Div>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Работа со строками, функции преобразования" style="display: none;"></a>

<P>Среди встроенных функций AutoLISP, работающих со строками, можно найти практически, всё, что имеется в любом развитом языке высокого уровня:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Функция</P></Td>
 <Td><P Class=tcb>Назначение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(itoa целое)</P></Td>
 <Td><P Class=tl>Возвращает результат преобразования целого числа в строковую константу</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(atoi строка)</P></Td>
 <Td><P Class=tl>Возвращает преобразование строковой константы в целое число</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(atof строка)</P></Td>
 <Td><P Class=tl>Возвращает преобразование строковой константы в действительное число</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(strcase строка признак)</P></Td>
 <Td><P Class=tl>Переводит все символы аргумента строка в нижний регистр, если признак не nil, если признак опущен или равен nil - в верхний</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(substr строка целое1 целое2)</P></Td>
 <Td><P Class=tl>Возвращает подстроку аргумента строка, начинающегося с символа целое1 и длиной целое2. Первый символ строки имеет номер 1</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(strlen строка)</P></Td>
 <Td><P Class=tl>Возвращает длину в символах аргумента строка</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(strcat строка1 строка2 ...)</P></Td>
 <Td><P Class=tl>Осуществляет сцепление аргументов строка</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(chr число)</P></Td>
 <Td><P Class=tl>Возвращает результат преобразования целого числа в символьный код ASCII, причем результатом является строковая константа. Например, (chr 65) возвратит символ (строковую константу) "А" (подобным образом действует функция CHR$ в языке Бейсик)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(ascii строка)</P></Td>
 <Td><P Class=tl>Возвращает преобразование одного символа, указываемого в виде строковой константы, в код ASCII</P></Td>
</Tr>
</Table></Center>




<P>В любой момент можно преобразовать целое число в действительное и наоборот:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Функция</P></Td>
 <Td><P Class=tcb>Назначение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(fix число)</P></Td>
 <Td><P Class=tl>Возвращает результат преобразования действительного числа в целое. Преобразование осуществляется усечением (отбрасыванием) дробной части</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(float число)</P></Td>
 <Td><P Class=tl>Возвращает результат преобразования целого числа в действительное</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(rtos число [режим [точность]])</P></Td>
 <Td><P Class=tl>

 Возвращает текстовую строку, которая представляет число (вещественная величина) в соответствии со значениями режима, точности и системной переменной AutoCAD DIMZIN.<Br>
Режим и точность - целые числа, которые назначают режим представления числа и его точность:



<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Режим RTOS</P></Td>
 <Td><P Class=tcb>Описание</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>1</P></Td>
 <Td><P Class=tl>Научный</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>2</P></Td>
 <Td><P Class=tl>Десятичный</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>3</P></Td>
 <Td><P Class=tl>Инженерный (футы и десятичные дюймы)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>4</P></Td>
 <Td><P Class=tl>Архитектурный (футы и дробные дюймы)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>5</P></Td>
 <Td><P Class=tl> Произвольные дробные части</P></Td>
</Tr>
</Table>



Аргументы режим и точность соответствуют системным переменным AutoCAD LUNITS и LUPREC. Если эти аргументы отсутствуют, то используются текущие значения LUNITS и LUPREC.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(type элемент)</P></Td>
 <Td><P Class=tl>

 Возвращает тип элемента<Br>
Используя функцию type, можно определить тип элемента. Пример использования функции TYPE:


<Table>
<Tr>
<Pre><code> (defun isint (a)
 (if (= (type a) 'INT) ;является ли а целым?
 T             ;если да - возвращаем ИСТИНУ
 nil           ;если нет - возвращаем nil 
 )</code></Pre>
 
</Tr>
</Table>

 </P></Td> 
</Tr>
</Table></Center>
<Br> 

<P>Строка может включать управляющие символы, которые интерпретируются следующим образом:</P>
<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Символ</P></Td>
 <Td><P Class=tcb>Значение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>\\\</P></Td>
 <Td><P Class=tl>символ \</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>\"</P></Td>
 <Td><P Class=tl>символ "</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>\е</P></Td>
 <Td><P Class=tl>символ escape-последовательности</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>\n</P></Td>
 <Td><P Class=tl>переход на новую строку</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>\r</P></Td>
 <Td><P Class=tl>возврат каретки</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>\t</P></Td>
 <Td><P Class=tl>табуляция</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>\nnn</P></Td>
 <Td><P Class=tl>символ с восьмеричным кодом nnn</P></Td>
</Tr>
</Table></Center>


<hr width="90%" color="#7685C6" align="Right">
</Div>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Работа с файлами: ввод/вывод" style="display: none;"></a>


<P>Средства работы с файлами в AutoLISP не слишком развиты, однако для большинства повседневных нужд этого вполне достаточно. При работе с файлами, как и в других языках программирования, следует придерживаться следующей схемы: сначала файл необходимо открыть, при этом будет создана специальная файловая переменная (дескриптор файла), затем можно выполнять операции чтения/записи, после чего файл должен быть закрыт.</P>
<pre><code> (open имя_файла режим)</code></pre>

<P>Эта функция открывает файл. Возвращается дескриптор файла.</P>
<P>Функции ввода/вывода работают не с именами файлов, а с дескрипторами файлов, определяющими не только собственно файл, но и режим доступа и различные другие системные параметры. "Открыть файл" - значит подготовить дескриптор файла к использованию его функциями ввода/вывода AutoLISP. Поэтому возвращаемое функцией OPEN значение дескриптора файла должно присваиваться некоторой файловой переменной, например:</P>
<pre><code> setq f (open "file.ext" "r"))</code></pre>

<P>Здесь переменная f - дескриптор файла file.ext, открытого для чтения. Флаг чтения или записи&nbsp;- это, как и имя файла, строковая константа, состоящая из одной буквы, которая должна быть набрана на нижнем регистре. Допустимые значения флага чтения/записи:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Режим</P></Td>
 <Td><P Class=tcb>Описание</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>r</P></Td>
 <Td><P Class=tl>Открыть файл для чтения. Если файл с указанным именем не существует, возвращается nil</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>w</P></Td>
 <Td><P Class=tl>Открыть файл для записи. Если файл с указанным именем не существует, создается и открывается новый файл. Если такой файл уже существует, то хранящиеся в нем данные будут утеряны</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>a</P></Td>
 <Td><P Class=tl>Открыть файл для дозаписи. Если файл с указанным именем не существует, возвращается nil</P></Td>
</Tr>
</Table></Center>

<P>Если аргумент имя_файла указывает на несуществующий файл в режимах "w" и "а", то он создаётся. Если указано неполное имя (без пути), то файл ищется в текущем каталоге и по списку путей файлов поддержки. Имя файла может включать в себя путь (имена надкаталогов). Можно пользоваться обратной косой чертой вместо прямой косой черты. (Напомним: чтобы ввести в строку одну обратную косую черту, следует напечатать две обратных косых черты: "\\").</P>
<pre><code> (setq f (open "D:\\Lisp\\Dim.txt" "w")) возвращает #<file "Dini.txt"> (дескриптор файла)</code></pre>
<Br>
<pre><code> (close дескриптор_файла)</code></pre>

<P>Эта функция завершает все процессы, инициированные функцией OPEN. После закрытия файла использование дескриптор_файла невозможно, хотя сам дескриптор файла не изменяется. Использование функции close обязательно: все открытые файлы должны быть закрыты, иначе данные могут быть потеряны.</P>
<pre><code> Пример: (close f) возвращает ni</code></Pre>
<Br>

<pre><code> (find file имя_файла)</code></pre>

<P>Эта функция отыскивает файл имя_файла (т. е. возвращает полное имя файла по указанному основному имени файла) в каталогах, хранящих файлы AutoCAD. Сначала просматривается текущий каталог, затем каталог, в котором хранится текущий рисунок, и, наконец, каталог, имя которого записано в переменной среды ACAD. Такое полное имя можно передавать функции open.</P>
<pre><code> (read строка)</code></pre>

<P>Эта функция возвращает первый список или атом из данной строки, причем строка не должна содержать пробелов, за исключением, находящихся в списке. READ возвращает аргументы, задавая им соответствующий тип данных.</P>
<pre><code> (read-char  [дескриптор_файла])</code></pre>

<P>Считывает единичный символ из буфера клавиатуры или из открытого файла, заданного аргументом дескриптор_файла. Возвращается целое число - код ASCII считанного символа. Если дескриптор_файла не задан и буфер клавиатуры пуст, функция ожидает ввода символа (пользователь должен ввести что-либо с клавиатуры, заканчивающееся RETURN). Например, если в ответ на запрос функции read-char пользователь введет с клавиатуры "АВС" и завершит ввод нажатием клавиши RETURN, то функция read-char возвратит код 65 (код ASCII латинской буквы '"А"). При следующих трех обращениях к read-char она возвратит соответственно 66, 67 и 10 (код перевода строки). Если последует пятый вызов функции read-char, она снова будет ожидать ввода. Для унификации работы программ на AutoLISP в различных операционных системах функция read-char возвращает при чтении конца строки один символ с кодом 10.</P>
<pre><code> (read-line [дескриптор_файла])</code></pre>

<P>Данная функция считывает строку символов с клавиатуры или из открытого файла, заданного аргументом дескриптор_файла. Возвращается считываемая строка. Если достигнут конец файла, возвращается nil.</P>
<pre><code> (write-char число [дескриптор_файла])</code></pre>

<P>Эта функция записывает один символ на экран или в открытый файл, заданный аргументом дескриптор_файла. Здесь число - код ASCII символа и является возвращаемым функцией значением. Функция write-char не может записать в файл символ NUL (ASCII - код 0).</P>
<pre><code> (write-line строка [дескриптор_файла])</code></pre>

<P>Эта функция записывает строковую константу строка на экран или в открытый файл, заданный аргументом дескриптор_файла. Она возвращает строку, взятую в кавычки, и опускает кавычки при записи в файл.</P>
<pre><code> (prin1 [выражение[дескриптор_файла]])</code></pre>

<P>Данная функция выводит выражение на экран или в открытый файл, заданный аргументом дескриптор_файла, без пробелов и переходов на новую строку и возвращает выражение. Выражение может быть любым, а не только строковой константой. Если выражение - строковая константа, включающая управляющие символы, то они интерпретируются следующим образом:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Символ</P></Td>
 <Td><P Class=tcb>Значение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>\\\</P></Td>
 <Td><P Class=tl>символ \</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>\"</P></Td>
 <Td><P Class=tl>символ "</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>\е</P></Td>
 <Td><P Class=tl>символ escape-последовательности</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>\n</P></Td>
 <Td><P Class=tl>переход на новую строку</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>\r</P></Td>
 <Td><P Class=tl>возврат каретки</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>\t</P></Td>
 <Td><P Class=tl>табуляция</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>\nnn</P></Td>
 <Td><P Class=tl>символ с восьмеричным кодом nnn</P></Td>
</Tr>
</Table></Center>

<P>При использовании PRIN1 без аргументов в качестве последнего выражения определяемой пользователем функции, то после завершения работы функции все, что появится на экране, - это пустая строка.</P>
<pre><code> (princ [выражение [дескриптор_файла]])</code></pre>

<P>Данная функция в отличие от предыдущей предназначена для печати управляющих символов в выражении без расширения, т. е. так, как они могли считываться функциями типа READ-LINE.</P>
<pre><code> (print [выражение [дескриптор_файла]])</code></pre>

<P>Данная функция в отличие от предыдущей предназначена для печати выражения с новой строки с последующим пробелом.</P>
<pre><code> (terpri)</code></pre>

<P>Данная функция печатает новую строку на экране и возвращает nil. Она не используется для ввода/вывода файлов.</P>
<pre><code> (prompt сообщение)</code></pre>

<P>Данная функция высвечивает сообщение в зоне подсказок экрана и возвращает nil. Сообщение - это строка символов.</P>



<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>


<p class="h3">Функция findfile
</p>
<p>Ищет файл по имени (краткому или полному)(findfile <файл>)
</p>
<p>Если аргумент содержит имя файла без полного пути, то поиск выполняется сначала в текущем каталоге (обычно это папка Мои документы текущего пользователя), а затем по стандартным для системы AutoCAD путям поиска файлов. Возвращается полное имя файла, если файл найден, или nil — в противном случае. Аргумент должен быть текстовой строкой.</p>
<p class="h55"> Примеры (для версий 2006):
</p>
<pre style="width: 70%;"><code> (findfile "Support") возвращает "d: WAutoCAD 2006\\Support"
 (findfile  "acad.cui") возвращает 
"С:\\Documents and Settings\\ ... \\Application Data\\Autodesk\\AutoCAD 2006\\R16.2\\enu\\support\\acad.cui"</code></pre>

<p class="h3">Функция read-line
</p>
<p>Читает строку из файла с заданным дескриптором.
(read-line [<Дескриптор>])</p>
<p>Если аргумент <дескриптор> опущен, то выполняется чтение строки с клавиатуры
(строка должна закончиться нажатием клавиши <Enter>).</p>
<p>Возвращаемое  значение — текстовая  строка, прочитанная  из файла или
с клавиатуры.</p>
<p>Дескриптор содержит внутри себя информацию о текущей записи (т. е. той строке, с которой будет выполняться очередная операция чтения или записи). Сразу же после выполнения функции open дескриптор указывает на первую запись файла.
</p><p>Пример применения функции read-line
</p>
<p class="h3">Функция write-line
</p>
<p>Записывает строку, заданную аргументом <строка>, в файл с дескриптором, заданным аргументом <дескриптор>. Если аргумент <дескриптор> опущен или равен nil, то система AutoCAD выводит строку на экран. При записи строка, заданная аргументом <строка>, заносится в файл (или выводится на экран) без ограничивающих ее двойных кавычек.</p>
<pre><code> (write-line <строка> [<дескриптор>])</code></pre>
<p>Возвращаемое значение — значение аргумента <строка>. 
</p><p class="h55">Пример:</p>
<pre><code> (write-line "Плазовая книга" fo) возвращает "Плазовая книга"</code></pre>
<Br>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=95%>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>

<Tr><Td Valign=ToP><P Class=pr>Замечание:&nbsp;&nbsp;</P></Td>

<Td Valign=Center><P Class=prt> Если выполнить одно только выражение, приведенное в примере, с выводом на экран, то в командной строке к тексту без кавычек добавится еще возвращаемое значение — тот же текст в кавычках.</P></Td></Tr>

<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr></Table>
<Br>
<pre><code> Функция princ</code></pre>
<p>Записывает значение аргумента <аргумент>, который может быть любым выражением LISP (а также числом, списком, строкой, именем примитива и т. д.), в виде текстовой строки в файл с заданным дескриптором.</p>
<pre><code> (princ [<аргумент> [<дескриптор>]])</code></pre>
<p>Если аргумент <дескриптор> опущен или равен nil, то <аргумент> выводится на экран. Если <аргумент> — строка, то при записи она заносится в файл (или выводится на экран) без ограничивающих ее двойных кавычек.</p>
<p>Возвращаемое значение — значение аргумента <аргумент> (для вещественных чисел выводятся по шесть значащих цифр). Если опущены оба аргумента, то функция осуществляет так называемый тихий выход, т. е. не возвращает никакого значения, в том числе nil (чтобы не загромождать командную строку ненужными данными и сообщениями).
</p>
<p class="h55">Примеры:
</p>
<pre><code> (princ ' (4.5678123  11.1) fo) пишет в файл и возвращает (4.56781  11.1)
 (prime "Мороз" fo) пишет в файл мороз и возвращает "мороз"
 (princ) не возвращает ничего</code></pre>
<p class="h3">Функция prin1
</p>
<p>Функция аналогична princ. Но если <аргумент> — строка, то при записи она заносится в файл (или выводится на экран) с ограничивающими двойными кавычками; специальные символы (обратная косая черта, кавычки, конец строки и т. п.) предваряются обратной косой чертой.</p>
<pre><code> prin1 [<аргумент> [<дескриптор>]])</code></pre>
<p>Возвращаемое значение — значение аргумента <аргумент>. Если опущены оба аргумента, то функция prin1 тоже осуществляет тихий выход.
</p>
<p class="h55">Примеры:
</p>
<pre><code> (prin1 '(4.5678123   11.1) fо) ПИШеТ В файл И ВОЗВращаеТ (4.56781   11.1)
 (prin1 "Мороз и солнце" fo) пишет в файл и возвращает "мороз и солнце"
 (prin1) не возвращает ничего</code></pre>

<p class="h3">Функция print
</p>
<p>Функция аналогична prin1, но при выводе добавляет перед значением аргумента <аргумент> символ конца строки предыдущей записи, а после значения — пробел.
<pre><code> (print [<аргумент> [<дескриптор>]])</code></pre>
<p>Возвращаемое значение — вычисленное значение аргумента <аргумент>. Функция тоже осуществляет тихий выход, если оба аргумента опущены.
</p><p class="h55">Примеры:</p>
<pre style="
    width: 62%;
"><code> В (print '(4.5678123 11.1) fo) пишет в файл \n(4.56781 11.1)_ и возвращает (4.56781 11.1) 
(перевод строки обозначен символами \n, а пробел
 в конце -символом подчеркивания)
 (print "Мороз" fo) пишет в файл \n"Мороз"_ и возвращает "Мороз"  (print) не возвращает ничего</code></pre>

<p class="h3">Функция read-char
</p>
<p>Читает символ из файла. Если аргумент не задан, то выполняет чтение символа из буфера клавиатуры.
<pre><code> (read-char [<дескриптор>])</code></pre>
<p>Возвращает целое число  -   код прочитанного символа (аналогично функции
ascii). При чтении из буфера клавиатуры — для клавиши <Enter> функция возвращает 10.
</p>


<p class="h3">Функция write-char
</p>
<p>Записывает буквенно-цифровой символ с заданным кодом в файл.
<pre><code> (write-char <код> [<дескриптор>])</code></pre>
<p>Если аргумент <дескриптор> не задан, то выводит символ на экран.
Возвращаемое значение — целое число (код выведенного символа). Невозможно
с помощью данной функции записать символ с кодом 0.</p>
<p class="h55">Примеры:
</p>
<pre style="width: 73%;"><code> (write-char 50) возвращает 50 (предварительно на экран выводится цифра 2, т. к. буквенно-цифровой символ "2" 
  имеет код 50, а затем в командную строкувыводится возвращаемое значение;
  поэтому кажется, что возвращено значение 250, а не 50)
 (setq syn (write-char 40 fo)) возвращает 40 (если прочитать значение переменной syn, то оно тоже будет равно 40)</code></pre>

<p class="h3">Функция prompt
</p>
<p>Выводит сообщение на экран (если используется установка системы AutoCAD на двухэкранный вычислительный комплекс, то выводит сообщение на оба экрана). Чтобы избежать этого дублирования, можно пользоваться для вывода сообщений функцией princ.</p>
<pre><code> (prompt <сообщение>)</code></pre>
<p>Аргумент — текстовая строка. Возвращаемое значение — nil. 
</p><p class="h55">Пример:</p>
<pre><code> (prompt "Новая тема") возвращает nil</code></pre>

<p class="h3">Функция alert
</p>
<p>Позволяет вывести на экран диалоговое окно с сообщением системы AutoCAD, (alert 
<сообщение>)</p>
<p>Аргумент — текстовая строка. Возвращаемое значение - nil.
</p>
<p>Максимальная длина строки <сообщение> зависит от многих вещей (в частности, от платформы) и может быть установлена пользователем самостоятельно. В случае превышения допустимой длины AutoCAD обрезает сообщение. При необходимости вывести сообщение в несколько строк нужно использовать знак КОНЦА строки ("\n").</p>
<p class="h55">Пример:
</p>
<pre style="
    width: 57%;
"><code> (setq lines (strcat "Я вас любил: любовь еще, быть может, 
\n" "В душе моей угасла Не совсем, \nНо пусть она вас больше " "не тревожит;\nЯ не хочу
 печалить вас ничем.")) (alert lines)</code></pre>
<p class="h3">Функция terpri
</p>
<p>Переводит курсор экрана на новую строку (очередное сообщение будет выводиться с начала следующей строки).
<pre><code> (terpri)</code></pre>
<p>Возвращаемое значение — nil.
Фактически является аналогом (princ "\n"), но с другим возвращаемым значением.</p>

<p class="h3">Функция vl-directory-flles
</p>
<p>Выводит список с именами файлов и палок, расположенных внутри указанной папки.
<pre><code> (vl-directory-flles [<папка> «образец <флаг> ])</code></pre>
<p>Аргументы:  — текстовая строка (имя палки (каталога), из которой нужно распечатать список с именами файлов и папок); <образец>    текстовая строка
</p> 
<p>(DOS - шаблон для выбора имей файлов); <ФПАГ> - целое число (флаг управления выводом имен палок). Если аргумент <папка> равен "" или nil или опушен, то в качестве рассматриваемой палки принимается текущий каталог. Если аргумент <образец> опущен или задан равным nil, в качестве его значения принимается "*.*"
Аргумент <флаг> может принимать только три значения:</p>
<p class="h5">-1 — выводить только имена палок;<br>
0 — выводить имена и файлов, и папок;<br>
1 — выводить только имена файлов.</p>
<p>По умолчанию в качестве значения аргумента <флаг> принимается 0.
</p>
<p>Возвращаемое значение — список с именами найденных файлов и папок или nil, если по заданному шаблону и флагу ничего не найдено.
</p><p class="h55">Примеры:</p>
<pre style="
    width: 57%;
"><code> (vl-directory-files "d:\\AutoCAD 2006" "acad.** 1) возвращает ("acad.exe"
 (vl-directory-files) возвращает ("." ".." ...) (список оборван) — список файлов 
 и палок текущего каталога (вероятнее всего, папки Мои документы текущего пользователя)</code></pre>

<p class="h3">Функция vl-file-copy
</p>
<p >Копирует содержимое файла-источника в целевой файл. Если целевой файл существует, то либо копирование не выполняется, либо содержимое файла-источника дописывается в конец целевого файла.</p>
<pre><code> (vl-file-copy <источник><цель> [<добавление>])</code></pre>
<p>Аргументы: <источник> — текстовая строка (имя файла-источника, т. е. файла, из которого выполняется копирование); <цель> — текстовая строка (имя целевого файла, т.е. файла, в который выполняется копирование); <добавление> — признак, разрешающий добавление информации в конец целевого файла, если он существовал до операции копирования (если аргумент <добавлеиие> задан и не равен nil, то дописывание разрешено; иначе генерируется сообщение об ошибке).
Если в аргументе <источник> имя файла указано без пути, то файл ищется по путям поиска файлов поддержки. То же относится к поиску или созданию файла, указанного в аргументе <цель>.</p>
<p>Возвращаемое значение — целое число (количество байтов) при успешном выполнении копирования. При ошибке возвращается nil.
</p> 
<p>Причинами ошибки могут быть, например, такие ситуации:
</p>
<p class="h5">не существует файл-источник (или в качестве имени файла-источника задано имя папки);<br>
целевой файл существует, но добавление в него не разрешено; ¦ сбой при чтении файла-источника;<br>
 сбой при записи (например, целевой файл защищен от записи); ¦ совпадают имена файла-источника и целевого файла. </p>
<p class="h55">Примеры:
</p>
<pre style="
    width: 53%;
"><code> (Yi-file-copy "acad.lsp"|; "acadl.lsp") возвращает nil (файл-источник не найден)
 (vl-file-copy "dim.txt" "dimdup.txt") может вернуть 28</code></pre>

<p class="h3">Функция vl-file-delete 
</p>
<p>Удаляет файл с заданным именем.
<pre><code> (vl-file-delete <файл>)</code></pre>
<p>Аргумент — текстовая строка с именем файла.
Возвращаемое значение — т, если удаление выполнено; nil, если удаление не выполнено.</p>
<p class="h55">Пример (продолжение второго примера из предыдущего раздела):
</p>
<pre><code> (vl-file-delete "dimdup.txt") возвращает T</code></pre>

<p class="h3">Функция vl-file-directory-p
</p>
<p>Проверяет, является ли имя, указанное в качестве аргумента, именем папки.
</p>
<pre><code> (vl-file-directory-p <иия>) Аргумент — текстовая строка.</code></pre>
<p>Возвращаемое значение — т, если аргумент указывает имя папки, и nil — в остальных случаях.
Бели аргумент <имя> не содержит полного пути к файлу, то проверяется только текущий каталог (чаще всего — папка Мои документы текущего пользователя).</p>
<p class="h55">Примеры:
</p>
<pre><code> (vl-file-directory-p "Мои рисунки") возвращает  Т
 (vl-file-directory-p  "Help") возвращает nil</code></pre> 
  
<p class="h3">Функция vl-file-rename
</p>
<p>Переименовывает файл или папку.
<pre><code> (vl-f ile-rename <старое> <новое>)</code></pre>
<p>Аргументы — текстовые строки.
Возвращаемое значение — т, если переименование выполнено, и nil, если переименование невозможно.
Если аргумент <старое> не содержит полного пути к файлу, то переименовываемый файл (папка) ищется только в текущем каталоге.</p>
<p class="h55">Пример:
</p>
<pre><code> (vl-f ile-rename "Help.txt" "Help2.txt") возвращает т, если в рабочем каталоге 
найдены файл или папка с именем "Help.txt" и переименование возможно</code></pre>

<p class="h3">Функция vl-file-size
</p>
<p>Вычисляет размер файла в байтах.
<pre><code> (vl-file-size <имя>)</code></pre>
<p>Аргумент — текстовая строка.
Возвращаемое значение — целое число (размер файла в байтах). Если указан несуществующий файл или аргумент является именем папки, то возвращается nil.
Если аргумент <имя> не содержит полного пути к файлу, то анализируемый файл ищется только в текущем каталоге.</p>
<p class="h55">Пример:
</p>
<pre><code> (vl-file-size "dim.txt") возвращает 28</code></pre>

<p class="h3">Функция vl-file-systime
</p>
<p>Вычисляет дату и время последней модификации файла.</p> <p class="h5">(vl-file-systime 
<имя>)</p>
<p>Аргумент — текстовая строка с именем файла.
</p><p>Возвращаемое значение — список из восьми целочисленных элементов:<br>
 год;<br>
 часы;<br>
 месяц;   <br>
минуты;<br>
 день недели;<br>
 секунды;<br>
 день месяца<br>
 миллисекунды</p>
<p>В качестве дня недели возвращается его порядковый номер (0— воскресенье, 1 — понедельник, 2 — вторник и т. д.).
</p><p class="h55">Пример:</p>
<pre><code> (vl-file-systime "dim.txt") может вернуть (2006 1 3 4  21  3  55 421), 
что означает 4 января 2006 года, 3-й день недели (среда), 21 час 3 мин. 55,421 сек.</code></pre>

<p class="h3">Функция vl-filename-base
</p>
<p>Выделяет имя файла, без расширения и пути.
<pre><code> (vl-filename-base <имя>)</code></pre>
<p>Аргумент — текстовая строка с полным или кратким именем файла.
Возвращаемое значение — текстовая строка с именем файла (без расширения и пути).
Функция не проверяет существования файла. </p>
<p class="h55">Пример:
</p>
<pre><code> (vl-filename-base "d:\\Cartoon\\Change\\v502.prn") возвращает "v502"</code></pre>

<p class="h3">Функция vl-filename-directory
</p>
<p>Выделяет путь из полного имени файла,
<pre><code> (vl-filename-directory <имя>)</code></pre>
</p>
<p>Аргумент — текстовая строка с именем файла. Возвращаемое значение — строка (путь к файлу).
Функция не проверяет существования файла. Удобно использовать ее в паре с функцией findfile, возвращающей полное имя файла.</p>
<p class="h5">Примеры:
</p>
<pre style="
    width: 61%;
"><code> (vl-filename-directory "d: \\Cartoon\\Change\\v502 .prn") возвращает "d: \\Cartoon\\Change"
  (vl-filename-directory "make.exe") возвращает</code></pre>

<p class="h3">Функция vl-filename-extension
</p>
<p>Выделяет расширение из имени файла,
<pre><code> (vl-filename-extension <имя>)</code></pre>
</p>
<p>Аргумент — текстовая строка с именем файла.
Возвращаемое значение — текстовая строка с расширением файла, начинается с точки. Если имя файла не содержит расширения, то возвращается nil.</p>
<p class="h55">Примеры:
</p>
<pre><code> (vl-filename-extension "d:\\Cartoon\\Change\\v502.prn") возвращает ".prn"
(vl-filename-extension "acad.lsp") возвращает ".lsp"
(vl-filename-extension "acad") возвращает nil</code></pre>

<p class="h3">Функция vl-filename-mktemp
</p>
<p>Вычисляет уникальное (т. е. не совпадающее с именами существующих файлов) имя для временного файла.
</p>
<pre><code> (vl-filename-mktemp [<образец> [<папка> [<расширение>]]])</code></pre>
<p>Аргументы: <образец> — образец префикса, используемого при построении имени временного файла; <папка> — папка, в которой нужно разместить временный файл; <расширение> — расширение, с которым нужно сформировать имя временного файла. Все аргументы — текстовые строки.
Возвращаемое значение — строка с уникальным именем временного файла.</p>
<p>Если аргумент <образец> не задан, то по умолчанию принимается "$VL~~" Если <образец> задает главную часть имени временного файла длиной более пяти символов, то используются только первые пять.</p>
<p>Если аргумент <папка> не задан или задан равным nil, то в качестве папки, в которой предполагается размещение временного файла, принимается папка, вычисляемая по следующему алгоритму:<br>
папка с именем из аргумента <образец>, если он задан с путем;<br>
папка, имя которой задано в переменной окружения ТМР;<br>
папка, имя которой задано в переменной окружения TEMP;<br>
текущий каталог.</p>
<p>Если аргумент <расширение> не задан, то расширение временного файла извлека¬ется из аргумента <образец> (может оказаться и пустой строкой). Если аргумент <расширение> указан без начальной точки, то его значение добавляется к главной части имени временного файла.
При формировании имени временного файла к главной части имени, извлекаемой из аргумента <образец>, добавляется трехзначный номер, обеспечивающий требуемую уникальность имени.</p>
<p class="h55">Примеры:
</p>
<pre style="
    width: 61%;
"><code> (vl-filename-mktemp) возвращает "С: \\D0CUME~1\\...\\LOCALS~l\\Temp\\$VL~~001"
 (vl-filename-mktemp "abcdefgh") Возвращает "С: \\DOCUME~l\\ ... \\LOCALS-1 \\Temp\\abcde002"
(vi-filename-mktemp "ххх" "c:\\Temp"  "$хх") возвращает wcr^\Temp\\xxx003$xx"
(Vl-filename-raktemp "ххх" "c:\\Temp" ".$хх") возвращает "с:\\Тетр\\ххх004.$хх"</code></pre>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=95%>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Br>
<Tr><Td Valign=ToP><P Class=pr>Замечание:&nbsp;&nbsp;</P></Td>
<Td Valign=Center><P Class=prt> Все файлы с именами, сгенерированными функцией vi-filename-mktemp во время сеанса работы в среде Visual LISP, автоматически удаляются при выходе из Visual LISP.
</P></Td></Tr>

<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<p class="h3">Функция vl-mkdir
</p>
<p>Создает палку с заданным именем.
<pre><code> (vl-mkdir <имя>)</code></pre>
<p>Тип аргумента — строка.
Возвращаемое значение — т при успешном завершении и nil — при ошибке создания.</p>
<p class="h55">Примеры:
</p>
<pre><code> (vl-mkdir "ABC") возвращает T (создана папка ABC внутри текущего каталога)
 (vl-mkdir "d:\\Temp14") возвращает Т
(vi-mkdir "d:\\XYZ\\Temp14") возвращает nil, если папка d:\XYZ не существует</code></pre>
<p class="h3">Функция vl-princ-to-string
</p>
<p>Преобразует в строку любой аргумент, по аналогии с тем, как функция princ выводит данные в файл.
<pre><code> (vl-princ-to-string <аргумент>)</code></pre>
<p>Тип аргумента — любой.
Возвращаемое значение — текстовая строка.</p>
<p class="h55">Примеры:
</p>
<pre style="
    width: 62%;
"><code> (vl-princ-to-string 41) возвращает "41"
 (vl-princ-to-string 'cons) возвращает "cons" ¦  (vl-princ-to-string "Tree") возвращает "Tree"
 (vl-princ-to-string '(12 7 11)) BO3вращает "(12 7 11)"
 (vl-princ-to-string '(0 . "LINE") ) возвращает "(O . LINE)"
 (vl-princ-to-string 5.1234567) возвращает "5.123456" (оставлено шесть значащих цифр)</code></pre>
<p class="h3">Функция vl-prin1 -to-string
</p>
<p>Преобразует в строку любой аргумент, по аналогии с тем, как функция prin1 выводит данные в файл.
<pre><code> (vl-prin1 -to-string <аргумент>)</code></pre>
<p>Тип аргумента — любой.
Возвращаемое значение — текстовая строка
</p><p class="h55">Примеры:</p>
<pre style="
    width: 62%;
"><code> (VL-PRIN1-TO-STGING 41) возвращает M4I"
 (VL-PRIN1-TO-STRING 'cons) возвращает "cons"
 (VL-PRIN1-TO-STRING "TREE") возвращает "\"TREE\""
 (VL-PRIN1-TO-STRING ' (12 7 11)) возвращает " (12 7 11) "
 (VL-PRIN1-TO-STRING '(0 . "LINE")) возвращает " (0 . \"LINE\") "
 (VI-PRIN1-TO-STRING   5.1234567)   возвращает "5.12346" (сохранено только шесть значащих цифр)</code></pre>
<p class="h3">Пример работы с файлами
</p>
<p>Приведенные в предыдущих разделах функции дают пользователю возможность работы только с файлами последовательного доступа. Указателем позиции в файле, с которой далее будет происходить чтение (запись), является переменная хранящая дескриптор этого файла. Механизм работы с файлами отображен в примере, приведенном в листинге.
</p>
<p class="h55">ПРИМЕР ИСПОЛЬЗОВАНИЯ ФУНКЦИЙ РАБОТЫ С ФАЙЛАМИ
</p>
<pre><code> (setq ff (open "d:\\temp.txt" "W"))
 (write-line "Первая строка" ff)
 (write-char 65 ff)
 (write-char 67 ff)
 (write-line "Вторая строка" ff)
 (close ff)
 ; ОПЕРАЦИИ чтения
 (setq ff (open "d:\\temp.txt" "r")) (setq s1 (read-char ff))
 (setq s2 (read-char ff))
 (setq strl (read-line ff))
 (setq str2 (read-line ff))
 (setq str3 (read^line ff))
 (Close ff)
 (setq ff nil)</code></pre>
 <p>
Первое выражение — (setq ff (open "d:\\temp.txt" "W")) — создает переменную ff, в которую заносится дескриптор файла c:\test.txt, открываемого для записи (в первом аргументе функции open обратная косая черта удваивается). Затем выражение (write-line "Первая строка" ff) заносит в открытый файл первую запись (текст "Первая строка" из 13 символов) и символы с кодами 13 и 10, которые в файлах последовательного доступа разделяют записи.</p>
<p>После этого указатель файла показывает на начало второй записи, куда поочередно — с помощью двукратного применения функции write-char— заносятся символы с кодами 65 (буква А) И 67 (буква с). Затем в продолжение второй записи
файла С ПОМОЩЬЮ функции write-line заносится текст "Вторая строка" (13 символов) и добавляются символы с кодами 13 и 10, означающие конец второй записи файла. Вслед за этим файл с дескриптором f f закрывается функцией close.</p>
 <p>Вторая часть листинга начинается функцией открытия того же файла, но уже в режиме чтения. Затем с помощью двукратного применения функций read-chat читаются два первых символа первой записи, которые запоминаются в переменных s1 и s2. После этого в переменную stri читается остаток первой записи. Далее в переменную str2 читается вторая запись файла. Третья операция чтения с помощью функции read-line приносит nil, поскольку в файле d:\temp.txt третьей записи нет. По окончании выполнения рассмотренной программы переменная ff очищается (в ней хранился дескриптор файла). Другие переменные получат такие значения:</p>
<p>s1 = 207 (код символа п)<br>
s2 = 229 (код символа е)<br>
strl = "рвая строка" <br>
str2 = "АСВторая строка" <br>
str3 =  nil</p>
<p>Функции princ, prin1, print и prompt чаще всего применяются для вывода сообщений в командную строку системы AutoCAD, причем prin1 и print выводят сообщения в кавычках (другие особенности описаны выше). Вместо функции write-line для записи в файл можно пользоваться функцией princ, но заносить признак конца записи, который выглядит как "\n", пользователь должен сам. </p>
<p>Например:
<pre><code> (princ "Первая запись\n" ff)</code></pre>
<hr width="90%" color="#7685C6" align="Right">
</Div>


<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Вызов команд AutoCAD из программы на AutoLISP" style="display: none;"></a>

<P>Ввод данных в программу на AutoLISP и вспомогательные вычисления над ними призваны служить автоматизации проектирования. Поэтому в AutoLISP не может не быть средства, позволяющего обращаться к командам AutoCAD из программ пользователя. Таким средством является функция AutoLISP command:</P>

<pre><code>(command аргумент1 аргумент2...)</code></pre>

<P>Эта функция выполняет команду AutoCAD из AutoLISP и всегда возвращает nil. Аргументы представляют собой команды AutoCAD и их опции; каждый аргумент вычисляется и посылается в AutoCAD как ответ на соответствующий запрос. Имена команд и опции представляются как строковые константы, двумерные и трехмерные точки - соответственно как списки из двух или трех действительных чисел. Пустая строка функции command равносильна нажатию пробела на клавиатуре. Вызов command без аргументов равносилен нажатию "CTRL С" с клавиатуры и прерывает большинство команд AutoCAD.</P>
<P>Если переменная AutoCAD CMDECHO установлена в нуль, то при выполнении этой функции на экран не будет выводиться выполнение команды AutoCAD.</P>
<P>На использование этой функции налагаются некоторые ограничения:</P>
<Ul>
 <Li>функции семейства GET не могут быть вложены в функцию command. Следует присваивать все необходимые значения переменным заранее;</Li>
 <Li>нельзя использовать восклицательный знак для указания команде AutoCAD значения переменной.</Li>
</Ul>

<P>Если в строке аргументов команды, вызываемой функцией command, встречается ключевое слово "Pause", то функция COMMAND приостановит свое действие, чтобы пользователь непосредственно ввел значение (или произвел отслеживание). В этот момент можно выполнить "прозрачную" команду, после чего выполнение функции command возобновится. Это позволяет, в частности, в процессе выполнения функции command использовать команды ZOOM, PAN и др. Пауза будет длиться до тех пор, пока не будет введен допустимый аргумент и пока не выполнятся все "прозрачные" команды. При этом, если функция command требует ввода, запрос может быть удовлетворен с помощью меню. Для приостановления действия меню следует указать обратную косую черту.</P>

<hr width="90%" color="#7685C6" align="Right">
</Div>

 <Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Использование функций GET для ввода данных" style="display: none;"></a>

<P>Для ввода данных с клавиатуры в AutoLISP существует семейство функций get. Для всех основных типов данных есть своя функция get. Все аргументы функций этого семейства необязательны. В качестве первого аргумента иногда выступает необязательная двумерная точка в текущей ПСК. Все функции get могут иметь в качестве аргумента произвольную строковую константу, в которой может содержаться текст запроса или какая-то подсказка, выводимая при запросе пользователю ввести какие-то данные. Все функции get ожидают ответа пользователя, т. е. приостанавливают выполнение программы до тех пор, пока не будет осуществлен ввод (нажата клавиша RETURN). Ввод может быть осуществлен как с клавиатуры, так и при помощи устройства указания. Вводя точки с экрана, вы можете захотеть, чтобы в процессе перемещения курсора по экрану Автокад показывал "резиновую" линию. Это позволяют делать практически все функции семейства get. Все вводимые данные автоматически преобразуются в нужный тип данных. В ответ на запрос функций семейства get нельзя вводить выражение AutoLISP: это приведет к ошибке и выводу сообщения "Can't reenter AutoLISP" ("Не могу войти в AutoLISP повторно"). В макроопределениях меню функции get нужно выделять обратной косой чертой с тем, чтобы AutoCAD обеспечил паузы для ввода данных. Вот список этих функций:</P>

<pre><code> (getangle [точка] [текст запроса-подсказки])</code></pre>

<P>Возвращает угол в радианах между задаваемым пользователем вектором и положительным направлением оси Х в текущей плоскости построений. Функция всегда возвращает угол в радианах вне зависимости от текущей установки переменных. Начальная точка вектора может быть определена первым аргументом функции. Вторую точку вектора можно указать на экране мышью, при этом AutoCAD нарисует "резиновую" линию от точки, указанной первым аргументом, до текущего положения курсора. Если первый аргумент опущен, AutoCAD потребует ввода двух точек. Не запрещается указывать трехмерные точки (см. также функцию GETORIENT).</P>

<pre><code> (getcorner точка ["текст запроса-подсказки"])</code></pre>

<P>Эта функция, так же как и getpoint, возвращает координаты указанной пользователем точки в текущей ПСК. Отличие от getpoint заключается в том, что функция getcorner строит "резиновую" рамку при передвижении курсора по экрану, первый угол которой может быть определен первым аргументом функции. В этой функции первый аргумент обязателен. Если вводится трехмерная точка, то координата Z игнорируется (см. функции getpoint и getdist).</P>

<pre><code> (getdist [точка] [текст запроса-подсказки])</code></pre>

<P>Какими бы ни были текущие единицы измерения (например, футы), эта функция всегда возвращает действительное число. Если расстояние указывается с клавиатуры, функция тестирует значения системной переменной flatland и флага трехмерных точек функции initget. Как видим из таблицы, если системная переменная flatland установлена в единицу, а флаг "трехмерные точки" функции initget не установлен, то функция, getdist будет обрабатывать задаваемую трехмерную точку как двумерную, проецируя ее на текущую ПСК:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>flatland</P></Td>
 <Td><P Class=tcb>initget</P></Td>
 <Td><P Class=tcb>Возвращается ли расстояние<Br>
 между трехмерными точками?</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>Да</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tc>Да</P></Td>
</Tr>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>Да</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tc>Нет</P></Td>
</Tr>
</Table></Center>
<Br >

<pre><code> (getenv имя_переменной)</code></pre>

<P>Возвращает строковое значение, присвоенное переменной среды DOS. Здесь имя переменной&nbsp;- строковая константа, представляющая собой имя переменной среды. Если эта переменная не определена, возвращается nil.</P>

<pre><code> (getint [текст запроса-подсказки])</code></pre>

<P>Ввод целого числа.</P>

<pre><code> (getkword [текст запроса-подсказки])</code></pre>

<P>Запрашивает у пользователя ключевое слово, определенное ранее при помощи функции initget. Если ответ не совпадает ни с одним определенным ключевым словом, AutoCAD попросит повторить ввод. Если ответ совпадает с ключевым словом, функция GETKWORD возвращает это ключевое слово как строковую константу. Пустой ввод, если разрешен, возвращает nil.</P>

<P Class=h55>Пример:</P>
<pre><code> (initget 1 "Yes No")
(setq x (getkword "Are you sure? Yes/No"))</code></pre>

<P>запросит пользователя и установит в символ Х либо "Yes", либо "No" в зависимости от ответа. Можно отвечать только одной начальной буквой и неважно, строчной или прописной. В данной ситуации пустой ввод не разрешен, поэтому при неправильном ответе AutoCAD попросит повторить ввод.</P>

<pre><code> (getorient [точка] [текст запроса-подсказки])</code></pre>

<P>То же, что и GETANGLE, однако измерение угла осуществляется относительно текущего направления измерения углов, а не относительно нулевого направления оси Х (абсолютный угол, в отличие от GETANGLE, которая измеряет относительный угол: угол относительно нулевого направления оси X).</P>

<pre><code> (getpoint [точка] [текст запроса-подсказки])</code></pre>

<P>Позволяет ввести точку. Если первый аргумент присутствует, AutoCAD рисует "резиновую" линию от точки, определяемой первым аргументом. Указание трехмерных точек обрабатывается так же, как и в функции GETDIST.</P>

<pre><code> (getreal [текст запроса-подсказки])</code></pre>

<P>Позволяет вводить действительное число. Ввод может быть осуществлен только с клавиатуры (или через планшет).</P>

<pre><code> (getstring [флагпробела] [подсказка])</code></pre>

<P>Запрашивает строковую константу и возвращает ее. Если строка длиннее 132 символов, то возвращаются первые 132 символа. Если в введенной строке имеются символы обратной косой черты, то они заменяются на две обратные косые черты.</P>
<P>Если флаг пробела присутствует и не равен nil, вводимая строка может содержать пробелы и завершением ввода считается нажатие клавиши RETURN.</P>

<pre><code> (getvar имяпеременной)</code></pre>

<P>Возвращает значение системной переменной AutoCAD. Имя переменной должно быть заключено в кавычки (см. функцию SETVAR).</P>
<P>Как видим, функции семейства get имеют много общего. Но кроме сходства их объединяет то, что все режимы ввода устанавливаются одной и той же функцией initget:</P>

<pre><code> (initget [биты] [строка])</code></pre>

<P>Данная функция устанавливает различные режимы, в которых работают все функции семейства get, кроме функций getstring и getvar. Возвращается всегда nil. Биты&nbsp;- необязательное целое число, биты которого интерпретируются следующим образом:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Бит initget</P></Td>
 <Td><P Class=tcb>Значение бита</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tl>Запрещение пустого ввода</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>2</P></Td>
 <Td><P Class=tl>Запрещение ввода нуля</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>4</P></Td>
 <Td><P Class=tl>Запрещение ввода отрицательных чисел</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>5</P></Td>
 <Td><P Class=tl>Не контролируются лимиты, даже если включена системная переменная LIMCHECK</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>16</P></Td>
 <Td><P Class=tl>Возвращаются не двумерные, а трехмерные точки</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>32</P></Td>
 <Td><P Class=tl>"Резиновая" линия и рамка рисуются пунктиром</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>64</P></Td>
 <Td><P Class=tl>Игнорируется координата Z трехмерной точки</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>128</P></Td>
 <Td><P Class=tl>Возвращается произвольный код с клавиатуры</P></Td>
</Tr>
</Table></Center>

<P>Биты задаются целыми значениями, являющимися степенями двойки, как показано в таблице, и общее целое число формируется путем сложения желаемых целых чисел. (Получается логическое И битов.) Следует избегать установки недокументированных битов, поскольку последние версии AutoCAD могут их использовать. Если установленные для ввода правила не выполнены, то AutoCAD попросит повторить ввод. Управляющие биты воспринимаются теми функциями, для которых они имеют смысл.</P>
<P>Второй аргумент функции initget, строка, используется для задания списка ключевых слов при вводе. Использование ключевых слов описано выше.</P>


<hr width="90%" color="#7685C6" align="Right">
</Div>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Работа с графической базой данных чертежа. Доступ к примитивам AutoCAD" style="display: none;"></a>

<P>Чуть ли не самой главной особенностью AutoLISP является то, что он позволяет осуществлять доступ к графической базе данных (ГБД) AutoCAD, многократно умножая возможности адаптации последнего к какому-либо типу задач. Попытаемся вкратце показать, как можно использовать возможности AutoLISP для работы непосредственно с объектами чертежа.</P>

<P>Любой создаваемый в AutoCAD чертеж состоит из отдельных примитивов, геометрическое описание которых хранится в специальном формате (формате AutoCAD) в файле чертежа (расширение .dwg). При загрузке чертежа AutoCAD заполняет графическую базу данных - заносит в нее системные настройки, создает список объектов и вносит в ГБД геометрическое описание этих объектов, присваивая при этом каждому примитиву уникальное имя. Итак, в сеансе редактирования каждый примитив AutoCAD (отрезок, дуга, окружность и т. п.) имеет свое имя, по которому его распознает сам AutoCAD. Поскольку имена меняются от одного сеанса редактирования к другому, не имеет смысла их хранить - даже не пытайтесь запомнить их. Вместо этого следует в программе на AutoLISP сначала найти имя примитива в базе данных AutoCAD с тем, чтобы впоследствии непосредственно манипулировать геометрическими характеристиками примитива или использовать их в макроопределениях меню. Попробуем извлечь это имя из ГБД при помощи AutoLISP. Нарисуйте отрезок и введите с командной строки AutoCAD cтроку</P>

<pre><code> Command:(setq ename (entlast))
 AutoCAD возвращает: Еntity name: 7ef74040</code></pre>

<P>Тем самым мы присвоили переменной ename имя последнего примитива (в данном случае отрезка). Напомним еще раз, что имена примитивов меняются от сеанса к сеансу, и вы наверняка увидите на экране другое имя. Имена примитивов в AutoCAD - шестнадцатеричные величины; имя примитива может быть, например, таким: 60000А14. Используя это имя, вы можете при помощи функции ENTGET получить доступ к данным, связанным с примитивом:</P>

<pre><code> (setq edata (entget ename))</code></pre>

<P>Имя примитива - это новый для нас тип данных AutoLISP, и если функции AutoLISP ENTGET требуется имя примитива, то бесполезно указывать число 60000018 - надо передать переменную ename, в которой это имя хранится.</P>
<P>В результате, выполнения команды вы получите малопонятное сообщение:</P>

<P Class=h5>((-1 . &lt;Entity name: 7ef74040gt;) (0 . "LINE") (330 . &lt;Entity name: 7ef5ecf8gt;) (5 . "F8")
(100 . "AcDbEntity")<Br> (67 . 0) (410 . "Model") (8 . "0") (100 . "AcDbLine") (10 -123.938 -28.7308 0.0) (11 12.2498 -34.8203 0.0)
(210 0.0 0.0 1.0))</P>

<P>Дело в том, что с точки зрения AutoLISP все данные, описывающие примитив, представляют собой список, состоящий, в свою очередь, из подсписков, в которых сгруппированы по функциональному назначению все данные о примитиве, как геометрические, так и общие: слой, цвет и т. п. Подсписки отличаются друг от друга по специальным кодам формата DXF (Drawing eXchange Format - формат обмена чертежами), которые позволяют определить, какой тип данных хранится в подсписке. Каждый подсписок имеет две части. Первая - код DXF, вторая - данные. Целое число 0, например, представляет собой код типа примитива. Код 8 говорит о том, что следующее за ним число - номер слоя. Код 10 - начальная точка примитива, код 11 - конечная, и т. п. Отметим, что набор кодов DXF различен для примитивов разных типов. Однако сами коды относятся ко всем примитивам - имя примитива, например, всегда хранится в подсписке с кодом DXF -1.</P>

<P>Представим полученный список edata в более понятном виде:</P>

<pre style="
    width: 62%;
"><code> ((-1 . &lt;Entity name: 7ef74040&gt;)
;Имя примитива в ГБД чертежа. Меняется всякий раз при открытии чертежа и не хранится в DWG
 (0 . "LINE")                    
;Тип примитива
 (330 . &lt;Entity name: 7ef5ecf8&gt;)  
;Изменяемый указатель; arbitrary soft pointers to other objects within same DXF file or drawing
 (5 . "F8")                       
;Указатель примитива; Текстовая строка до 16 шестнадцатиричных чисел
 (100 . "AcDbEntity")            
Маркер данных подкласса (со строкой производного класса)
 (67 . 0)                        
Пространство модели или пространство чертежа
 (410 . "Model")                
;Строка
 (8 . "0")                       
Имя слоя
 (100 . "AcDbLine")             
;Подкласс маркера данных (со строкой производного класса) 
 (10 -123.938 -28.7308 0.0)      
;Начальная точка
 (11 12.2498 -34.8203 0.0)       
;Конечная точка
 (210 0.0 0.0 1.0))              
;Направление выдавливания (fixed) APP: 3D вектор направления выдавливания</code></pre>

<P>Пользуясь DXF кодами, можно извлечь из списка edata любую информацию о примитиве. Такой доступ к рисунку более сложен, но предоставляет гибкие возможности по изменению практически всех свойств примитивов.</P>

<P>В AutoCAD имеется стандартное средство работы не с одним, а с несколькими примитивами. Это средство
называется набором. Практически все команды редактирования работают не с отдельными примитивами, а с
группой примитивов. Из AutoLISP также можно работать с наборами примитивов - предоставлять пользователю
возможность заносить примитивы в набор и затем их модифицировать. Набор формируется функцией SSGET:</P>

<pre><code>(ssget [режим] [точка1] [точка2])</code></pre>

<P>Необязательный аргумент режим - это строка, которая указывает способ выбора примитива. Им может быть
"W", "С", "L", "P", "WP", "СP" - соответствующие Рамке, Секущей рамке, Последнему и Текущему набору
примитивов AutoCAD, Многоугольнику и Секущему многоугольнику. Аргументы точка1 и точка2 - списки
точек, указывающие точки, относящиеся к выбору.</P>

<P Class=h55>Примеры функции SSGET:</P>
<pre><code> (ssget)
;Создаёт набор из одного объекта чертежа
 (ssget "P")
;Создаёт набор из последних выбранных примитивов
 (ssget "L")
;Создаёт набор из последнего видимого примитива добавленного к базе данных
 (ssget '(2 2))
;Создаёт набор из примитива, проходящего через точку (2, 2)
 (ssget "W" '(0 0) '(5 5))
;Создаёт набор из примитивов в рамке от (0,0) до (5,5)
 (ssget "С" '(0 0) '(4 5))
;Создаёт набор из примитивов, пересекаемых рамкой от (0,0) до (4,5)
 (ssget "X" список-фильтр)
;Создаёт набор из примитивов в соответствии со списком-фильтром</code></pre>
<P>Выбранные объекты подсвечиваются только тогда, когда SSGET используется без аргументов.</P>
<P>Особый режим - режим SSGET "X" - фильтры выбора. В этом режиме функция SSGET просматривает весь рисунок и создает набор, состоящий из имен всех основных примитивов, удовлетворяющих заданным критериям.</P>
<P>Доступные коды для SSGET "X" представлены в следующей таблице:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Код</P></Td>
 <Td><P Class=tcb>Значение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tl>Тип примитива</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>2</P></Td>
 <Td><P Class=tl>Имя блока для описания блока (INSERT)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>6</P></Td>
 <Td><P Class=tl>Имя типа линии</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>7</P></Td>
 <Td><P Class=tl>Имя гарнитуры шрифта для определений текста или атрибутов</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>8</P></Td>
 <Td><P Class=tl>Имя слоя</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>38</P></Td>
 <Td><P Class=tl>Уровень (вещественное число)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>39</P></Td>
 <Td><P Class=tl>Высота (вещественное число)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>62</P></Td>
 <Td><P Class=tl>Код цвета (0="BYBLOCK, 256= "BYLAYER")</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>66</P></Td>
 <Td><P Class=tl>Следующий за атрибутом флаг в описании блока (INSERT)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>210</P></Td>
 <Td><P Class=tl>Вектор направления выдавливания (список из трех вещественных чисел)</P></Td>
</Tr>
</Table></Center>


<P>Для первых пяти кодов разрешается использовать глобальные символы.</P>
<P>Например, используя этот режим, можно создать набор, состоящий из всех отрезков, находящихся на слое "ЭТАЖ" зеленого цвета:</P>

<pre><code> (ssget "х" '((0 . "LINE")(8 . "ЭТАЖ")(62 . 3)))</code></Pre>

<P>В AutoLISP имеются хорошие средства работы с наборами примитивов. Рассмотрим их вкратце.</P>


<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Примитив</P></Td>
 <Td><P Class=tcb>Действие</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(sslength набор)</P></Td>
 <Td><P Class=tl>Возвращает число примитивов в наборе. Если это число больше 32 767, то оно возвращается как действительное</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(ssname набор номер)</P></Td>
 <Td><P Class=tl>Возвращает имя примитива под номером из набора. Запомните, что первый примитив в наборе имеет номер 0! Если примитивов слишком много, используйте действительные числа (округляются до целых)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(ssadd имя_примитива набор)</P></Td>
 <Td><P Class=tl>Если вызвать функцию без аргументов, ssadd создаст новый набор без единого примитива. Если вызвать только с аргументом имя_примитива, будет создан набор, содержащий один примитив. Если вызвать с обоими указанными аргументами, примитив имя_примитива будет добавлен в набор</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(ssdel имя_примитива набор)</P></Td>
 <Td><P Class=tl>Удаляет имя_примитива из набора и возвращает новый набор</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(ssmemb имя_примитива набор)</P></Td>
 <Td><P Class=tl>Если примитив имя_примитива находится в наборе, то возвращается имя примитива, если нет - nil</P></Td>
</Tr>
</Table></Center>


<P>Рассмотрим далее функции, позволяющие извлекать имена примитивов из ГБД по их порядку.</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Функция</P></Td>
 <Td><P Class=tcb>Назначение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(entnext [имя_примитива])</P></Td>
 <Td><P Class=tl>Будучи вызвана без параметров, возвращает имя первого неудаленного примитива в ГБД. Если задан аргумент имя_примитива, будет возвращено имя первого неудаленного примитива, следующего в ГБД за примитивом имя_примитива. Если примитива нет, будет возвращен nil. Возвращаются как основные примитивы, так и субпримитивы (например, вершины полилинии, полученные в результате аппроксимации последней сплайном)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(entlast)</P></Td>
 <Td><P Class=tl>Возвращается имя последнего основного неудаленного примитива в ГБД</P></Td>
</Tr>
</Table></Center>


<P>Из AutoLISP можно непосредственно модифицировать данные о существующих в ГБД примитивах. Однако если мы хотим добавить новый примитив, то должны использовать команды отрисовки или редактирования AutoCAD. Это ограничение связано с желанием защитить ГБД от неграмотного программиста: неправильно пользуясь командами AutoCAD, вы не сможете испортить саму ГБД - самое большее, что вы испортите, это свой чертеж.</P>
<P>Примитивы можно удалять из чертежа командой</P>

<pre><code> (entdel ename)</code></pre>

<P>AutoLISP возвращает имя примитива, например:</P>

<P Class=h5>&lt;Entityname:60000018&gt;<Br>
&lt;Имя примитива: 60000018&gt;</P>

<P>Интересно, что если вы повторите эту операцию, то примитив будет восстановлен. Этот способ позволяет удалять из ГБД невидимые примитивы, что невозможно обычным выбором объектов (нельзя выбрать невидимый объект).</P>
<P>Для того, чтобы модифицировать геометрические характеристики примитива непосредственно в ГБД , надо уметь находить в DXF-списке данных примитива (наша переменная edata) подсписки, в которых хранится нужная информация. Выбор и изменение различных данных, относящихся к примитиву, осуществляется по коду DXF (это всегда целое число) с помощью функций assoc и subst:</P>

<pre><code> (assoc элемент_списка список)</code></pre>

<P>Извлекает из списка элемент списка по ключу элемент_списка. Если элемент_списка не найден, assoc возвращает nil.</P>
<P>При помощи этой функции можно извлечь, например, из списка goods ((1 "car" "volvo")(2 "price" 80000)) подсписок (2 "price" 80000):</P>

<pre><code> (assoc 2 goods) возвращает список (2 "price" 80000)
 (subst новый_элемент старый_элемент список)</code></pre>

<P>Возвращает копию исходного списка с заменой всех найденных подсписков, идентичных старому_элементу, на новый_элемент. Если вхождений не обнаружено, subst возвращает копию старого списка (не nil!):</P>

<pre><code> (subst '(2 "price" 100000) '(2 "price" 80000) goods)</code></Pre>
<P>возвращает:</P>
<pre><code> ((1 "car" "volvo")(2 "price" 100000))</code></pre>

<P>Используя эту технику, попробуем извлечь из списка edata имя примитива:</P>

<pre><code> Command:(assoc 0 edata)
AutoLISP возвращает:(0 . "LINE")</code></pre>

<P>В приведенном только что примере мы фактически сказали AutoLISP: "Возврати мне подсписок с DXF-кодом 0". AutoLISP просмотрел DXF-список примитива, нашел подсписок с кодом 0 и возвратил его. Разумеется, целиком. Полученный по коду подсписок все еще содержит DXF-код, который необходимо убрать: первый элемент списка, уже "отработал" свое и больше не понадобится. Для этой цели лучше всего использовать функцию CDR:</P>

<pre><code> Command:(cdr (assoc 0 edata))
AutoLISP возвращает:"LINE"</code></pre>

<P>Извлекая из DXF-списков нужную информацию, можно программно обрабатывать ее и затем, внеся изменения в DXF-список примитива при помощи функции subst, модифицировать ГБД при помощи функций entmod и entupd.</P>

<pre><code> (entmod список)</code></pre>

<P>С помощью данной функции преобразуется список в формат, возвращаемый функцией ENTGET, и обновляется информация базы данных о примитиве, имя которого указано в группе -1 списка. С помощью функции ENTMOD нельзя изменить тип примитива. Все объекты, на которые ссылается список примитива (гарнитура шрифта, тип линии, имена форм и блоков), должны быть известны AutoCAD к моменту ее вызова. Исключением является имя слоя: если неизвестный AutoCAD слой поименован в списке, ENTMOD создает новый слой со стандартными значениями.</P>

<pre><code> (entupd имя_примитива)</code></pre>
<P>Функция регенерации отдельного примитива, не обязательно основного.</P>
<P>Приведем пример того, как можно из AutoLISP модифицировать вершину полилинии:</P>
<pre><code> (setq e1 (entnext));Переменной е1 присваивается имя полилинии
 (setq e2 (entnext e1));Переменной e2 присваивается имя первой вершины
 (setq ed (entget e2));В списке ed данные о вершине 1
 (setq ed;Модификация переменной ed
  (subst(10 1.0 3.7);Этот список помещается на место старого
  (assoc 10 ed);вхождения списка с первым элементом 10
  )
 )
 (entmod ed);Обновляет данные в ГБД
 (entupd e1);Обновляет полилинию на экране</code></pre>
<P>Заметим, что если вы попытаетесь извлечь данные о вставке блока (INSERT), то получите информацию о самой вставке, а не об определении блока.</P>
<P>Итак, для модификации примитива (группы примитивов) непосредственно в базе данных нужно:</P>
<Ul>
 <Li>предложить пользователю выбрать примитив (функция entsel) или группу примитивов (функция ssget). Используя функцию ssget, можно выбирать примитивы из ГБД программно, без обращения к пользователю - по их свойствам (тип примитива, слой и т. п.);</Li>
 <Li>извлечь из ГБД данные, относящиеся к этому примитиву (если использовался набор, то сначала следует извлечь имя примитива из набора - функция ssname, затем извлечь из ГБД данные, относящиеся к этому примитиву, - функция entget);</Li>
 <Li>средствами работы со списками AutoLISP модифицировать данные о примитиве в переменной - списке данных (функции assoc, subst);</Li>
 <Li>модифицировать саму ГБД: внести изменения в чертеж (функции entmod и entupd).</Li>
</Ul>

<P>Информацию о слоях, типах линий, видах, гарнитурах шрифтов, блоках, ПСК, размерных стилях и видовых экранах AutoCAD хранит в справочных таблицах. Для работы с ними в AutoCAD предусмотрены функции TBLNEXT и TBLSEARCH, которые просматривают таблицу и выдают содержащуюся в ней информацию. Содержимое таблиц изменять не разрешается.</P>

<pre><code> (tbinext имятаблицы [первый])</code></pre>

<P>Первым аргументом функции является строковая константа имени символьной таблицы. Допустимые имена таблиц - "LAYER", "LTYPE", "VIEW", "STYLE", "BLOCK", "UCS", "DIMSTYLE", "VPORT".</P>

<P>При повторном вхождении TBLNEXT возвращает следующее вхождение в указанную таблицу. Если аргумент первый присутствует и не равен nil, чтение таблицы начинается сначала. Если вхождений в таблицу нет, возвращается nil. Если вхождение найдено, возвращается список кодов и значений типа DXF. Точки входа, вызываемые из таблицы "BLOCK", содержат группу - 2 с именем первого элемента в описании блока. Это имя можно использовать только в функциях ENTGET и ENTNEXT, т. е. они программно не модифицируются:</P>

<pre><code> (tblsearch имятаблицы символ [следующий])</code></pre>

<P>Если аргумент следующий присутствует и не равен nil, точка входа TBLNEXT изменяется так, чтобы следующий вызов TBLNEXT возвращал точку входа, следующую за возвращенной.</P>

<P Class=h55>Пример:</P>

<pre><code> (tblnext "BLOCK")
 Возможный возврат:
 ((0 . "BLOCK");тип символа
 (2 . "BORDER");имя символа
 (70 . 0);флаги
 (10 . 9.7 2.0 0.0);X, Y, Z базовой точки
 (-2 . Имя примитива: 40000126);первый примитив
 )</code></pre>
<P>Как уже говорилось, имена примитивов действительны только в текущем сеансе редактирования. Однако в AutoLISP есть средство, позволяющее узнавать примитивы из других сеансов редактирования. Это средство называется меткой. Метки - это просто номер примитива в ГБД. Метки присваиваются примитивам автоматически в процессе создания (если были включены), и с ними можно работать из AutoLISP. Для этого в AutoLISP существует функция handent.</P>

<P Class=h5>(handent метка)</P>

<P>Возвращает имя примитива, который указывается строковым параметром метка. После того как получено имя примитива, оно может быть использовано для дальнейшей работы.</P>



<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>


</Div>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Специальные функции" style="display: none;"></a>


<P>ИзAutoLISP можно управлять некоторыми режимами графического редактора не обращаясь к функциям AutoCAD. К встроенным функциям AutoLISP, управляющим графическим редактором, можно отнести следующие функции:</P>
<pre><code> (graphscr)</code></pre>

<P>Переключает экран из текстового режима в графический в системах с одним экраном (эквивалентна клавише переключения экрана - F1 на IBM PC).</P>

<pre><code> (textscr)</code></pre>

<P>Переключает экран из графического режима в текстовый в системах с одним экраном (эквивалентна клавише переключения экрана - F1 на IBM PC).</P>

<pre><code> (textpage)</code></pre>

<P>Аналогична функции TEXTSCR за исключением того, что она очищает текстовый экран от любого отображаемого на нем текста.</P>

<pre><code> (redraw [имя_примитива [режим]])</code></pre>

<P>Действие данной функции зависит от количества аргументов. Если аргументов нет, то она перерисовывает текущий видовой экран, как это делает команда AutoCAD REDRAW: если она вызывается с аргументом имя_примитива, то перерисован будет только этот выбранный примитив. Эту функцию часто используют для идентификации примитива на экране после использования функции AutoCAD GRCLEAR. Полный контроль за перерисовкой примитива обеспечивается заданием параметра режим, который может принимать одно из следующих значений:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Режим REDRAW</P></Td>
 <Td><P Class=tcb>Действие</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>1</P></Td>
 <Td><P Class=tl>Перерисовывает примитив на экране</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>2</P></Td>
 <Td><P Class=tl>Не рисует примитив (стирает)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>3</P></Td>
 <Td><P Class=tl>Подсвечивает примитив (если позволяет дисплей)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>4</P></Td>
 <Td><P Class=tl>Перестает подсвечивать примитив (если позволяет дисплей)</P></Td>
</Tr>
</Table></Center>

<P>Если имя_примитива - заголовок сложного примитива (полилинии или блока с атрибутами), то в процессе перерисовки будут участвовать как основной примитив, так и все подпримитивы, при условии, что аргумент режим положителен. Если же аргумент режим отрицателен, то в процессе выполнения функции REDRAW будет участвовать только основной примитив. Функция REDRAW всегда возвращает nil.</P>

<pre><code> (grdraw от к цвет [подсветка])</code></pre>

<P>Данная функция рисует вектор между двумя точками на текущем видовом экране. Координаты точек от и к определяют конечные точки отрезка в текущей ПСК. Вектор подрезается до видимой части на экране. Цвет вектора задается целочисленным аргументом цвет. Если это значение равно -1, то цвет дополняет цвет линии, поверх которой он отрисовывается, до цвета фона, что делает данный фрагмент невидимым. Если аргумент подсветка присутствует и не равен нулю, то вектор изображается подсвеченным, как выбранный примитив, если дисплей в состоянии это отобразить. При отсутствии или при нулевом значении этого аргумента используется обычный режим отрисовки.</P>

<pre><code> (grtext [бокс текст [подсветка])</code></pre>

<P>Данная функция обеспечивает доступ к текстовым частям графического экрана AutoCAD. Если аргумент бокс присутствует и равен целому числу в пределах от нуля до наибольшего нумерованного бокса экранного меню минус единица, высвечивается строковый аргумент текст в заданном боксе экранного меню. Если текст не помещается, он усекается. При слишком коротком тексте он дополняется пробелами.</P>
<P>В присутствии подсветки не равной нулю текст подсвечивается. Снять подсветку можно установкой этого значения в нуль. Подсветка другого бокса автоматически снимает подсветку предыдущего. При вставке текста в бокс он сначала должен быть записан без подсветки, а потом его можно подсветить. Для того, чтобы подсветить бокс меню или снять с него подсветку, необходимо указать тот же строковый аргумент текст, который был первоначально записан в этот бокс, но с аргументом подсветка. Заметим, что эта функция только высвечивает указанную строку экранного меню; она не заменяет отмеченных пунктов меню. Более того, на некоторых типах мониторов действие обычной подсветки пункта меню заключается в изменении цвета этого пункта, так что GRTEXT может возвратить текст пункта в предыдущее состояние, если этот пункт меню подсветить. На некоторых мониторах зона меню переписывается при выполнении действий по переключению экрана или при перерисовке экрана командами REDRAW, REGEN. Однако на большинстве мониторов текст функции GRTEXT будет оставаться в зоне экранного меню до тех пор, пока его не перепишет новая страница меню.</P>
<P>Если в функции GRTEXT указать номер бокса равным -1, текст будет записан в статусную строку режимов. Длина статусной строки различна на разных мониторах, в большинстве случаев она составляет 40 символов. При превышении этой длины текст усекается.</P>
<P>Если номер бокса равен -2, текст записывается в строку координат. Если отслеживание координат включено, значения, записанные в этом поле, будут переписываться, как только от устройства указания последуют новые данные о координатах. В двух последних случаях при заданном аргументе подсветка он игнорируется.</P>
<P>Если функцию вызвать без аргументов, текстовые поля экрана придут к стандартному виду.</P>

<pre><code> (grread [отслеживание])</code></pre>

<P>Функция позволяет непосредственно считывать информацию с устройств ввода AutoCAD, отслеживая перемещения устройства указания. Аргумент отслеживание, если он присутствует и не равен nil, дает возможность возвратить координаты от устройств указания в то время, как они движутся, не требуя нажатия кнопки ввода.</P>
<P>GRREAD возвращает список, первый элемент которого - код, указывающий тип устройства или режима ввода.</P>
<P>Коды для первого элемента списка:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Код</P></Td>
 <Td><P Class=tcb>Назначение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>2</P></Td>
 <Td><P Class=tl>Символ клавиатуры - второй элемент - его ASCII-код</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>3</P></Td>
 <Td><P Class=tl>Выбранная точка - координаты в виде списка</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>4</P></Td>
 <Td><P Class=tl>Выбранная ячейка экранного меню - номер бокса</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>5</P></Td>
 <Td><P Class=tl>Задан режим отслеживание, не равный nil. Второй элемент - координаты режима отслеживания</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>6</P></Td>
 <Td><P Class=tl>Выбран пункт меню BUTTONS - номер кнопки</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>7</P></Td>
 <Td><P Class=tl>Выбран пункт меню TABLET1 - номер бокса</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>8</P></Td>
 <Td><P Class=tl>Выбран пункт меню TABLET2 - номер бокса</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>9</P></Td>
 <Td><P Class=tl>Выбран пункт меню TABLET3 - номер бокса</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>10</P></Td>
 <Td><P Class=tl>Выбран пункт меню TABLET4 - номер бокса</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>11</P></Td>
 <Td><P Class=tl>Выбран пункт меню AUX1 - номер бокса</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>12</P></Td>
 <Td><P Class=tl>Координаты, связанные с кнопкой указателя в качестве второго элемента. Всегда следует за типом 6, возвращает список</P></Td>
</Tr>
</Table></Center>


<P>Нажатие клавиши "CTRL С" при выполнении функции GRREAD приведет к прерыванию выполнения LISP-программы. Любой другой ввод будет передаваться непосредственно к функции, предоставляя полный контроль над устройством ввода.</P>
<P>При нажатии кнопки выбора и указания области экранного или падающего меню GRREAD возвращает код 11, но при последующем вызове код 12 не возвращается: код 12 возвращается только после кодов 6 или 11, если кнопка выбора нажата при указании на графическую область экрана.</P>
<P>Важно очищать буфер от данных кода 12 перед выполнением других действий с кнопкой выбора или меню AUX1. Для этого можно выполнить вложенную функцию GRREAD:</P>

<pre><code> (setq code12 (grread (setq code (grread))))</code></pre>

<P>Данная последовательность запоминает значение кода 12 как потоковый ввод с устройства.</P>

<pre><code> (vports)</code></pre>

<P>Возвращает список дескрипторов действующих в настоящий момент видовых экранов. Каждый дескриптор видового экрана - это список, содержащий номер видового экрана и координаты его нижнего левого и правого верхнего углов. Значения координат находятся в интервале от 0.0 до 1.0, где (0.0 0.0) - координаты нижнего левого угла зоны графического экрана, а (1.0 1.0) - координаты ее верхнего правого угла. Дескриптор текущего видового экрана всегда стоит в списке первым.</P>
<P>Таким образом, из программы на AutoLISP можно гибко управлять режимами отображения графического редактора. Но на этом не исчерпывается список ориентированных на систему AutoCAD функций AutoLISP. В AutoLISP есть функции, позволяющие использовать внутренние возможности графического редактора как системы управления графической базой данных. К таким функциям относятся функции объектной привязки и определения различных геометрических параметров объектов, описываемые ниже.</P>

<pre><code> (menucmd строка)</code></pre>

<P>Данная программа представляет механизм листания меню в программах на LISP, что позволяет согласованно работать с загруженными файлами меню, высвечивая соответствующие страницы. MENUCMD всегда возвращает nil. Аргумент строка записывается в следующей форме:</P>

<P Class=h5>раздел=субменю</P>

<P>Раскроем, что имеется в виду под разделом и субменю.</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Раздел</P></Td>
 <Td><P Class=tcb>Имя субменю</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>S</P></Td>
 <Td><P Class=tc>SCREEN</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>В1-В4</P></Td>
 <Td><P Class=tc>BUTTONS от 1 до 4</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>I</P></Td>
 <Td><P Class=tc>ICON</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>PI - Р16</P></Td>
 <Td><P Class=tc>(POP) от 1 до 16</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>Tl - Т4</P></Td>
 <Td><P Class=tc>TABLET от 1 до 4</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>Al - A4</P></Td>
 <Td><P Class=tc>AUX от 1 до 4</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>М</P></Td>
 <Td><P Class=tc>Выражения DIESEL</P></Td>
</Tr>
</Table></Center>

<P>Субменю - Указывает, какое субменю активизировать. Именем должна быть либо одна из меток субменю без ** в текущем загруженном файле меню, либо имя одного из разделов меню. Знак S здесь не используется.</P>
<P>Что касается графических и падающих меню, то для них допустимо имя *, которое означает вызов субменю из текущего раздела.</P>

<hr width="90%" color="#7685C6" align="Right">
</Div>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Геометрические функции" style="display: none;"></a>


<P>В этом разделе собраны функции пересчета одних параметров, определяющих построение графических примитивов из AutoLISP, в другие.</P>

<pre><code> (osnap точка режим)</code></pre>

<P>Возвращает точку, которая является результатом применения объектной привязки, задаваемой в строке "режим" для указанной точки. Режим - строковая константа, состоящая из одного или более идентификатора объектной привязки, как, например, "середина", "центр" и т. д., разделенных запятыми:</P>

<pre><code> (setq pt2 (osnap pt1 "сер"))
 (setq pt2 (osnap pt1 "сер,кон,цен"))</code></pre>

<P>Если аргумент точка - двумерная точка (список из двух действительных чисел), то будет возвращена двумерная точка. Если точка - трехмерная точка (список из трех действительных чисел), то будет возвращена трехмерная точка. Если ни одной точки, соответствующей заданному режиму объектной привязки, не найдено, то будет возвращен nil. Отметим, что действие этой функции зависит также от текущего трехмерного вида и от значения системной переменной FLATLAND.</P>

<pre><code> (polar точка угол расстояние)</code></pre>

<P>Возвращает точку в ПСК, находящуюся под заданным углом и расстоянием от заданной точки; угол измеряется в радианах в направлении против часовой стрелки от оси X. Хотя точки могут быть и трехмерными, угол всегда определяется в текущей плоскости построений. Если значение системной переменной FLATLAND равно нулю, то возвращаются трехмерные точки, в противном случае - двумерные.</P>

<pre><code> (distance точка 1 точка2)</code></pre>

<P>Эта функция возвращает расстояние между двумя трехмерными точками. Если значение системной переменной FLATLAND не равно нулю, то функция DISTANCE предполагает двумерные точки (игнорирует координату Z переданной точки) и возвращает расстояние между точками - проекциями указанных трехмерных точек на текущую плоскость построений.</P>

<pre><code> (angle точка1 точка2)</code></pre>

<P>Возвращает угол в радианах, образованный лучом, направленным из точки1 в точку2 и осью Х текущей плоскости построений. Угол измеряется против часовой стрелки. Трехмерные точки проецируются на текущую плоскость построений.</P>

<pre><code> (inters точка1 точка2 точкаЗ точка4 [неопред])</code></pre>

<P>Возвращает точку пересечения двух отрезков (точка1 точка2) и (точкаЗ точка4). Все точки выражены в координатах текущей ПСК. Если значение системной переменной FLATLAND равно нулю, то точки считаются трехмерными и контролируется пересечение в трехмерном пространстве. В противном случае отрезки проецируются на текущую плоскость построений и пересечение контролируется на плоскости. Если факультативный аргумент неопред присутствует и является nil, то контролируется пересечение не отрезков, а определяемых ими прямых и INTERS будет возвращать точку пересечения даже в том случае, если она не принадлежит ни одному из отрезков. Если же факультативный аргумент неопред отсутствует или не является nil, то точка пересечения должна принадлежать обоим отрезкам (отрезки должны пересекаться), иначе будет возвращен nil.</P>
<pre><code> (trans точка из в [вектор])</code></pre>

<P>Эта функция преобразует координаты точки (или величину перемещения) из одной системы координат в другую. Аргумент точка - список из трех действительных чисел, который можно интерпретировать либо как трехмерную точку, либо как трехмерное перемещение (вектор); из - код системы координат, в которой находится указанная точка, а в - код системы координат, в которой происходит преобразование координат точки. Если имеется факультативный аргумент вектор и его значение не равно нулю, то аргумент точка будет трактоваться как трехмерное перемещение.</P>

<hr width="90%" color="#7685C6" align="Right">
</Div>

<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Системные переменные AutoCAD" style="display: none;"></a>

<P>Среда графического редактора AutoCAD позволяет изменять режимы, переопределять лимиты, менять размеры прицелов объектной привязки и выбора объектов, получать информацию о различных установках графического редактора.</P>
<P>Установленные вами режимы сохраняются до тех пор, пока вы их не переопределите. Сохраняются не только общие настройки (например, размер прицела выбора объектов), но и настройки, относящиеся к способу работы с чертежом (единицы измерения, режим отрисовки маркеров и т. п.).</P>
<P>Все настройки графического редактора управляются так называемыми системными переменными AutoCAD. Когда вы изменяете установки, например включаете или выключаете режим ORTHO, изменяете режим привязки и т. п., AutoCAD сохраняет только что установленный режим в соответствующей системной переменной. Системные переменные, таким образом, формируются в процессе работы с графическим редактором. Фиксировано не только имя, но и тип системной переменной (в вещественную переменную, например, нельзя записать строку).</P>
<P>Системные переменные делятся на модифицируемые пользователем и защищенные. Защищенную переменную нельзя изменять ни программно, ни при помощи команды SETVAR. Она может быть изменена только при выполнении определенной команды. Например, при создании нового примитива за границами зоны чертежа, содержавшей ранее созданные примитивы, и последующем выполнении команды ПОКАЖИ Границы системные переменные EXTMIN и ЕХТМАХ изменятся и примут новые значения. Те же переменные, которые не имеют такой защиты, могут быть вами изменены прямо в процессе выполнения той или иной команды путем использования команды 'SETVAR в прозрачном режиме. Меняя значения системных переменных, вы можете управлять многими (правда, не всеми) режимами графического редактора AutoCAD. Системные переменные также можно разделить по месту их хранения: некоторые из них записываются по окончании сеанса редактирования в файл конфигурации системы, остальные (таких большинство) - в текущий чертеж. Таким образом, файл чертежа AutoCAD - это не просто описание геометрических объектов, а еще и полное описание режимов работы и настроек AutoCAD. Некоторые переменные никуда не записываются, потому что никогда не меняются - например, номер версии AutoCAD (переменная ACADVER).</P>
<P>При помощи команды SETVAR вы можете в любой момент посмотреть текущие установки системных переменных:</P>

<pre><code> Command: SETVAR Variable name or ?:?
 Команда: SETVAR Имя переменной или ?:?</code></pre>

<P>Системные переменные AutoCAD могут быть считаны или установлены из AutoLISP, для этого существуют встроенные функции AutoLISP getvar и setvar. (He надо путать функцию setvar AutoLISP и команду SETVAR AutoCAD - это совершенно разные вещи.) Для того чтобы в программах на AutoLISP не изменять установки системных переменных, используемые AutoCAD по умолчанию, необходимо считывать (при помощи функции getvar) значение изменяемой системной переменной, сохранять старое значение и затем (при помощи функции setvar) восстанавливать его перед выходом из программы. В макроопределениях также следует восстанавливать старые значения системных переменных - это хороший стиль программирования на AutoLISP, он поможет вам застраховаться от ошибок.</P>

<P Class=h3>
<A Href=lisp_system.html>Список системных переменных AutoCAD</A></P>

<hr width="90%" color="#7685C6" align="Right">
</Div>

 
 
 </Ul><Br>

<A Name=22></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=99% BgColor=#9CA6CE>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../оболочка/images/raspor.gif></Td><Td align=left><span Class=h>Примеры программ на AutoLisp</span></Td></Tr>
<Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr></Table>
<Ul>
<Li> <A Href=lisp_prog.html Class="u">Написание программ на AutoLISP</A></Li>
</Ul><Br>
<A Name=2></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=99% BgColor=#9CA6CE>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../оболочка/images/raspor.gif></Td><Td align=left><span Class=h>Язык управления диалогом DCL</span></Td></Tr>
<Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<Ul>


<Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Язык управления диалогом - DCL" style="display: none;"></a>


 <Table valign="left"><Tr align="left"><Td>
<Ul>
<Dt><A Class=m href="#tit1">Предварительно определенные активные поля</A></Dt>
<Dt><A Class=m href="#tit2">Предварительно определенные активные группы полей</A></Dt>
<Dt><A Class=m href="#tit3">Декоративные и информационные поля</A></Dt>
<Dt><A Class=m href="#tit4">Предопределенные атрибуты</A></Dt>
<Dt><A Class=m href="#tit5">Структура DCL-файла</A></Dt>
<Dt><A Class=m href="#tit6">Файлы base.dcl и асаd.dcl</A></Dt>
<Dt><A Class=m href="#tit7">Определенные пользователем DCL-файлы</A></Dt>
<Dt><A Class=m href="#tit8">Синтаксис языка DCL</A></Dt>
<Dt><A Class=m href="#tit9">Определение поля</A></Dt>
<Dt><A Class=m href="#tit10">Ссылки на поля</A></Dt>
<Dt><A Class=m href="#tit11">Атрибуты и значения атрибутов</A></Dt>
<Dt><A Class=m href="#tit12">Комментарии</A></Dt>
<Dt><A Class=m href="#tit13">Обработка ошибок в DCL</A></Dt>
</Ul>
</Td></Tr></Table>

<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>


<P>Диалоговые окна AutoCAD определяются текстовыми файлами, написанными на DCL. Эти файлы имеют расширение .dcl. В них содержится описание способа вывода окна и его состав: клавиши, списки, скользящие шкалы, кнопки выбора и т. п. Правила конструирования диалоговых окон задают ограничения на размер и место расположения окна. Расположение элементов окна очень похоже на расположение абзацев в сформатированном тексте, поэтому нет необходимости задавать точные координаты фрагментов окон.</P>
<P>Диалоговое окно из меню AutoCAD вызывается через функцию AutoLISP или внешнюю функцию СРП (Средства Разработки Приложений), которые управляют диалоговым окном.</P>
<P>В каждом диалоговом окне содержится одно или несколько полей, определяющих функции окна. К основным типам полей относятся базовые поля: клавиши, кнопки, текстовые поля, скользящие шкалы, поля списков, поля изображений. Поля могут обрамляться рамками. Можно комбинировать поля, создавая ряды и колонки. Каждое диалоговое окно рассматривается как древовидная структура, вершина которой представляется на языке DCL как dialog. Управление появлением и поведением поля на этом языке осуществляется атрибутами поля. Можно определить новые поля (прототипы) и группы полей, которые не связаны с обыкновенными диалоговыми окнами. На прототипы можно ссылаться и изменять при необходимости их атрибуты и предварительно определенные поля. Объединения используются только для внешних ссылок. Их атрибуты изменять нельзя.</P>

<Table>
<Tr>
 <Td><p><Img Src=images/lisp/lisp_dcl01.gif></Center></Td>
 <Td Width=24></Td>
 <Td><p><Img Src=images/lisp/lisp_dcl02.gif></Center></Td>
</Tr>
<Table>
<Tr><Td>

<P>На этом рисунке показан пример структуры диалогового окна. Уровни дерева - это встроенные поля, а вершина дерева - примитив диалога. Описание диалогового окна дается на языке DCL, отражающем его древовидную структуру.</P>

<A name="tit1"></A>
<P Class=h3>Предварительно определенные активные поля</P>

<P>Предварительно определенные поля непосредственно поддерживаются средствами программируемых диалоговых окон AutoCAD. Их определения содержатся в файле base.dcl в виде комментариев. При выборе активного поля диалоговое окно извещает об этом приложение (программу на LISP или С), управляющее диалоговым окном. Подобная операция называется действием или вызовом с возвратом. Любое предварительно определенное активное поле имеет соответствующий видимый внешний эффект (например, раскрытие списка или закрытие диалога при указании клавиши OK) или внутренний эффект. В этом случае вырабатывается код причины, смысл которого зависит от типа поля, его инициировавшего.</P>

<Tr><Td>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Клавиша - button:</B> Поле диалогового окна, напоминающее обычную клавишу клавиатуры. Клавиши предназначены для выполнения действий, имеющих внешний эффект для пользователя:
закрытие диалогового окна, появление еще одного окна и т. д. Все диалоговые окна содержат клавишу OK или ее эквивалент, позволяющую выполнить действие окна, а многие окна - клавишу Cancel, позволяющую пользователю покинуть диалоговое окно без внесения каких-либо изменений.
</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>label:</P></Td>
 <Td><P Class=tl>Метка - строка, заключенная в кавычки (значения по умолчанию нет). Определяет надпись, которая появляется на клавише.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>is_default:</P></Td>
 <Td><P Class=tl>Возможные значения: true или false (по умолчанию - false). Если значение true, клавиша является клавишей по умолчанию и указывается, когда пользователь нажимает клавишу RETURN. Если пользователь работает в текстовом поле, поле списка или клавише изображения, имеющих атрибут allow_accept, установленный в true, клавиша по умолчанию также выбирается путем указания клавиши принятия или (для полей списка и клавиш изображения) выполнения двойного указания с помощью кнопки выбора устройства указания. Клавиша по умолчанию не выбирается при нажатии клавиши выполнения, если подсвечена другая клавиша: в этом случае будет выбрана подсвеченная клавиша.<Br>
Клавиша по умолчанию выводится на экран отличным от других клавиш способом, например с помощью дополнительной рамки.<Br>
Только одна клавиша в диалоговом окне может иметь значение атрибута is_default, равное true.</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>is_cancel:</P></Td>
 <Td><P Class=tl>Возможные значения: true или false (по умолчанию - false). Если значение true, клавиша выбирается при нажатии клавиши отмены (например, ESC или Ctrl+C).<Br>
Только одна клавиша в диалоговом окне может иметь значение атрибута is_cancel, равное true. Клавиша, имеющая установленный в true атрибут is_cancel, закрывает диалоговое окно после выполнения действия или вызова с возвратом.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Текстовое поле - edit_box:</B> Поле в котором пользователь может вводить или редактировать текстовую строку. Если вводимый текст превышает размеры текстового поля, его можно "прокрутить" в горизонтальном направлении.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>label:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки (по умолчанию - пустая - " "). Текст выводится слева от поля. Если он определен, атрибут выравнивается влево по ширине текстового поля.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Edit_width:</P></Td>
 <Td><P Class=tl>Возможные значения: целое или вещественное число. Ширина редактируемой части поля, ограниченной рамкой текстового поля в единицах ширины символ. Если атрибут не указан или установлен в нуль и ширина поля не ограничена, рамка расширяется настолько, насколько это возможно. Если значение атрибута не равно нулю, рамка выравнивается вправо внутри занятого полем пространства. Если необходимо вытянуть поле, можно при компоновке вставить пробелы между атрибутом и редактируемой частью поля средствами PDB.</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Edit_limit:</P></Td>
 <Td><P Class=tl>Значение - целое число (по умолчанию - 132); максимум - 256. Максимальное число символов, которое может ввести пользователь в текстовое поле. Когда этот предел достигается, драйвер монитора отбрасывает дополнительные символы (кроме Backspase или Del) и выдает сигнал.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки (по умолчанию - пустая - " "). Исходное значение текстовое, размещенное в рамке. Значение выравнено влево в редактируемой части поля.<Br>Значение текстового поля всегда заканчивается пустым вводом (\0 или EOS). Если пользователь вводит больше символов, чем установлено атрибутом edit_limit, и при этом необходимо усечь строку, добавляется пустой символ.</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Allow_accept:</P></Td>
 <Td><P Class=tl>Возможные значения: true или false (по умолчанию - false). Если значение равно true и пользователь нажал клавишу выполнения (обычно клавиша RETURN), клавиша по умолчанию (если есть) становится "нажатой". (Клавишей по умолчанию считается клавиша, атрибут is_default которой установлен в true.)</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Клавиша изображения - image_button:</B> Поле с нарисованным графическим изображением. Когда пользователь выбирает клавишу изображения, программа получает координаты точки, в которой произошел выбор. Это может быть полезно, если нарисован небольшой рисунок и выбор разных его областей имеет разное значение.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Color:</P></Td>
 <Td><P Class=tl>Цвет фона рисунка, определенный как номер цвета AutoCAD или одно из символьных имен (по умолчанию - 7):<Br>
dialog_line - текуший цвет диалогового окна;<Br>
dialog_forground - текущий цвет символов диалогового окна (для текста);<Br>
dialog_background - текущий цвет фона диалогового окна;<Br>
graphic_background - текущий цвет фона графического экрана AutoCAD (обычно аналог 0);<Br>
black - цвет AutoCAD (черный) на черном фоне изображается как белый;<Br>
red - цвет AutoCAD 1 (красный);<Br>
yellow - цвет AutoCAD 2 (желтый);<Br>
green - цвет AutoCAD 3 (зеленый);<Br>
cyan - цвет AutoCAD 4 (голубой);<Br>
blue - цвет AutoCAD 5 (синий);<Br>
magenta - цвет AutoCAD 6 (фиолетовый);<Br>
white - цвет AutoCAD 7 (белый);<Br>
graphic_forground на белом фоне изображается как черный.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Allow_accept:</P></Td>
 <Td><P Class=tl>Возможные значения: true или false (по умолчанию - false). Если значение равно true и пользователь нажал клавишу выполнения (обычно клавиша RETURN), клавиша по умолчанию (если есть) становится "нажатой". (Клавишей по умолчанию считается клавиша, атрибут is_default которой установлен в true.</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Acpect_ratio:</P></Td>
 <Td><P Class=tl>Отношение ширины изображения к его высоте (ширина, деленная на высоту). Если значение равно нулю (0.0), то поле подгоняется под размеры изображения. Возможно значение с плавающей точкой (значения по умолчанию нет).<Br>
Полю изображения необходимо присвоить точные значения атрибутов width и height или один из этих атрибутов плюс значение acpect_ratio.</P></Td>
</Tr>
</Table></Center><Br>


<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Поле списка - list_box:</B> Поле, содержащее ряды текстовых строк. Наличие такого поля дает возможность пользователю выбрать необходимый пункт из списка. Обычно список имеет переменную длину, но поля списков могут использоваться и для списков фиксированной длины. При выборе строки списка она подсвечивается. Поле списка может содержать строк больше, чем вмещает поле; в этом случае справа от списка поля появляется скользащая шкала (она включена только тогда, когда список имеет больше пунктов, чем можно ввести за один раз). Перемещая визир скользящей шкалы или указывая на стрелки, можно просмотреть весь список. В зависимости от приложения пользователь может выбрать несколько строк списка.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Текст, выводимый над полем списка. Значение - строка, заключенная в кавычки (значения по умолчанию - нет).</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Multiple_select:</P></Td>
 <Td><P Class=tl>Возможные значения true или false (по умолчанию - false). Если true, в поле списка можно выбрать (и подсветить несколько пунктов). Если false, в поле списка может быть выбран только один пункт, а выбор другого пункта отменит выбор предыдущего.</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>List:</P></Td>
 <Td><P Class=tl>Определяет начальный выбор строк, размещенных в поле списка. Строки разделяются символом новой строки (\n). Символ табуляции (\t) может присутствовать в каждой строке. Значение - строка, заключенная в кавычки (значения по умолчанию нет).</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Tabs:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки, содержащая целые числа или числа с плавающей точкой, разделенные пробелами (значения по умолчанию нет). Каждое число - это величина, которая определяет расположение табуляций в единицах ширины символа. Эти значения используются для вертикального выравнивания колонок текста в поле списка (см. диалоговое окно управления слоями AutoCAD, acad_mylayer в файле acad.dcl).</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки, может содержать нуль ("0") или целые числа, разделенные пробелами (значения по умолчанию нет). Каждое целое (начиная с нуля) представляет первоначально выбранный пункт списка. Если значение атрибута multiple_select равно false, атрибут value не может содержать более одного числа.<Br>
Если строка пуста (" "), первоначально не будет выбран ни один пункт. В этом случае этот атрибут можно вообще не определять.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Allow_accept:</P></Td>
 <Td><P Class=tl>Возможные значения: true или false (по умолчанию - false). Если значение равно true и пользователь нажал клавишу выполнения (обычно клавиша Return), клавиша по умолчанию становится "нажатой". (Клавишей по умолчанию считается клавиша, атрибут is_default которой установлен в true.)</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Раскрывающийся список - popup_list:</B> Раскрывающийся список эквивалентен полю списка. Когда диалоговое окно появляется первый раз, раскрывающийся список находится в закрытом состоянии и на экране он выглядит скорее как клавиша с направленной вниз стрелкой справа. При выборе надписи или стрелки список раскрывается и позволяет выбрать необходимый пункт в пределах окна. Раскрытый список, как правило, отображается полностью, в противном случае он будет иметь скользящую шкалу справа, которая функционально аналогична скользящей шкале поля списка. Когда раскрывающийся список закрыт, текущий выбор появляется в его видимой области. Раскрывающиеся списки не допускают выбора нескольких элементов одновременно.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки (значения по умолчанию нет). Это текст, выводимый слева от раскрывающегося списка. Если значение атрибута label определено, оно выравнивается влево в пределах поля popup_list.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Edit_width:</P></Td>
 <Td><P Class=tl>Возможные значения: целое или вещественное число. Ширина части списка в единицах ширины символа, ширина рамки, описывающей единственный пункт, когда раскрывающийся список закрыт. Список не включает необязательную метку слева и стрелку (или скользящую шкалу) справа. Если атрибут не указан или установлен в нуль и ширина поля не задана, рамка расширяется настолько, насколько это возможно. Если значение атрибута не равно нулю, рамка выравнивается вправо внутри занятого полем пространства. Если необходимо вытянуть поле, можно при компоновке вставить пробелы между атрибутом и редактируемой частью поля средствами PDB.</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки, содержащая целое число (по умолчанию 0). Целое число (начиная с нуля) представляет текущий выбранный пункт в списке (пункт, который выводится на экран при закрытом списке).</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>List:</P></Td>
 <Td><P Class=tl>Определяет начальный выбор строк, размещенных в поле списка. Строки разделяются символом новой строки (\n). Символ табуляции (\t) может присутствовать в каждой строке. Значение - строка, заключенная в кавычки (значения по умолчанию нет).</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Tabs:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки, содержащая целые числа или числа с плавающей точкой, разделенные пробелами (значения по умолчанию нет). Каждое число - это величина, которая определяет расположение табуляций, в единицах ширины символа. Эти значения используются для вертикального выравнивания колонок текста в раскрывающемся списке.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Кнопка выбора - radio_button:</B> Одна или группа кнопок, объединенных в колонку или ряд выбора. Кнопки выбора функционально эквивалентны кнопкам радиопанелей: можно выбрать одну кнопку, и, пока она будет в нажатом состоянии, любая другая кнопка в колонке (ряду) будет отключена. Справа от кнопки выбора может появиться необязательная метка (label). Кнопки выбора появляются только в колонках или рядах выбора. Если кнопка выбора размещена вне колонки или ряда выбора, сообщается об ошибке.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Это текст, выводимый слева от клавиши выбора. Значение - строка, заключенная в кавычки (значения по умолчанию нет).</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Заключенная в кавычки строка (значения по умолчанию нет). Если значение атрибута единица, кнопка выбора включена; если нулю - кнопка выбора отключена; все другие значения аналогичны нулю.<Br>
Если по каким-то причинам несколько кнопок имеют атрибут value, равный единице, будет включена только последняя из них. (Эта ситуация может иметь место только в пользовательских DCL-файлах. Как только диалоговое окно появилось на экране, средства PDB управляют кнопками выбора и добиваются, чтобы могла быть включена только одна кнопка в группе одновременно.)</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Скользящая шкала - slider:</B> Подразумевает получение численного значения. Пользователь может перемещать визир скользящей шкалы влево или вправо (или вверх и вниз) для получения величины, назначение которой зависит от приложения. Эта величина возвращается как строка, содержащая целое число определенной точности со знаком. В приложении это значение можно масштабировать.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Min_value и Max_value</P></Td>
 <Td><P Class=tl>Значение - целые числа, определяющие диапазон возвращаемых скользящей шкалой значений. Минимальное значение по умолчанию, min_value - 0. Максимальное значение по умолчанию max_value - 10000. Диапазон должен быть определен знаковым 16-битовым целым, т. е. от -32768 до 32767.<Br>
Значение атрибута min_value может быть больше, чем значение max_value. На некоторых платформах это изменяет как последовательность появления на экране этих значений, так и последовательность их возврата скользящей шкалой во время перемещения визира.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>SmaII_increment и big_increment</P></Td>
 <Td><P Class=tl>Значение - целые числа, определяющие значения, используемые при управлении приращением значения скользящей шкалы. Значение, по умолчанию для атрибута big_increment - одна десятая полного диапазона, значение по умолчанию для small_increment - сотая от полного диапазона. Значения должны быть в диапазоне, определяемом атрибутами min_value и max__value. Эти атрибуты не обязательны.</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Layout:</P></Td>
 <Td><P Class=tl>Скользящая шкала может быть ориентирована горизонтально или вертикально (по умолчанию - горизонтально). Для горизонтальных шкал значение увеличивается слева направо, для вертикальных - снизу вверх.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки и содержащая текущее (целое) значение скользящей шкалы (по умолчанию - min_value).</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Переключатель - toggle</B> Переключатель оперирует двоичными величинами ("О" или "1"). Он изображается небольшим прямоугольником с необязательной меткой (label) справа. Метка Х появляется или исчезает в прямоугольнике при указании переключателя. Переключатель позволяет пользователю видеть и изменять его состояние "включен_выключен".</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Текст, выводимый слева от кнопки переключателя. Значение - строка, заключенная в кавычки.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Определяет первоначальное состояние переключателя. Значение - строка, заключенная в кавычки и содержащая целое число (по умолчанию - нуль). Если значение равно нулю, кнопка переключателя пуста (не помечена). Если значение равно единице, кнопка выводится с меткой X.</P></Td>
</Tr>
</Table></Center><Br>


<A name="tit2"></A>
<P Class=h3>Предварительно определенные активные группы полей</P>

<P>Поля можно группировать в объединенные ряды или колонки. Сгруппированные ряды и колонки при формировании общего диалогового окна рассматриваются как единое поле и могут быть заключены в рамку и иметь необязательную метку (группа без рамки не может иметь метки). Однако при выборе группа не может иметь присвоенное ей действие (кроме ряда или колонки выбора) и представляет собой просто удобный способ раскладки полей в диалоговом окне. Ряд или колонку можно определить для внешнего использования как элемент диалогового окна. Группы, используемые подобным образом, называются объединениями, так как они могут содержать другие поля (детей). Нельзя изменять атрибуты объединения, если оно используется как ссылка в диалоговом окне. В файле base.dcl определено несколько стандартных объединений.</P>


<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Колонка - column:</B> Колонка или любой вид поля (кроме кнопки выбора), включая ряды и другие колонки. Все элементы колонки располагаются вертикально в порядке расположения в DCL-файле.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td COLSPAN=2><P Class=tl>Колонка без рамки не имеет дополнительных атрибутов, кроме стандартных атрибутов компоновки.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Колонка в рамке - boxed_column:</B> Колонка, имеющая нарисованную вокруг нее рамку (границу). Диалоговое окно расположено, как и колонка, в рамке. Если у колонки в рамке имеется метка, она может появиться выше рамки или быть встроенной в нее. Если метка отсутствует или является пробелом (" "), или пусто (""), изображается только рамка.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки (по умолчанию " "). Атрибут label выводится как поле в верхнем левом углу колонки, заключенной в рамку.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Ряд - row:</B> Аналогичен колонке, но его поля расположены горизонтально в порядке расположения в DCL-файле.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td COLSPAN=2><P Class=tl>Ряд без рамки не имеет дополнительных атрибутов, кроме стандартных атрибутов компоновки.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Ряд в рамке - boxed_row</B> Ряд, имеющий нарисованную вокруг него рамку (границу). Если у ряда в рамке имеется метка, она может появиться выше рамки или быть встроенной в нее. Если метка отсутствует или является пробелом (" ") или пусто (""), изображается только рамка.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки (по умолчанию " "). Атрибут label выводится как поле в верхнем левом углу ряда, заключенного в рамку.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Колонка выбора - radio_column</B> Колонка, содержащая поля кнопок выбора. За один раз можно выбрать только одну из кнопок. Это фиксированный набор взаимоисключающих альтернатив. В отличие от обычных колонок колонкам выбора можно присвоить действие.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки, содержащая значение ключа (key) выбранной текущей кнопки выбора.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Колонка выбора в рамке - boxed_radio_column</B> Колонка выбора, имеющая нарисованную вокруг нее рамку (границу). Метка трактуется аналогично метке колонки в рамке.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tl>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки (по умолчанию " "). Атрибут label выводится как поле в верхнем левом углу колонки, заключенной в рамку.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки, содержащая значение ключа (key) выбранной текущей кнопки выбора.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Ряд выбора - radio_row</B> Аналогичен ряду выбора и содержит поля кнопок выбора, но при этом за один раз можно выбрать только одну кнопку. Ряду выбора можно присвоить действие.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки, содержащая значение ключа (key) выбранной текущей кнопки выбора.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Ряд выбора в рамке - boxed_radio_row</B>Ряд выбора, заключенный в рамку (границу). Метка трактуется как и метка колонки в рамке.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки (по умолчанию " "). Атрибут label выводится как поле в верхнем левом углу ряда, заключенного в рамку.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Значение - строка, заключенная в кавычки, содержащая значение ключа (key) выбранной текущей кнопки выбора.</P></Td>
</Tr>
</Table></Center><Br>


<A name="tit3"></A>
<P Class=h3>Декоративные и информационные поля</P>


<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Изображение - image</B> Прямоугольник, внутри которого отображается векторное изображение.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Color:</P></Td>
 <Td><P Class=tl>Цвет фона рисунка, определенный как номер цвета AutoCAD или одно из символьных имен (по умолчанию - 7):<Br>
dialog_line - текущий цвет диалогового окна;<Br>
dialog_forground - текущий цвет символов диалогового окна (для текста);<Br>
dialog_background - текущий цвет фона диалогового окна;<Br>
graphic_background - текущий цвет фона графического экрана AutoCAD (обычно аналог 0);<Br>
black - цвет AutoCAD (черный) на черном фоне изображается как белый;<Br>
red - цвет AutoCAD 1 (красный);<Br>
yellow - цвет AutoCAD 2 (желтый);<Br>
green - цвет AutoCAD 3 (зеленый);<Br>
cyan - цвет AutoCAD 4 (голубой);<Br>
blue - цвет AutoCAD 5 (синий);<Br>
magenta - цвет AutoCAD 6 (фиолетовый);<Br>
white - цвет AutoCAD 7 (белый).<Br>
graphic_forground на белом фоне изображается как черный</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Acpect_ratio:</P></Td>
 <Td><P Class=tl>Отношение ширины изображения к его высоте (ширина, деленная на высоту). Если значение равно нулю (0.0), то поле подгоняется под размеры изображения. Возможно значение с плавающей точкой (значения по умолчанию нет).<Br>
Полю изображения необходимо присвоить точные значения атрибутов width и height или один из этих атрибутов плюс значение acpect_ratio.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Надпись - text</B> Текстовая строка, используемая для вывода заголовка поля и диалогового окна или с информационной целью.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Label:</P></Td>
 <Td><P Class=tl>Отображаемый на экране текст. Значение - строка, заключенная в кавычки (значения по умолчанию нет). При компоновке поля надписи его ширина больше значения атрибута width, определенного в DCL-файле, или ширины, определяемой атрибутом label, если он задан. Если ни один из них не задан, выдается сообщение об ошибке.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>Value:</P></Td>
 <Td><P Class=tl>Как и label, определяет строку, выводимую в поле надписи, но не влияет на компоновку полей. Если сообщение является неизменяемым, следует определить атрибут label и не определять width и value. В противном случае определяется атрибут value и присвоить атрибуту width присваивается достаточно большое значение. После вывода диалогового окна на экран нельзя изменить размер его полей; если при выводе функции set_tile надписи присвоено более длинное значение, чем ширина окна, надпись будет усечена.</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>Is_bold:</P></Td>
 <Td><P Class=tl>Возможные значения: true или false (по умолчанию - false). Если true, надпись выводится полужирным шрифтом.</P></Td>
</Tr>
</Table></Center><Br>



<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td COLSPAN=2><P Class=tcb>Тип поля</P></Td>
</Tr>
<Tr >
 <Td COLSPAN=2 BGCOLOR="#F1F6FF"><P Class="tl"><B>Разделитель - spaser</B> Пустое поле. Используется только в целях компоновки и влияет на размер и расположение смежных полей.</P></Td>
</Tr>
<Tr>
 <Td COLSPAN=2 BGCOLOR="#D1D6E9"><P Class=tcb>Атрибуты</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td COLSPAN=2><P Class=tl>Нет.</P></Td>
</Tr>
</Table></Center><Br>


<P>В этих таблицах показаны поля, используемые в диалоговых окнах вместе с их атрибутами. Атрибуты полей определяют их размещение и функциональность. Атрибут похож на переменную языка программирования. Он состоит из имени и значения. Значения атрибутов могут быть:</P>
<Ul>
 <Li>целыми - это численная величина (целая или вещественная), которая представляет собой размер в единицах ширины или высоты символов;</Li>
 <Li>вещественными - это численная величина, в которой наличие незначащего нуля в целой части обязательно;</Li>
 <Li>строковыми - это строка текста, заключенная в кавычки (" "). Если строка содержит символ кавычки, перед ним следует поставить обратную косую черту: \". Строка может содержать другие ESC-последовательности:
  <Ul>
   <Dt>\" - кавычку;</Dt>
   <Dt>\\ - обратную косую черту;</Dt>
   <Dt>\n - новую строку;</Dt>
   <Dt>\t - горизонтальную табуляцию;</Dt>
  </Ul>
 <Li>зарезервированными словами - это идентификатор, состоящий из текстовых символов и начинающийся с буквы (например, true или false - зарезервированные слова, требуемые во многих атрибутах). Зарезервированное слово чувствительно к регистру: True не равно true. Имена атрибутов также чувствительны к регистру.</Li>
</Ul>

<P>Приложения всегда получают атрибут в виде строки, поэтому, если приложением используются численные величины, они должны быть преобразованы из строкового представления.</P>
<P>Некоторые атрибуты едины для всех полей. Определение атрибутов необязательно; многие атрибуты имеют значения по умолчанию. Они используются при неопределенном атрибуте. Другие атрибуты специально предназначены для определенного типа полей (например, цвет фона изображения). Попытка присвоить такой атрибут другим полям приведет к сообщению об ошибке.</P>
<P>Можно определить собственные атрибуты с именами, не конфликтующими ни с одним из стандартных имен атрибутов. Имя атрибута, как и ключевое слово, может содержать буквы, цифры или символ подчеркивания (_). Первым символом должна быть буква.</P>
<P>Значения определенных пользователем атрибутов должны соответствовать типам атрибутов полей.</P>


<A name="tit4"></A>
<P Class=h3>Предопределенные атрибуты</P>

<P>Здесь описаны определенные PDB атрибуты в алфавитном порядке.</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td Width="20%" BGCOLOR="#D1D6E9"><P Class=tcb>Имя атрибута</P></Td>
 <Td Width="40%" BGCOLOR="#D1D6E9"><P Class=tcb>Поля</P></Td>
 <Td Width="40%" BGCOLOR="#D1D6E9"><P Class=tcb>Назначение<Br>(если определено или true)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>action</P></Td>
 <Td><P Class=tl>Все активные поля</P></Td>
 <Td><P Class=tl>Активное выражение AutoLISP</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>alignment</P></Td>
 <Td><P Class=tl>Все</P></Td>
 <Td><P Class=tl>Горизонтальное или вертикальное положение в группе</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>allow_accept</P></Td>
 <Td><P Class=tl>Текстовое поле, клавиша изображения и поле списка</P></Td>
 <Td><P Class=tl>Активизирует клавишу is_default, когда это поле выбрано</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>acpect_ratio</P></Td>
 <Td><P Class=tl>Изображение, клавиша изображения</P></Td>
 <Td><P Class=tl>Коэффициент коррекции изображения</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>big_increment</P></Td>
 <Td><P Class=tl>Скользящая шкала</P></Td>
 <Td><P Class=tl>Наибольший шаг перемещения</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>children_alignment</P></Td>
 <Td><P Class=tl>Ряд, колонка, ряд выбора, ряд в рамке, колонка в рамке, ряд выбора в рамке и колонка выбора в рамке</P></Td>
 <Td><P Class=tl>Выравнивание элемента, подчиненного группе</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>children_fixed_heigth</P></Td>
 <Td><P Class=tl>Ряд, колонка, ряд выбора, ряд в рамке, колонка в рамке, ряд выбора в рамке и колонка выбора в рамке</P></Td>
 <Td><P Class=tl>Высота элемента, подчиненного группе. Не растет при компоновке</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>children_fixed_width</P></Td>
 <Td><P Class=tl>Ряд, колонка, ряд выбора, ряд в рамке, колонка в рамке, ряд выбора в рамке и колонка выбора в рамке</P></Td>
 <Td><P Class=tl>Ширина элемента, подчиненного группе. Не растет при компоновке</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tlb>color</P></Td>
 <Td><P Class=tl>Изображение, клавиша изображения</P></Td>
 <Td><P Class=tl>Цвет фона изображения</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>edit_limit</P></Td>
 <Td><P Class=tl>Текстовое поле</P></Td>
 <Td><P Class=tl>Максимальное число символов, которое может ввести пользователь</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>edit_width</P></Td>
 <Td><P Class=tl>Текстовое поле, раскрывающийся список</P></Td>
 <Td><P Class=tl>Ширина редактируемой части поля</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>fixed_height</P></Td>
 <Td><P Class=tl>Все</P></Td>
 <Td><P Class=tl>Высота не растет при компоновке</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>fixed_width</P></Td>
 <Td><P Class=tl>Все</P></Td>
 <Td><P Class=tl>Ширина не растет при компоновке</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>height</P></Td>
 <Td><P Class=tl>Все</P></Td>
 <Td><P Class=tl>Высота поля</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>initial_focus</P></Td>
 <Td><P Class=tl>Элемент диалога</P></Td>
 <Td><P Class=tl>Ключ поля с первоначальной подсветкой</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>is_bold</P></Td>
 <Td><P Class=tl>Надпись</P></Td>
 <Td><P Class=tl>Выводится как полужирный текст</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tlb>is_cancel</P></Td>
 <Td><P Class=tj>Клавиша</P></Td>
 <Td><P Class=tj>Кнопка активизируется при нажатии комбинации клавиш Ctrl+C.</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>is_default</P></Td>
 <Td><P Class=tl>Клавиша</P></Td>
 <Td><P Class=tl>Кнопка активизируется при нажатии клавиши RETURN</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>is_enabled</P></Td>
 <Td><P Class=tl>Все активные поля</P></Td>
 <Td><P Class=tl>Поле является изначально доступным</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>is_tab_stop</P></Td>
 <Td><P Class=tl>Все активные поля</P></Td>
 <Td><P Class=tl>Поле может стать активным при нажатии клавиши табуляции</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>key</P></Td>
 <Td><P Class=tl>Все активные поля</P></Td>
 <Td><P Class=tl>Имя (ключ), используемое приложением</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>label</P></Td>
 <Td><P Class=tl>Ряд в рамке, колонка в рамке, ряд выбора в рамке, колонка выбора в рамке, клавиша, примитив диалога, текстовое поле, поле списка, раскрывающийся список, клавиша выбора, надпись и переключатель</P></Td>
 <Td><P Class=tl>Отображаемая метка поля</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>layout</P></Td>
 <Td><P Class=tl>Скользящая шкала</P></Td>
 <Td><P Class=tl>Скользящая шкала вертикальна или горизонтальна</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>list</P></Td>
 <Td><P Class=tl>Поле списка, раскрывающийся список</P></Td>
 <Td><P Class=tl>Начальные значения, отображаемые в списке</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>max_value</P></Td>
 <Td><P Class=tl>Скользящая шкала</P></Td>
 <Td><P Class=tl>Максимальное значение скользящей шкалы</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>min_value</P></Td>
 <Td><P Class=tl>Скользящая шкала</P></Td>
 <Td><P Class=tl>Минимальное значение скользящей шкалы</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>mnemonic</P></Td>
 <Td><P Class=tl>Все активные поля</P></Td>
 <Td><P Class=tl>Мнемонический символ для поля</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>multiple_select</P></Td>
 <Td><P Class=tl>Поле списка</P></Td>
 <Td><P Class=tl>Поле списка позволяет выбрать несколько пунктов</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>small_increment</P></Td>
 <Td><P Class=tl>Скользящая шкала</P></Td>
 <Td><P Class=tl>Малый шаг перемещения</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>labs</P></Td>
 <Td><P Class=tl>Поле списка, раскрывающийся список</P></Td>
 <Td><P Class=tl>Табуляция при отображении списка</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>value</P></Td>
 <Td><P Class=tl>Текст, активные поля, (за исключением клавиш и клавиш изображения)</P></Td>
 <Td><P Class=tl>Начальное значение поля</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>width</P></Td>
 <Td><P Class=tl>Все</P></Td>
 <Td><P Class=tl>Ширина поля</P></Td>
</Tr>
</Table></Center><Br>


<A name="tit5"></A>
<P Class=h3>Структура DCL-файла</P>

<P>Помимо диалоговых окон DCL-файлы могут определять прототипы или объединения, которые могут включать определения из других DCL-файлов. DCL-файл может состоять из следующих трех частей, которые могут располагаться в любом порядке (некоторые части могут отсутствовать):</P>
<Ul>
 <Li>ссылки на другие DCL-файлы. Содержат директивы по включению;</Li>
 <Li>определения прототипов полей, объединения в колонки и ряды. Это определения полей, на которые можно ссылаться;</Li>
 <Li>определения диалоговых окон.</Li>
</Ul>

<A name="tit6"></A>
<P Class=h3>Файлы base.dcl и асаd.dcl</P>

<P>В комплект поставки AutoCAD включены файлы base.dcl и acad.dcl. Они могут быть использованы в качестве примера при создании DCL-файлов.</P>
<P>Файл base.dcl содержит определения базовых, предварительно определенных полей, и типов полей. В нем также содержатся определения прототипов общего использования. Предварительно определенные поля не могут быть переопределены средствами PDB. He следует модифицировать этот файл! Ошибки в файле base.dcl будут прерывать появление как стандартных диалоговых окон AutoCAD, так и диалоговых окон приложений пользователя.</P>
<P>Файл acad.dcl содержит определения всех стандартных диалоговых окон, используемых стандартной версией AutoCAD. Можно отредактировать этот файл, если необходимо изменить появление стандартных диалоговых окон.</P>


<A name="tit7"></A>
<P Class=h3>Определенные пользователем DCL-файлы</P>

<P>Все определенные пользователем DCL-файлы могут автоматически ссылаться на поля, определенные в файле base.dcl. DCL-файл также может использовать поля, определенные в другом DCL-файле дополнительно к base.dcl, используя имя другого файла в директиве включения (include):

<p><Img Src=images/lisp/lisp_dcl03.gif></Center>

<P>Здесь файлы usr1.dcl и usr2.dcl независимы друг от друга, а файл usr3.dcl использует поля, определенные в файле usr1.dcl.</P>
<P>Директива включения имеет форму</P>

<pre><code>@include имя_файла</code></pre>

<P>где имя_файла - строка, заключенная в кавычки и содержащая полное имя другого DCL-файла (с расширением dcl).</P>
<P>Создаваемый DCL-файл не может использовать диалоговые окна, определенные в файле acad.dcl. Нельзя использовать директиву @include "acad.dcl", хотя для создания подобных диалоговых окон можно вырезать часть из файла acad.dcl и вставить ее в создаваемый файл.</P>

<A name="tit8"></A>
<P Class=h3>Синтаксис языка DCL</P>

<P>Язык DCL используется для определения новых полей и объединения существующих полей в диалоговые окна. Новые окна создаются определениями полей. Если определение появляется вне диалогового окна, оно является прототипом (определением поля) или объединением (группой с подчиненными элементами), которое можно использовать в диалоговых окнах для ссылок. Каждая ссылка на определение наследует атрибуты исходного поля. Если ссылка дается на прототип, можно изменять значения наследуемых атрибутов или добавлять новые атрибуты; в случае ссылок на объединения атрибуты не могут быть изменены или добавлены.</P>
<P>Если используется несколько экземпляров полей с несколькими общими атрибутами, проще определить прототип, который содержит общие атрибуты. Тогда в каждой ссылке на прототип можно изменять или добавлять новые атрибуты. Вы избавляетесь от необходимости перечислять список всех общих атрибутов при каждой ссылке на поле.</P>
<P>Так как атрибуты наследуются именно таким образом, то при создании диалогового окна проще создать ссылки на поля (особенно ссылки на предварительно определенные поля), чем создавать новые поля.</P>


<A name="tit9"></A>
<P Class=h3>Определение поля</P>

<P>Форма определения поля</P>

<pre><code> name : item1 [:item2 : item3 ....]{
 attribute = value;
 }</code></pre>

<P>где item - предварительно определенное поле; name - новое поле, которое наследует атрибуты всех определенных полей item; {} - определения атрибутов (добавляют или, если имена атрибутов идентичны, замещают наследуемые определения). Если определение имеет множество родителей, атрибуты имеют приоритет в порядке слева направо. Если более чем одно предварительно определенное поле item определяет один и тот же атрибут, используется первое из них.</P>
<P>Если новое определение не содержит подчиненных элементов, оно является прототипом и ссылки на него могут изменять или дополнять его атрибуты. Если оно является группой (рядом или колонкой) с подчиненными пунктами или вложенными полями, оно является субобъединением.</P>
<P>Имя name поля или прототипа может содержать только буквы, числа или символ подчеркивания (_) и должно начинаться с буквы.</P>

<P Class=h55>Примеры:</P>
<P>Внутреннее определение клавиши</P>

<pre><code> button : tile {
 fixed_heigth = true;
 is_tab_stop = true;
}</code></pre>

<P>Файл base.dcl определяет клавишу по умолчанию default_button:</P>
<pre><code> default_button : button {
 is default = true;
}</code></pre>

<P>Поле default_button наследует значения атрибутов fixed_heigth и is_tab_stop поля button. Файл добавляет новый атрибут is_default и присваивает ему значение true.</P>


<A name="tit10"></A>
<P Class=h3>Ссылки на поля</P>

<P>Форма ссылки на поле</P>

<pre><code> Name;
  или
 : name {
 attribute = value;
 }</code></pre>

<P>В обоих случаях name - имя предварительно определенного поля. В первом случае все атрибуты, определенные в name, объединены в ссылке. Во втором случае определения атрибутов внутри фигурных скобок добавляют или замещают определения, наследуемые из name. Так как это ссылка на поле, а не на определение, изменения атрибутов относятся только к этому образцу поля. Вторая форма может ссылаться только на прототипы, а не на объединения (группы с подчиненными элементами).</P>


<A name="tit11"></A>
<P Class=h3>Атрибуты и значения атрибутов</P>

<P>Внутри фигурных скобок определения поля или ссылки можно определить атрибуты и присвоить им значения, используя форму</P>

<pre><code> attribute = value;</code></pre>

<P>где attribute - ключевое слово; value - значение, присвоенное атрибуту; = - знак присваивания, ;&nbsp;- завершение присваивания.</P>


<A name="tit12"></A>
<P Class=h3>Комментарии</P>

<P>Комментариям в DCL-файлах предшествуют две обратные косые черты - //. Все, что появляется между // и концом строки, игнорируется. DCL также позволяет использовать комментарии, принятые в языке С. Они имеют форму /*, текст комментария - */. Начальные (/*) и конечные (*/) символы могут находиться на разных строках.</P>


<A name="tit13"></A>
<P Class=h3>Обработка ошибок в DCL</P>

<P>Средства PDB проверяют DCL-файл сразу же после его загрузки. Если при этом обнаруживается синтаксическая ошибка, неправильное использование атрибутов или другая ошибка (например, ошибка определения атрибута key для активного поля), DCL-файл не загружается и в файл acad.dce выводится список ошибок. Если DCL-файл прочитан успешно, AutoCAD удаляет файл acad.dce.</P>


</td>
<hr width="90%" color="#7685C6" align="Right">
</Div>
 
 <Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Приемы языка DCL" style="display: none;"></a>


<hr width="90%" color="#7685C6" align="Right"><hr width="90%" color="#7685C6" align="Right">
</Div>
 
 <Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Функции AutoLISP для диалоговых окон" style="display: none;"></a>
<Table valign="left"><Tr align="left"><Td>
<Ul>
<Dt><A Class=m href="#tit1">Открытие и закрытие DCL-файлов</A></Dt>
<Dt><A Class=m href="#tit2">Открытие и закрытие диалоговых окон</A></Dt>
<Dt><A Class=m href="#tit3">Инициализация выражений действия и функций вызова с возвратом</A></Dt>
<Dt><A Class=m href="#tit4">Обработка полей и атрибутов</A></Dt>
<Dt><A Class=m href="#tit5">Задание полей списков и раскрывающихся списков</A></Dt>
<Dt><A Class=m href="#tit6">Создание изображений</A></Dt>
<Dt><A Class=m href="#tit7">Данные, связанные с программным приложением</A></Dt>
</Ul>
</Td></Tr></Table>
<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>


<P>Эти функции обращаются к соответствующему DCL-файлу при отображении диалогового окна на экране.</P>

<A name="tit1"></A>
<P Class=h3>Открытие и закрытие DCL-файлов</P>

<pre><code> (load_dialog имя-файла)</code></pre>

<P>Загружает указанный DCL-файл. Возвращает целое значение (dcl_id), используемое в последующих вызовах функций new_dialog и unload_dialog. В имя файла не следует вставлять расширение.</P>
<pre><code> (unload_dialog dcl_id)</code></pre>

<P>Выгружает указанный DCL_файл. Всегда возвращает nil.</P>

<A name="tit2"></A>
<P Class=h3>Открытие и закрытие диалоговых окон</P>

<pre><code> (new_dialog имя-окна dcl_id [[действие] точка])</code></pre>

<P>Начинает управление диалоговым окном, выводит его на экран и может определить действие по умолчанию. Аргумент имя-окна является строкой и определяет диалоговое окно, а аргумент dcl_id определяет DCL-файл (это значение определяется вызовом функции load_dialog). Приложение должно вызывать функцию new_dialog перед вызовом start_dialog. Все установки, такие, как присвоение полям значений, создание изображений или списков для долей списка и связывание действий с полями (через вызовы функции action_tile), должны происходить после вызова функции new_dialog и перед вызовом start_dialog. Действие по умолчанию выполняется после указания пользователем активного поля, которое не имеет присвоенного функцией action_tile или определенного в DCL-файле действия или функции вызова с возвратом. При успешном завершении функции (new_dialog) возвращает t, в противном случае - nil. Аргумент действие, который должен быть задан, если определен аргумент точка, является строкой, содержащей выражение AutoLISP для использования как действия по умолчанию. Если аргумент действие определять не нужно, следует присвоить ему пустую строку (" "). Если присутствует аргумент точка, то он является списком (X У) точки расположения диалогового окна на экране. Точка обычно определяет положение левого верхнего угла диалогового окна. Поэтому не следует определять положение диалогового окна при его первой инициализации. Координаты положения окна следует задавать после вызова функции (done_dialog) для повторного открытия окна. Это позволяет открывать окна заново, где они были закрыты. Если точка определена как '(-1 -1), диалоговое окно откроется в положении по умолчанию (в центре графического экрана AutoCAD).</P>

<P>Всегда следует проверять возвращаемое функцией new_dialog значение. Вызов функции start_dialog, если функция new_dialog вернула значение ошибки, может привести к непредсказуемым последствиям.</P>

<pre><code> (start_dialog)</code></pre>


<P>Начинает диалог в диалоговом окне. Диалоговое окно должно быть предварительно инициализировано предшествующим вызовом функции new_dialog. Оно остается активным, пока выражение действия или функция вызова с возвратом не вызовут функцию done_dialog; обычно вызов done_dialog связан с полем, имеющим ключ "accept" (обычно клавиша "Да" ("ОК")) или "Cancel" (обычно клавиша "Отмена" ("Cancel")).</P>
<P>Функция (start_dialog) не имеет аргументов. Она возвращает аргумент состояние, переданный в функцию (done_dialog). Значением по умолчанию является 1, если пользователь указал клавишу OK; 0, если пользователь указал клавишу Cancel; -1, если окна были закрыты вызовом функции (term_dialog). Но если функция (done_dialog) установила состояние в значение большее 1, функция (start_dialog) вернет значение, смысл которого определяется приложением.</P>

<pre><code> (done_dialog [состояние])</code></pre>

<P>Завершает диалог в диалоговом окне и убирает его с экрана. Функция должна вызываться из выражения действия или из функции вызова с возвратом. Эта функция также возвращает текущее положение (X Y) диалогового окна. Если функция с возвратом определена для клавиш с ключом "accept" или "done", функция вызова с возвратом должна определенно вызывать функцию done_dialog. Если этого не сделать, пользователь может не выйти из диалогового окна. Если с этими клавишами не связана функция вызова с возвратом и используются стандартные клавиши выхода, AutoCAD обрабатывает их автоматически. Кроме того, точное действие AutiLISP для клавиши "accept" должно определить действие как 1 (или как определенное приложением значение), иначе функция (start_dialog) вернет значение по умолчанию 0, что аналогично отмене диалогового окна.</P>
<P>Аргумент состояние не является обязательным. Если он определен, то должен быть положительным целым, который функция (start_dialog) возвращает как 1 для OK и как 0 для Cancel. Функция (done_dialog) возвращает список координат точки (X Y), определяющей положение диалогового окна, которое покинул пользователь. Этот список можно использовать в последующем вызове функции (new_dialog) для повторного открытия диалогового окна в месте, выбранном пользователем.</P>

<pre><code> (term_dialog)</code></pre>

<P>Завершает диалог во всех активных в настоящий момент диалоговых окнах, как в случае прерывания пользователем. Если при открытых DCL-файлах выполнение приложения прерывается, AutoCAD автоматически вызывает функцию (term_dialog). Данная функция используется в основном для закрытия вложенных диалоговых окон. Функция (tenm_dialog) всегда возвращает nil.</P>



<A name="tit3"></A>
<P Class=h3>Инициализация выражений действия и функций вызова с возвратом</P>

<pre><code> (action_tile ключ выражение_действия)</code></pre>

<P>Присваивает действие, которое будет выполняться после выбора пользователем определенного поля. Аргумент ключ представляет имя поля, которое будет вызывать действие. Действие, присвоенное функцией action_tile, замещает действие по умолчанию диалогового окна или атрибут поля action, если они определены в DCL-файле.</P>
<P>Аргументы ключ и выражение_действия являются строками. Аргумент выражение_действия вычисляется после выбора пользователем поля. Выражение может обращаться к текущему значению поля (атрибут поля value), определенному как $value, к его имени, определенному как $key, к данным, установленным функцией (client_data_tile), определенным как $data, к коду причины вызова, определенному как $reason, к координатам изображения, если это поле изображения, определенным как $x и $y.</P>


<A name="tit4"></A>
<P Class=h3>Обработка полей и атрибутов</P>

<pre><code> (mode_tile ключ режим)</code></pre>

<P>Устанавливает режим для данного поля. Аргумент ключ определяет поле. Аргумент режим является целым числом, его значения даются в таблице:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Значение аргумента</P></Td>
 <Td><P Class=tcb>Результат</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>0</P></Td>
 <Td><P Class=tc>Поле включено (доступно)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>1</P></Td>
 <Td><P Class=tc>Поле отключено (недоступно)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>2</P></Td>
 <Td><P Class=tc>Выбрать поле</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>3</P></Td>
 <Td><P Class=tc>Подсветить содержимое текстового поля</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>4</P></Td>
 <Td><P Class=tc>Включить/отключить подсветку изображения</P></Td>
</Tr>
</Table></Center>

<P><I>Для аргумента <B>режим</B> можно определить только одно целое значение.<Br>Аргумент <B>ключ</B> является строкой.</I></P>

<pre><code> (get_attr ключ атрибут)</code></pre>

<P>Запрашивает значение DCL указанного атрибута. Аргумент ключ определяет поле, аргумент атрибут - имя атрибута в DCL-описании поля. Значение возвращается как первоначально установленное в описании поля; оно не отражает изменений состояния поля, которые могут произойти после ввода пользователя или вызова функции set_tile.</P>
<P>Функция (get_attr) возвращает значение атрибута как строку. Аргументы ключ и атрибут являются строками.</P>

<pre><code> (get_tile ключ) </code></pre>

<P>Запрашивает действующее значение указанного поля.</P>
<P>Аргумент ключ определяет поле. Функция (get_tile) возвращает значение поля как строку. Аргумент ключ является строкой.</P>

<pre><code> (set_tile ключ значение)</code></pre>

<P>Устанавливает действующее значение для указанного поля. Аргумент ключ определяет поле, аргумент значение - присваиваемое значение. Все аргументы являются строками.</P>


<A name="tit5"></A>
<P Class=h3>Задание полей списков и раскрывающихся списков</P>

<pre><code> (start_list ключ {операция] индекс])</code></pre>

<P>Запускает обработку указанного поля списка или раскрывающегося списка, определенного аргументом ключ. Аргумент операция является целым числом со следующими возможными значениями:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Аргумент</P></Td>
 <Td><P Class=tcb>Результат</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>1</P></Td>
 <Td><P Class=tc>Изменить выбранное содержимое списка</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>2</P></Td>
 <Td><P Class=tc>Добавить новый пункт в список</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>3</P></Td>
 <Td><P Class=tc>Удалить старый список и создать новый (по умолчанию)</P></Td>
</Tr>
</Table></Center>

<P>Аргумент индекс игнорируется, если функция start_dialog не вызывается с кодом изменения 1, тогда индекс определяет пункт списка для изменения последующим вызовом функции add_list. Значения индекс начинаются с нуля. Аргументы операция и индекс необязательны. Если не определен аргумент операция, он по умолчанию устанавливается в 3. Если не определена операция и не определен индекс, индекс по умолчанию устанавливается в 0. Аргумент ключ является строкой.</P>
<pre><code> (add_list элемент)</code></pre>

<P>Добавляет заданную строку в текущий список или замещает пункт списка на элемент. Аргумент элемент является строкой. Он завершает обработку текущего списка.</P>

<pre><code> (end_list)</code></pre>


<A name="tit6"></A>
<P Class=h3>Создание изображений</P>

<pre><code> (dimx_tile ключ)
 (dimy_tile ключ)</code></pre>

<P>Функции возвращают размеры поля в единицах диалогового окна, которые используются функциями vector_image, fill_image и slide_image, требующими задания абсолютных координат. Аргумент ключ определяет поле. Координаты возвращаются как максимально разрешенные в поле. Так как координаты отсчитываются от нуля, функции возвращают значения на единицу меньше, чем размеры по Х- или Y-направлению. Функция dimx_tile возвращает ширину поля, функция dimy_tile - его высоту. Для обеих функций аргумент ключ является строкой.</P>

<pre><code> (start_image ключ)</code></pre>

<P>Запускает процесс создания указанного изображения в поле, определенном аргументом ключ. Аргумент ключ является строкой.</P>

<pre><code> (vector_image x1 у1 х2 у2 цвет)</code></pre>

<P>Рисует вектор на текущем активном изображении (открытом функцией start_image) из точки (x1&nbsp;у1) в точку (х2&nbsp;у2). Параметр цвет определяет номер цвета AutoCAD или один из логических цветов:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Номер цвета</P></Td>
 <Td><P Class=tcb>Мнемоника ADI</P></Td>
 <Td><P Class=tcb>Значение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>-2</P></Td>
 <Td><P Class=tc>BGLCOLOR</P></Td>
 <Td><P Class=tc>Цвет фона графического экрана AutoCAD</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>-15</P></Td>
 <Td><P Class=tc>DBGLCOLOR</P></Td>
 <Td><P Class=tc>Цвет фона диалогового окна</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>-16</P></Td>
 <Td><P Class=tc>DFGLCOLOR</P></Td>
 <Td><P Class=tc>Цвет диалогового окна (для текста)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>-18</P></Td>
 <Td><P Class=tc>LINELCOLOR</P></Td>
 <Td><P Class=tc>Цвет линии диалогового окна</P></Td>
</Tr>
</Table></Center>

<P>Начало (0 0) находится в левом верхнем углу изображения. Можно получить координаты правого нижнего угла изображения, вызвав функцию размеров (dimx_tile).</P>

<pre><code> (fill_image x1 y1 х2 у2 цвет)</code></pre>

<P>Рисует закрашенный прямоугольник на активном изображении. Аргументы аналогичны функции vector_image.</P>

<pre><code> (slide_image x1 y1 х2 у2 имя_слайда)</code></pre>

<P>Отображает слайд AutoCAD на текущем активном изображении. Слайд может быть отдельным слайдом (*.sld) или находиться в составе библиотеки слайдов (*.slb). При вызове из библиотеки сначала указывается имя библиотеки, затем в круглых скобках имя слайда. Первый угол слайда, его точка вставки, определяется как (x1 y1), второй угол - (х2 у2). Начало (0 0) находится в левом верхнем углу изображения. Завершает создание текущего изображения</P>

<pre><code> (end_image)</code></pre>


<A name="tit7"></A>
<P Class=h3>Данные, связанные с программным приложением</P>


<pre><code> (client_data_tile ключ клиент-данные)</code></pre>

<P>Связывает управляемые приложением данные с полем, определенным аргументом ключ. Аргумент ключ является строкой. Определенные приложением данные задаются аргументом клиент-данные и также являются строкой. Выражение действия может ссылаться на строку, определенную как $data.</P>


</Div>
 
 <Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Приемы языка DCL" style="display: none;"></a>

<Table valign="left"><Tr align="left"><Td>
<Ul>
<Dt><A Class=m href="#tit1">Управление распределением полей в группе</A></Dt>
<Dt><A Class=m href="#tit2">Нежелательный промежуток справа и внизу диалогового окна</A></Dt>
<Dt><A Class=m href="#tit3">Пространство вокруг ряда или колонки в рамке</A></Dt>
<Dt><A Class=m href="#tit4">Группы текста</A></Dt>
<Dt><A Class=m href="#tit5">Текстовые части (text_part)</A></Dt>
<Dt><A Class=m href="#tit6">Соединение (concatenation)</A></Dt>
<Dt><A Class=m href="#tit7">Абзац (paragraf)</A></Dt>
<Dt><A Class=m href="#tit8">Клавиши выхода из диалогового окна</A></Dt>
<Dt><A Class=m href="#tit9">Изменение надписи клавиши выхода</A></Dt>
<Dt><A Class=m href="#tit10">Поле ошибки - errtile</A></Dt>
</Ul>
</Td></Tr></Table>
<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>


<P>Для правильной компоновки полей в диалоговом окне следует:</P>
<Ul>
 <Li>использовать компоновку по умолчанию и проверить результат: в случае возникновения проблем, похожих на описанные в этом разделе, или специальных случаев, требующих отладки, перейти к следующему шагу;</Li>
 <Li>попытаться отрегулировать компоновку (изменить значения по умолчанию на уровне групп);</Li>
 <Li>отрегулировать отдельные поля.</Li>
</Ul>

<A name="tit1"></A>
<P Class=h3>Управление распределением полей в группе</P>

<P>Пусть определен ряд из трех полей, расположенных вдоль другого поля сверху:</P>

<pre><code> :column {
 : row {
 : compact tile {
 }
 : compact tile {
 }
 : compact tile {
 }
 : large tile {
 }
 }</code></Pre>

<P>Предполагается, что компоненты поля compact_tile имеют атрибут fixed_width и что поле large_tile шире, чем минимальное пространство, необходимое для расположенного выше ряда полей compact_tile. По умолчанию эта группа выглядит следующим образом:</P>

<p><Img Src=images/lisp/lisp_dcl201.gif><Br>
Горизонтальное выравнивание по умолчанию</Center>

<P>Левая граница правого поля compact_tile выравнивается по левой границе поля large_tile, а правая граница последнего поля compact_tile ряда выравнивается по правой границе поля large_tile. Поля, расположенные между ними, распределяются равномерно. Аналогично выравнивается группа колонок.</P>
<P>Для изменения распределения по умолчанию следует использовать поля spacer_0 и spacer_l, которые отличаются от определенного в файле base.dcl поля spacer.</P>

<P><I>Точка вставки наполнения (spacer_0)</I></P>
<P>Поле spacer_0 в нормальном состоянии не имеет ширины. Оно указывает точку вставки разделителя в группе полей, если группу необходимо растянуть при компоновке. Если группе полей spacer_0 присвоена положительная ширина, то они все будут занимать равную долю пространства.</P>

<p><Img Src=images/lisp/lisp_dcl202.gif><Br>
Распределение, измененное вставкой наполнения</Center>


<P><I>Единичное наполнение (spacer_1)</I></P>

<P>Поле spacer_l имеет ширину и высоту, равные единице. Поле используется как наименьший разделитель.</P>

<P Class=h55>Пример:</P>

<p><Img Src=images/lisp/lisp_dcl203.gif><Br>
Распределение, измененное вставкой единичного наполнения</Center>


<P><I>Нежелательный промежуток между полями в прореженных группах</I></P>

<P>Если смежные колонки существенно различаются по размерам, занимаемым полями, поля меньшего размера в группе будут распределены слишком редко.</P>

<P Class=h55>Пример:</P>

<p><Img Src=images/lisp/lisp_dcl204.gif><Br>
Поля, распределенные слишком редко</Center>

<P>В данном случае колонка будет выглядеть лучше, если присвоить атрибуту fixed-length значение true:

<p><Img Src=images/lisp/lisp_dcl205.gif><Br>
Скорректированное прореженное распределение</Center>


<A name="tit2"></A>
<P Class=h3>Нежелательный промежуток справа и внизу диалогового окна</P>

<P>Иногда в диалоговых окнах имеется неиспользованное пространство вдоль правой стороны. Это может быть вызвано полями text, у которых выводимое значение меньше, чем значение атрибута width.</P>

<P Class=h55>Пример:</P>

<P>Фрагмент диалогового окна режимов создания примитивов AutoCAD:
<pre><code> : text {
 key = "I_text";
 width = 18;
 fixed_width = true;
 }</code></pre>

<P>В поле text не отображается ничего (атрибут value не установлен). Приложение может вывести надпись в поле text, используя функцию</P>

<pre><code> (set_tile "I_text" "По слою")</code></pre>

<P>Так как ширина надписи "BYLAYER" меньше 18 символов, вдоль правой стороны диалогового окна появится пустое пространство. Для того, чтобы ограничить поле text, его можно вставить в ряд в рамке. Иногда для этого может потребоваться перестановка полей в диалоговом. окне.</P>
<P>Аналогичная ситуация возникает при использовании поля errtile, отображающем сообщение об ошибке: если сообщение об ошибке не выведено, поле выглядит как дополнительное пространство внизу диалогового окна. В этом случае для вертикального выравнивания рекомендуется вставить дополнительное поле spacer в верхнюю часть диалогового окна.</P>


<A name="tit3"></A>
<P Class=h3>Пространство вокруг ряда или колонки в рамке</P>

<P>Если атрибут label ряда или колонки в рамке является пробелом (" ") или не задан (""), рамка группы создается, но не содержит текста. Единственный пробел не прерывает рамку. Следует иметь в виду:</P>
<Ul>
 <Li>если метка является единственным пробелом, то сжимается пространство по вертикали, которое может занимать метка внутри рамки, но не сжимается пространство по вертикали, которое метка может занимать над рамкой;</Li>
 <Li>если метка - пустая строка, сжимается пространство по вертикали как внутри рамки, так и вне ее.</Li>
</Ul>


<A name="tit4"></A>
<P Class=h3>Группы текста</P>

<P>Поле текста обычно окружено свободным пространством, как и любой другой тип поля. При сочетании частей текста может возникнуть проблема, например, при выводе сообщения</P>

<P Class=h5>Текущее время 0800 ч. 37 с.</P>

<P>где значения 0800 и 37 заполняются пользовательским приложением. Чтобы исключить нежелательные свободные промежутки, используются соединенные надписи, построенные из полей text_part. При создании абзаца можно располагать текстовые части (надписи) вертикально и таким образом избежать слишком больших промежутков между строками.</P>
<P>Описанные, в этом разделе поля text_part, concatenation и paragraph, являются полями-прототипами, определенными в файле base.dcl.</P>

<A name="tit5"></A>
<P Class=h3>Текстовые части (text_part)</P>

<P>Текстовая часть - поле надписи, используемое как часть большого куска текста. Граница поля text_part подавляется так, чтобы сочетаться с другими частями text_part в соединении или в поле абзаца.</P>

<A name="tit6"></A>
<P Class=h3>Соединение (concatenation)</P>

<P>Соединение - строка надписи, созданная из множества соединенных полей text_part. Это может быть полезно при вставке в стандартное сообщение какого-нибудь текста, который может изменяться во время выполнения. Граница вокруг соединения представляется как единое целое.</P>

<A name="tit7"></A>
<P Class=h3>Абзац (paragraph)</P>

<P>Группа полей text_part или concatenation, расположенных вертикально относительно друг друга. Это позволяет строить абзацы текста как до выполнения, так и во время выполнения. Граница вокруг абзаца представляется как единое целое.</P>

<A name="tit8"></A>
<P Class=h3>Клавиши выхода из диалогового окна</P>

<P>Файл base.dcl обеспечивает несколько объединений стандартных клавиш для выхода из диалогового окна или его удаления. Эти стандартные объединения следует использовать для сохранения единообразия вида, диалоговых окон среди различных приложений. Кроме того, в версии файла base.dcl эти клавиши определены для каждой платформы с учетом ее особенностей, так что использование этих определений гарантирует совместимость с каждой платформой.</P>


<P><I>Единственная клавиша Да (ОК) - ok_only</I></P>

<P>Клавиша Да (ОК) аналогична клавише в окне предупреждений. Ключ key клавиши Да имеет значение "accept".</P>


<P><I>Да (Ok) и Отмена (cancel) - ok_cancel</I></P>

<P>Комбинация клавиш Да и Отмена (OK and Cancel) - стандартная комбинация для диалоговых окон, в которых могут вноситься изменения в данные. Ключ key клавиши Отмена (Cancel) имеет значение "cancel".</P>


<P><I>Да (Ok), Отмена (Cancel) и Помощь (Help) - ok_cancel_help</I></P>

<P>Группа ok_cancel скомбинирована со стандартной клавишей Помощь (Help). Ключ key клавиши Помощь имеет значение "help".</P>


<P><I>Да (Ok], Отмена (Cancel), Помощь (Help) и Информация (Info) - ok_cancel_help_info</I></P>

<P>Все описанные выше клавиши плюс информационная клавиша для вывода дополнительной информации, которая может отображать имя приложения, товарный знак, номер версии, информацию о получении технического сопровождения и т. д. Ключ key клавиши Инфо... имеет значение "info".</P>



<A name="tit9"></A>
<P Class=h3>Изменение надписи клавиши выхода</P>

<P>Иногда может возникнуть необходимость изменить надпись клавиш выхода, например для создания диалогового окна, которое может удалить данные, используя клавишу Удаление вместо клавиши Да. Для этого следует использовать прототип retirement_button:
<pre><code> destroy_button : retirement_button {
label  = "Удаление";
key    = "destroy";
;mnemonic = "y";
   }</code></pre>

<P>После определения измененной клавиши выхода следует встроить ее в объединение, которое соответствует по виду и действию стандартным группам, описанным в предыдущем разделе. Например, здесь определено поле ok_cancel_help:</P>

<pre><code> ok_cancel_help : column {
 : row {
 fixed_width = true;
 alignment =centered;
 ok_button;
 : spacer {width =2;}
 cancel_button;
 : spacer {width =2;}
 help button;
}
}</code></pre>
<P>Описание нового объединения с замещенной клавишей ok_button на новую:</P>
<P Class=h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</P>

<P>В стандартном объединении клавиша OK предлагается по умолчанию, но атрибут is_default не добавляется к описанию destroy_button. В подобных ситуациях, если диалоговое окно выполняет действия по удалению, следует сделать клавишу Cancel клавишей по умолчанию. В этом случае она действует и как клавиша по умолчанию, и как клавиша отмены опасной операции:</P>

<pre><code> destroy_cancel_help : column {
 :row {
 fixed_width = true;
 alignment = centered;
 destroy_button;
 : spacer {width =2;}
 : cancel_button {is_default = true;}
 spacer (width =2;}
 help_button;
} 
}</code></pre>
<P>Перед cancel_button ставится двоеточие. Поскольку атрибут изменен, следует использовать исходное описание клавиши Cancel как прототип. Если клавиша отмены и клавиша по умолчанию совпадают (обе имеют атрибуты is_default и is_cancel, установленные в true, как в этом примере) и не присвоено действие с вызовом функции done_dialog любой другой клавише, то ни одна клавиша не сможет закрыть диалоговое окно, и его действие всегда будет отменяться.</P>



<A name="tit10"></A>
<p>Поле ошибки - errtile</P>

<P>Поле надписи, которое, как правило, появляется внизу диалогового окна. По умолчанию оно пусто, но приложение может отобразить в нем сообщение, присвоив значение полю с ключом "error".</P>

<P><I>Да (Ok), Отмена (Cancel), Помощь (Help) и поле ошибки - ok_cancel_help_errtile</I></P>
<P>Объединение, определенное в файле base.dcl, является колонкой, в которой клавиши выхода ok_cancel_help располагаются над стандартным полем errtile. Этим достигается удобное определение одновременно клавиш выхода и поля ошибки.</P>


<hr width="90%" color="#7685C6" align="Right">
</Div>
 
 <Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Функции AutoLISP для диалоговых окон" style="display: none;"></a>
<Table valign="left"><Tr align="left"><Td>
<Ul>
<Dt><A Class=m href="#tit1">Открытие и закрытие DCL-файлов</A></Dt>
<Dt><A Class=m href="#tit2">Открытие и закрытие диалоговых окон</A></Dt>
<Dt><A Class=m href="#tit3">Инициализация выражений действия и функций вызова с возвратом</A></Dt>
<Dt><A Class=m href="#tit4">Обработка полей и атрибутов</A></Dt>
<Dt><A Class=m href="#tit5">Задание полей списков и раскрывающихся списков</A></Dt>
<Dt><A Class=m href="#tit6">Создание изображений</A></Dt>
<Dt><A Class=m href="#tit7">Данные, связанные с программным приложением</A></Dt>
</Ul>
</Td></Tr></Table>
<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>


<P>Эти функции обращаются к соответствующему DCL-файлу при отображении диалогового окна на экране.</P>

<A name="tit1"></A>
<P Class=h3>Открытие и закрытие DCL-файлов</P>

<pre><code> (load_dialog имя-файла)</code></pre>

<P>Загружает указанный DCL-файл. Возвращает целое значение (dcl_id), используемое в последующих вызовах функций new_dialog и unload_dialog. В имя файла не следует вставлять расширение.</P>
<pre><code> (unload_dialog dcl_id)</code></pre>

<P>Выгружает указанный DCL_файл. Всегда возвращает nil.</P>

<A name="tit2"></A>
<P Class=h3>Открытие и закрытие диалоговых окон</P>

<pre><code> (new_dialog имя-окна dcl_id [[действие] точка])</code></pre>

<P>Начинает управление диалоговым окном, выводит его на экран и может определить действие по умолчанию. Аргумент имя-окна является строкой и определяет диалоговое окно, а аргумент dcl_id определяет DCL-файл (это значение определяется вызовом функции load_dialog). Приложение должно вызывать функцию new_dialog перед вызовом start_dialog. Все установки, такие, как присвоение полям значений, создание изображений или списков для долей списка и связывание действий с полями (через вызовы функции action_tile), должны происходить после вызова функции new_dialog и перед вызовом start_dialog. Действие по умолчанию выполняется после указания пользователем активного поля, которое не имеет присвоенного функцией action_tile или определенного в DCL-файле действия или функции вызова с возвратом. При успешном завершении функции (new_dialog) возвращает t, в противном случае - nil. Аргумент действие, который должен быть задан, если определен аргумент точка, является строкой, содержащей выражение AutoLISP для использования как действия по умолчанию. Если аргумент действие определять не нужно, следует присвоить ему пустую строку (" "). Если присутствует аргумент точка, то он является списком (X У) точки расположения диалогового окна на экране. Точка обычно определяет положение левого верхнего угла диалогового окна. Поэтому не следует определять положение диалогового окна при его первой инициализации. Координаты положения окна следует задавать после вызова функции (done_dialog) для повторного открытия окна. Это позволяет открывать окна заново, где они были закрыты. Если точка определена как '(-1 -1), диалоговое окно откроется в положении по умолчанию (в центре графического экрана AutoCAD).</P>

<P>Всегда следует проверять возвращаемое функцией new_dialog значение. Вызов функции start_dialog, если функция new_dialog вернула значение ошибки, может привести к непредсказуемым последствиям.</P>

<pre><code> (start_dialog)</code></pre>

<P>Начинает диалог в диалоговом окне. Диалоговое окно должно быть предварительно инициализировано предшествующим вызовом функции new_dialog. Оно остается активным, пока выражение действия или функция вызова с возвратом не вызовут функцию done_dialog; обычно вызов done_dialog связан с полем, имеющим ключ "accept" (обычно клавиша "Да" ("ОК")) или "Cancel" (обычно клавиша "Отмена" ("Cancel")).</P>
<P>Функция (start_dialog) не имеет аргументов. Она возвращает аргумент состояние, переданный в функцию (done_dialog). Значением по умолчанию является 1, если пользователь указал клавишу OK; 0, если пользователь указал клавишу Cancel; -1, если окна были закрыты вызовом функции (term_dialog). Но если функция (done_dialog) установила состояние в значение большее 1, функция (start_dialog) вернет значение, смысл которого определяется приложением.</P>

<pre><code> (done_dialog [состояние])</code></pre>

<P>Завершает диалог в диалоговом окне и убирает его с экрана. Функция должна вызываться из выражения действия или из функции вызова с возвратом. Эта функция также возвращает текущее положение (X Y) диалогового окна. Если функция с возвратом определена для клавиш с ключом "accept" или "done", функция вызова с возвратом должна определенно вызывать функцию done_dialog. Если этого не сделать, пользователь может не выйти из диалогового окна. Если с этими клавишами не связана функция вызова с возвратом и используются стандартные клавиши выхода, AutoCAD обрабатывает их автоматически. Кроме того, точное действие AutiLISP для клавиши "accept" должно определить действие как 1 (или как определенное приложением значение), иначе функция (start_dialog) вернет значение по умолчанию 0, что аналогично отмене диалогового окна.</P>
<P>Аргумент состояние не является обязательным. Если он определен, то должен быть положительным целым, который функция (start_dialog) возвращает как 1 для OK и как 0 для Cancel. Функция (done_dialog) возвращает список координат точки (X Y), определяющей положение диалогового окна, которое покинул пользователь. Этот список можно использовать в последующем вызове функции (new_dialog) для повторного открытия диалогового окна в месте, выбранном пользователем.</P>

<pre><code> (term_dialog)</code></pre>

<P>Завершает диалог во всех активных в настоящий момент диалоговых окнах, как в случае прерывания пользователем. Если при открытых DCL-файлах выполнение приложения прерывается, AutoCAD автоматически вызывает функцию (term_dialog). Данная функция используется в основном для закрытия вложенных диалоговых окон. Функция (tenm_dialog) всегда возвращает nil.</P>



<A name="tit3"></A>
<P Class=h3>Инициализация выражений действия и функций вызова с возвратом</P>

<pre><code> (action_tile ключ выражение_действия)</code></pre>

<P>Присваивает действие, которое будет выполняться после выбора пользователем определенного поля. Аргумент ключ представляет имя поля, которое будет вызывать действие. Действие, присвоенное функцией action_tile, замещает действие по умолчанию диалогового окна или атрибут поля action, если они определены в DCL-файле.</P>
<P>Аргументы ключ и выражение_действия являются строками. Аргумент выражение_действия вычисляется после выбора пользователем поля. Выражение может обращаться к текущему значению поля (атрибут поля value), определенному как $value, к его имени, определенному как $key, к данным, установленным функцией (client_data_tile), определенным как $data, к коду причины вызова, определенному как $reason, к координатам изображения, если это поле изображения, определенным как $x и $y.</P>


<A name="tit4"></A>
<P Class=h3>Обработка полей и атрибутов</P>

<pre><code> (mode_tile ключ режим)</code></pre>

<P>Устанавливает режим для данного поля. Аргумент ключ определяет поле. Аргумент режим является целым числом, его значения даются в таблице:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Значение аргумента</P></Td>
 <Td><P Class=tcb>Результат</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>0</P></Td>
 <Td><P Class=tc>Поле включено (доступно)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>1</P></Td>
 <Td><P Class=tc>Поле отключено (недоступно)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>2</P></Td>
 <Td><P Class=tc>Выбрать поле</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>3</P></Td>
 <Td><P Class=tc>Подсветить содержимое текстового поля</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>4</P></Td>
 <Td><P Class=tc>Включить/отключить подсветку изображения</P></Td>
</Tr>
</Table></Center>

<P><I>Для аргумента <B>режим</B> можно определить только одно целое значение.<Br>Аргумент <B>ключ</B> является строкой.</I></P>

<pre><code> (get_attr ключ атрибут)</code></pre>

<P>Запрашивает значение DCL указанного атрибута. Аргумент ключ определяет поле, аргумент атрибут - имя атрибута в DCL-описании поля. Значение возвращается как первоначально установленное в описании поля; оно не отражает изменений состояния поля, которые могут произойти после ввода пользователя или вызова функции set_tile.</P>
<P>Функция (get_attr) возвращает значение атрибута как строку. Аргументы ключ и атрибут являются строками.</P>

<pre><code> (get_tile ключ) </code></pre>

<P>Запрашивает действующее значение указанного поля.</P>
<P>Аргумент ключ определяет поле. Функция (get_tile) возвращает значение поля как строку. Аргумент ключ является строкой.</P>

<pre><code> (set_tile ключ значение)</code></pre>

<P>Устанавливает действующее значение для указанного поля. Аргумент ключ определяет поле, аргумент значение - присваиваемое значение. Все аргументы являются строками.</P>


<A name="tit5"></A>
<P Class=h3>Задание полей списков и раскрывающихся списков</P>

<pre><code> (start_list ключ {операция] индекс])</code></pre>

<P>Запускает обработку указанного поля списка или раскрывающегося списка, определенного аргументом ключ. Аргумент операция является целым числом со следующими возможными значениями:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Аргумент</P></Td>
 <Td><P Class=tcb>Результат</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>1</P></Td>
 <Td><P Class=tc>Изменить выбранное содержимое списка</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>2</P></Td>
 <Td><P Class=tc>Добавить новый пункт в список</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>3</P></Td>
 <Td><P Class=tc>Удалить старый список и создать новый (по умолчанию)</P></Td>
</Tr>
</Table></Center>

<P>Аргумент индекс игнорируется, если функция start_dialog не вызывается с кодом изменения 1, тогда индекс определяет пункт списка для изменения последующим вызовом функции add_list. Значения индекс начинаются с нуля. Аргументы операция и индекс необязательны. Если не определен аргумент операция, он по умолчанию устанавливается в 3. Если не определена операция и не определен индекс, индекс по умолчанию устанавливается в 0. Аргумент ключ является строкой.</P>
<pre><code> (add_list элемент)</code></pre>

<P>Добавляет заданную строку в текущий список или замещает пункт списка на элемент. Аргумент элемент является строкой. Он завершает обработку текущего списка.</P>

<pre><code> (end_list)</code></pre>


<A name="tit6"></A>
<P Class=h3>Создание изображений</P>

<pre><code> (dimx_tile ключ)
 (dimy_tile ключ)</code></pre>

<P>Функции возвращают размеры поля в единицах диалогового окна, которые используются функциями vector_image, fill_image и slide_image, требующими задания абсолютных координат. Аргумент ключ определяет поле. Координаты возвращаются как максимально разрешенные в поле. Так как координаты отсчитываются от нуля, функции возвращают значения на единицу меньше, чем размеры по Х- или Y-направлению. Функция dimx_tile возвращает ширину поля, функция dimy_tile - его высоту. Для обеих функций аргумент ключ является строкой.</P>

<pre><code> (start_image ключ)</code></pre>

<P>Запускает процесс создания указанного изображения в поле, определенном аргументом ключ. Аргумент ключ является строкой.</P>

<pre><code> (vector_image x1 у1 х2 у2 цвет)</code></pre>

<P>Рисует вектор на текущем активном изображении (открытом функцией start_image) из точки (x1&nbsp;у1) в точку (х2&nbsp;у2). Параметр цвет определяет номер цвета AutoCAD или один из логических цветов:</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Номер цвета</P></Td>
 <Td><P Class=tcb>Мнемоника ADI</P></Td>
 <Td><P Class=tcb>Значение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>-2</P></Td>
 <Td><P Class=tc>BGLCOLOR</P></Td>
 <Td><P Class=tc>Цвет фона графического экрана AutoCAD</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>-15</P></Td>
 <Td><P Class=tc>DBGLCOLOR</P></Td>
 <Td><P Class=tc>Цвет фона диалогового окна</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>-16</P></Td>
 <Td><P Class=tc>DFGLCOLOR</P></Td>
 <Td><P Class=tc>Цвет диалогового окна (для текста)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>-18</P></Td>
 <Td><P Class=tc>LINELCOLOR</P></Td>
 <Td><P Class=tc>Цвет линии диалогового окна</P></Td>
</Tr>
</Table></Center>

<P>Начало (0 0) находится в левом верхнем углу изображения. Можно получить координаты правого нижнего угла изображения, вызвав функцию размеров (dimx_tile).</P>

<pre><code> (fill_image x1 y1 х2 у2 цвет)</code></pre>

<P>Рисует закрашенный прямоугольник на активном изображении. Аргументы аналогичны функции vector_image.</P>

<pre><code> (slide_image x1 y1 х2 у2 имя_слайда)</code></pre>

<P>Отображает слайд AutoCAD на текущем активном изображении. Слайд может быть отдельным слайдом (*.sld) или находиться в составе библиотеки слайдов (*.slb). При вызове из библиотеки сначала указывается имя библиотеки, затем в круглых скобках имя слайда. Первый угол слайда, его точка вставки, определяется как (x1 y1), второй угол - (х2 у2). Начало (0 0) находится в левом верхнем углу изображения. Завершает создание текущего изображения</P>

<pre><code> (end_image)</code></pre>


<A name="tit7"></A>
<P Class=h3>Данные, связанные с программным приложением</P>


<pre><code> (client_data_tile ключ клиент-данные)</code></pre>

<P>Связывает управляемые приложением данные с полем, определенным аргументом ключ. Аргумент ключ является строкой. Определенные приложением данные задаются аргументом клиент-данные и также являются строкой. Выражение действия может ссылаться на строку, определенную как $data.</P>

<hr width="90%" color="#7685C6" align="Right">
</Div>
 <Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Схема вызовов функций управления" style="display: none;"></a>
 <Table valign="left"><Tr align="left"><Td>

<Ul>
<Dt><A Class=m href="#tit1">Функции, запрещенные во время действия диалогового окна</A></Dt>
<Dt><A Class=m href="#tit2">Выражения действий</A></Dt>
<Dt><A Class=m href="#tit3">Вложенные диалоговые окна</A></Dt>
<Dt><A Class=m href="#tit4">Временное закрытие диалоговых окон</A></Dt>
<Dt><A Class=m href="#tit5">Обработка полей</A></Dt>
<Dt><A Class=m href="#tit6">Создание изображений</A></Dt>
<Dt><A Class=m href="#tit7">Ввод клавиши изображения</A></Dt>
<Dt><A Class=m href="#tit8">Обработка групп выбора</A></Dt>
<Dt><A Class=m href="#tit9">Обработка скользящих шкал</A></Dt>
<Dt><A Class=m href="#tit10">Обработка текстовых полей</A></Dt>
<Dt><A Class=m href="#tit11">Определяемые приложением данные</A></Dt>
</Ul>
</Td></Tr></Table>

<P>Рассмотрим пример вызова и управления простого диалогового окна</P>
<pre><code>hello : dialog {
 label = "Пример диалогового окна";
 : text {
 label = "Всем привет";
}
 ok_only;
}</code></pre>

<P>Данное описание находится в файле hello.dcl. Управляющая появлением этого окна функция AutoLISP может иметь следующий вид:</P>

<pre><code> (defun showalert ( / dcl_id)
 (setq dcl_id (load.gialog "hello.dcl"))
;Загрузить DCL-файл
 (if (not (new_dialog "hello" dcl_id)) 
;Инициализировать диалог
 (exit)) ;(выйти, если не работает)
 (action_tile 
;Связать выражение действия "accept"
;c ключом клавиши Да
 "(done_dialog)") 
;(Закончить диалог, если
; нажата клавиша Да
 (start_dialog)
;Вывести диалоговое окно
 (unload_dialog dcl_id)
;Выгрузить DCL-файл</code></pre>

<P>После вызова функции (start_dialog) диалоговое окно становится активным, пока пользователь не подсветит поле (обычно клавишу), которое связано с вызовом выражения (done_dialog). Вызов функции (action_tile) устанавливает связь между полем (в этом примере с клавишей OK, ключ которой имеет значение "accept") и выражением действия. Именно из-за этого вызов функции (done_dialog) появляется внутри вызова функции (action_tile) и перед вызовом функции (start_dialog). По сути, все действия до функции (start_dialog) являются настроечными. Более сложные окна потребуют большего числа настроек и дополнительных операторов между функциями (start_dialog) и (unload_dialog), но последовательность вызовов будет такой же.</P>
<P>Показанный пример демонстрирует обычную последовательность вызовов функций:</P>

<P><SPAN>1.</SPAN> Загрузка DCL-файла функцией (load_dialog).</P>
<P><SPAN>2.</SPAN> Вызов функции (new_dialog) для вывода отдельного диалогового окна на графический экран AutoCAD. Важно проверять возвращаемое функцией (new_dialog) значение. Вызов функции (start_dialog), если функция (new_dialog) возвратила ошибку, может привести к непредсказуемым результатам.</P>
<P><SPAN>3.</SPAN> Инициализация диалогового окна и установка значений полей, списков и изображений, если это необходимо. На этом этапе обычно вызываются функции (set_tile) и (mode_tile) для установки состояния полей и их значений; (start_list), (add_list), (end_list) для полей списков; (start_image), (vector_image), (fill_image), (slide_image), (end_image) для изображений. На этом этапе обычно вызывается функция (action_tile) для установки выражения действия. Здесь можно вызвать и функцию (action_tile) для связи определенных приложением данных с диалоговым окном и его компонентами.</P>
<P><SPAN>4.</SPAN> Вызов функции (start_dialog) передает управление диалоговому окну, в которое пользователь может вводить данные.</P>
<P><SPAN>5.</SPAN> Процесс ввода данных пользователем (вызовы с возвратом). На этом этапе используются функции (get_tile), (get_attr), (set_tile), (mode_tile).</P>
<P><SPAN>6.</SPAN> Указание пользователем клавиши выхода вызовет функцию (done_dialig), которая, в свою очередь, возвращает функции (start_dialog). Далее следует выгрузка DCL-файла, обеспечиваемая функцией (unload_dialog).</P>
<P>Показанную последовательность действий можно представить следующей схемой:</P>

<p><Img Src=images/lisp/lisp_dcl501.gif></Center>

<P>На схеме показано одновременное управление только одним окном и одним DCL-файлом. Управление несколькими окнами аналогично: следует размножить средний большой прямоугольник нужное число раз:</P>

<p><Img Src=images/lisp/lisp_dcl502.gif></Center>

<P>Схему можно использовать для загрузки нескольких DCL-файлов.</P>


<A name="tit1"></A>
<P Class=h3>Функции, запрещенные во время действия диалогового окна</P>


<P>При активном диалоговом окне (функция (start_dialog) вызвана) нельзя вызывать некоторые функции AutoLISP, которые изменяют экран, который не должен изменяться, пока на нем изображается диалоговое окно, или требуют ввода пользователя, не имеющего отношения к диалоговому окну.</P>
<P>Если необходимо ввести данные в режиме графического экрана (например, выбрать точку или примитив), необходимо временно закрыть диалоговое окно, вызвав функцию (done_dialog), - графический экран станет доступен. После выполнения выбора производится повторный вызов окна.</P>
<P>Перечень функций AutoCAD, запрещенных к вызову при открытом диалоговом окне:</P>
<P><SPAN>1.</SPAN> Запросы и команды AutoCAD: (command), (osnap).</P>
<P><SPAN>2.</SPAN> Функции ввода пользователем: (getint), (getreal), (getstring), (getpoint), (getcorner), (getdist), (getangle), (getorient), (getkword).</P>
<P><SPAN>3.</SPAN> Функции управления экраном: (prompt)

<SPAN><B>(</B></SPAN>Функции вывода текста (print) и (princ) полезно использовать при отладке диалоговых окон, но не в окончательной версии. Если диалоговое окно перекрывает зону подсказок, эти функции выводят текст поверх диалогового окна.<SPAN><B>)</B></SPAN>,

(menucmd), (redraw), (graphscr), (textscr), (textpage).</P>
<P><SPAN>4.</SPAN> Графические функции низкого уровня: (grclear), (grdraw), (grread), (grtext), (grvacs).</P>
<P><SPAN>5.</SPAN> Функция набора выбора (ssget).

<SPAN><B>(</B></SPAN>Запрещены только интерактивные функции (ssget).<SPAN><B>)</B></SPAN>

<P><SPAN>6.</SPAN> Функции управления примитивами: (entmod), (entmake), (entdel), (entsel), (nentsel), (entupd).</P>


<A name="tit2"></A>
<P Class=h3>Выражения действий</P>

<P>Для определения последствий выбора определенного поля диалогового окна следует связать выражение AutoLISP с этим полем посредством вызова функции (action_tile). Внутри действия часто бывает необходимо получить доступ к атрибутам DCL-файла. Это обеспечивают функции (get_attr) и (get_tile): функция (get_attr) выдает значения, сохраненные в DCL-файле, a (get_tile) выдает текущие значения. Значения, связанные с выбранным полем, получаются автоматически.</P>
<P>Выражение действия AutoLISP получает доступ к переменным, которые описаны ниже в таблице и описывают выбранное поле и его состояние во время действия. Имена переменных зарезервированы, и их значения можно только считать (они имеют смысл только тогда, когда доступны выражению действия).</P>

<p>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Переменная</P></Td>
 <Td><P Class=tcb>Назначение</P></Td>
 <Td><P Class=tcb>Примечание</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>$key</P></Td>
 <Td><P Class=tl>Атрибут key выбранного поля</P></Td>
 <Td><P Class=tl>Применима ко всем действиям</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>$value</P></Td>
 <Td><P Class=tl>Строка текущего значения поля, похожая на строку окна редактирования, или "О", или "1" для переключателя</P></Td>
 <Td><P Class=tl>Применима ко всем действиям. Если поле является полем списка (или раскрывающегося списка) и не содержит ни одного пункта, переменная $value будет иметь значение nil</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>$data</P></Td>
 <Td><P Class=tl>Данные, установленные сразу после вызова (new_dialog) через вызов (client_data_tile) и управляемые приложением</P></Td>
 <Td><P Class=tl>Применима ко всем действиям. Не имеет значения до тех пор, пока приложение не установит его вызовом функции (client_data_tile)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tcb>$reason</P></Td>
 <Td><P Class=tl>Код причины, сообщающий, какой выбор пользователя вызвал действие. Используется в полях edit_box, list_box, image_button и slider</P></Td>
 <Td><P Class=tl>Определяет причину действия. Ее значение определено для любого вида действия, но его следует проверять, если действие связано с полями edit_box, list_box, image_button и slider</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>$x</P></Td>
 <Td><P Class=tl>Координата X выбора image_button.</P></Td>
 <Td ROWSPAN=2 Bgcolor=#EAEAEA><P Class=tl>Представляют координаты X и Y точки, в которой пользователь выбрал поле image_button. Для других целей эти переменные не имеют значения. Координата Х находится в интервале, возвращаемом функцией (dimx_tile), координата Y - в интервале, возвращаемом функцией (dimy_tile).</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tcb>$y</P></Td>
 <Td><P Class=tl>Координата Y выбора image_button.</P></Td>
</Tr>
</Table></Center>


<P Class=h55>Примеры:</P>

<P>Если текстовое поле определено как edit1, выражение действия в следующем вызове функции (action_tile) вычисляется после того, как пользователь покинет текстовое поле:</P>
<pre><code> (action_tile "edit1" "(setq ns $value)")</code></pre>
<P>В этот момент $value содержит строку, введенную пользователем, и она сохранится в переменной us.</P>
<P>В следующем примере сохраняется имя выбранного поля, и в случае необходимости программа может ссылаться на него.</P>
<pre><code> (action_tile "edit1" "(setq newtile $key)")</code></pre>
<P>Переменная newtile устанавливается в значение атрибута key выбранного поля, т. е. в "edit1". Переменная $key часто используется внутри функций, которые служат для выполнения действий, присвоенных нескольким различным полям.</P>



<A name="tit3"></A>
<P Class=h3>Вложенные диалоговые окна</P>

<P>Создавая вложенные диалоговые окна, ими можно управлять с помощью функций (new_dialog) и (start_dialog), вызывая их выражение действия. Например, функция (showalert) отобразила бы диалоговое окно "Всем привет" при выборе пользователем клавиши button_l какого-либо нового диалога, если вставить выражение</P>

<pre><code> (action_tile "button_1" "(showalert)").</code></pre>

<P>Для возвращения в предыдущее окно необходимо покинуть текущее.</P>
<P>Слишком большое число вложений усложняет работу. AutoCAD ограничивает число вложений восемью. Рекомендуется использовать около трех-четырех вложенных окон.</P>


<A name="tit4"></A>
<P Class=h3>Временное закрытие диалоговых окон</P>

<P>При необходимости выхода из диалогового окна для интерактивного выбора на графическом экране следует временно закрыть диалоговое окно и после выполнения действия на графическом экране вернуться в диалоговое окно с полным его восстановлением. Такая процедура выполняется с помощью функции (done_dialog) с аргументом status.</P>

<P Class=h55>Пример:</P>

<P>В программе bmake.lsp используется клавиша Указание точки&lt;, которая временно закрывает диалоговое окно для предоставления возможности ввода точки на графическом экране. При указании этой клавиши происходит закрытие диалогового окна с кодом состояния 4:</P>
<pre><code> (action_tile "pick_pt" "(done_dialog 4)")</code></pre>

<P>После возврата из функции (start_dialog) программа проверяет возвращаемый код состояния и при необходимости изменяет координаты точки:</P>
<pre><code>
 (setq what_next (start_dialog))
 (cond ((= what_next 4)
 (progn
 (setq pick_pt (getpoint "Базовая точка вставки: "))
 (setq x_pt (rtos (car (pick_pt) 2 4))
 (setq y_pt (rtos (cadr (pick_pt) 2 4))
 (setq z_pt (rtos (caddr (pick_pt) 2 4))
 ))
   )</code></pre>
<P>Тело основной функции заключено в цикл с вызовом функции (start_dialog) до тех пор, пока пользователь не нажмет на клавишу OK или Cancel:</P>

<pre><code>
 (defun c:mblock...
 ...
 (while (< 2 what_next)
 ...
 (setq what_next (start_dialog)<Br>
 (cond
 ...
 )
 ))</code></pre>
<P>Если диалоговое окно вложено, процедура усложняется, по существу оставаясь прежней:</P>

<pre><code>
 (defun c:mdialog (/what_next what_next1)
 (setq what_next 5)
 (if (&lt; (setq dcl_id (load_dialog "maindlg.dcl")) 0) (exit))
 (while (&lt; 1 what_next)
 (new_dialog "maindlg" dcl_id)
 (action_tile "x" "(subdlg)")
 (cond
 ((= what_next1 3)
 (subdlg)
 (if (/= 3 what_next1)
 (setq what_next (start_dialog))
 )
)
 (T (setq what_next (start_dialog)))
)
 (cond
 ((= 2 what_next)
 (setq xx (getpoint "\пУкажите точку: "))
)
)
)
 )
 (defun subdlg()
 (new_dialog "subdlg" dcl_id)
 (action_tile "hide_all" "(done_dialog 3)")
 (setq what_next (start_dialog))
 (if (= 3 what_next1)
 (done_dialog 2)
)
 )</code></pre>



<A name="tit5"></A>
<P Class=h3>Обработка полей</P>

<P>Как управлять полями при инициализации и в процессе ведения диалога? При изменении значения одного поля со связанными с ним полями должны происходить изменения.</P>

<P><I>Инициализация режимов и значений</I></P>

<P>При инициализации диалогового окна определенное поле может быть первоначально включено или отключено и подсвечено или не подсвечено. Эти операции выполняются с помощью вызова функции (mode_tile). Установить значение поля можно с помощью функции (set_tile). Во время инициализации делаются установки полей списка и создаются изображения.</P>

<P Class=h55>Пример:</P>

<P>Показанный набор функций выполняет установку значения по умолчанию для текстового поля и подсвечивает его:</P>

<pre><code> (setq name_str "Коленчатый вал")
 (set_tile "lastname" name_str)
 (mode_tile "lastname" 2)</code></pre>

<P>Дополнительный вызов функции (mode_tile) может подсветить содержимое текстового поля:</P>

<pre><code> (mode_tile "lastname" 3)</code></pre>

<P>Перед тем, как отключить подсвеченное поле, необходимо с помощью вызова функции (mode_tile) подсветить другое поле. Ведь отключенное подсвеченное поле бессмысленно, что в некоторых случаях может привести к ошибке.</P>
<P>Пример "самоотключения" поля - последовательность "страниц" диалоговых окон, которые перелистываются указанием клавиши "Следующий" или "Предыдущий". Когда указывается клавиша "Следующий" на предпоследней "странице", после перехода эта клавиша отключается. Тоже самое происходит с клавишей "Предыдущий" при переходе на первую "страницу". В обоих случаях использованная клавиша отключается и подсвечивается другое поле.</P>
<P>Предположим, что переключатель с именем "group_on" управляет группой "group": когда переключатель отключен, поля группы недоступны и не могут быть изменены. В этом случае для переключателя следует определить следующее действие:</P>

<pre><code> (action_tile "group_on" "(mode_tile \"group\" (- 1 (atoi $value)))")</code></pre>

<P>Вычитание и вызов функции (atoi) в выражении действия устанавливают значение аргумента mode функции (mode_tile). Так как значение переключателя равно нулю, когда он отключен, и единице, когда он включен, вычитание изменяет значение аргумента mode на противоположное и управляет доступностью группы.</P>

<P><I>Установка полей списков и раскрывающихся списков</I></P>

<P>При установке значений для поля списка или раскрывающегося списка необходимо выполнить следующую последовательность операций:</P>

<pre><code> (start_list), (add_list) и (end_list)</code></pre>

<P>Список можно изменить после его создания. Функция (mapcar) полезна для перевода списка из AutoLISP в отображаемое поле списка:</P>

<pre><code> (start_list "selections" операция)
(mapcar 'add_list newnames)
(end_list)</code></pre>

<P><I>Обработка значений списков</I></P>

<P>При обработке списков значение поля list_box может содержать начальные пробелы, особенно если выбрано несколько пунктов, так что не следует его проверять с помощью функций сравнения строк. Сначала следует преобразовать значение к целому, используя функцию (atoi) или (read).</P>

<P Class=h55>Пример:</P>

<P>Предполагается, что список "justone" позволяет выбрать только один пункт одновременно. Фрагмент кода проверяет, выбран ли третий пункт списка. (Поскольку функция (atoi) возвращает 0, если строка пустая или когда в ней содержится "0", сначала следует проверить, является ли строка пустой.)</P>

<pre><code> (setq index (get_tile "justone"))
(cond
((/= index "")
(= 2 (atoi index)); это третий пункт
...
)
)</code></pre>

<P>Значение раскрывающегося списка никогда не начинается с символа пробела, так что преобразование в этом случае выполнять не обязательно. Раскрывающиеся списки не позволяют выполнять множественный выбор.  Если в поле списка можно выбрать одновременно несколько пунктов, программа должна не только выполнить преобразование, но и перебрать все множество значений в строке.</P>

<P Class=h55>Пример:</P>
<P>Функция (mk_list) возвращает список, содержащий только выбранные пользователем поля из исходного списка displist. Переменная displist определена как глобальная. Предполагается, что функция (mk_list) вызывается с текущим значением $value поля списка.</P>

<pre><code> (defun mk_list (readlist / count item retlist)
 (setq count 1)
 (while (setq item (read readlist))
 (setq retlist (cons (nth item displist) retlist))
 (while (and (/= " " (substr readlist count 1))
 (while (and (/= "" (substr readlist count 1))
 (/= " " (substr readlist count 1)))
 (setq count (1+count))
 )
 (setq readlist (substr readlist count))
)
 (reverse retlist)
)</code></pre>



<A name="tit6"></A>
<P Class=h3>Создание изображений</P>

<P>Последовательность вызовов для создания поля изображения и клавиши изображения аналогична последовательности обработки списка. Функция (start_image) начинает создание изображения, функция (end_image) заканчивает его. Однако определение результата рисования осуществляется путем использования нескольких разных функций, а не путем задания разных аргументов:</P>
<Ul>
 <Li>(vector_image) - рисует вектор (одна прямая линия) на текущем изображении.</Li>
 <Li>(fill_image) - рисует закрашенный прямоугольник.</Li>
 <Li>(slide_image) - отображает слайд AutoCAD.</Li>
</Ul>

<P>Эти функции требуют определения абсолютных координат. Чтобы задать их корректно, следует знать размеры поля изображения или клавиши изображения. Так как размеры полей определяются во время их компоновки, функции PDB обеспечивают получение ширины и высоты поля: (dimx_tile) и (dimy_tile). Начало поля (0 0) всегда находится в верхнем левом углу.</P>

<P Class=h55>Примеры:</P>

<P>Предположим, что нужно закрасить красным цветом поле изображения "cur_color":</P>

<pre><code> (setq width (dimx_tile "cur_color")
 height (dimy_tile "cur_color"))
 (start_image "cur_color")
 (fill_image "cur_color")
 (fill_image 0 0 width height 1) ; 1 - красный цвет AutoCAD
 (end_image)</code></pre>

<P>Далее нарисуем вокруг поля границу красного цвета, а не закрашенный прямоугольник (векторы рисуются против часовой стрелки):</P>
<pre><code> (setq width (dimx_tile "border")
 height (dimy_tile "border"))
 (start_image "border")
 (vector_image 0 0 0 height 1)
 (vector_image 0 height width height 1)
 (vector_image width height width 1)
 (vector_image width 0 0 0 1)
 (end_tmage)</code></pre>

<P>Функции отрисовки должны вызываться вместе. Изобразим закрашенное изображение и нарисуем на нем вертикальную линию:</P>

<pre><code> (setq width (dimx_tile "striple")
 height (dimy_tile "striple"))
 (start_image "striple")
 (fill_image 0 0 width height 3) ; 3 - зеленый цвет AutoCAD
 (setq x(/ width 2.0)
 (vector_image x 0 height 4) ; 4 - фиолетовый цвет AutoCAD
 (end_image)</code></pre>

<P>Отображаемые с помощью функции (slide_image) слайды могут быть отдельными слайд-файлами (.sld) или частью файла библиотеки слайдов (.slb). Расширение указывать не нужно. Просто слайд именуется по имени, слайд из библиотеки именуется как в меню: сначала имя библиотеки, затем имя слайда в скобках. Функция (slide_image) ищет слайд или библиотеку слайдов в соответствии с текущим путем поиска библиотек AutoCAD.</P>
<P>Предположим, что необходимо отобразить слайд tppview.sld:</P>

<pre><code> (setq x (dimx_tile "view")
 у (dimy_tile "view"))
 (start_image "view")
 (slide_mage 0 x у "topview")
 (end_image)</code></pre>

<P>Векторы слайда часто рисуются бельм цветом, который является цветом фона изображения по умолчанию. Если слайд после вывода не виден, надо изменить атрибут color на значение graphic_background.</P>


<A name="tit7"></A>
<P Class=h3>Ввод клавиши изображения</P>

<P>Клавишу изображения можно обрабатывать как и обычную клавишу, т. е. при ее указании вызывается соответствующее действие. Однако имеется возможность определения клавиши так, что действие будет зависеть от места указания в зоне клавиши. Для этого действие клавиши должно получить координаты точки указания. Координаты задаются в диапазоне размера изображения и возвращаются функциями определения размеров.</P>

<P Class=h55>Пример:</P>

<P>Допустим, что клавиша изображения имеет две прямоугольные области разного цвета. Требуется определить, какую из областей указал пользователь. Если клавиша разделена горизонтально, следует проверять только один размер:</P>

<pre><code> (action_tile "image_set" "(pick_shade" $key $value $y)")
 ...
 ...
 (defun pick_shade (key val y)
 (setq threshold (/ dimy_tile key) 2))
 (if (y threshold)
 (setq result "Светлый")
 (setq result "Темный"))
 )</code></pre>


<A name="tit8"></A>
<P Class=h3>Обработка групп выбора</P>

<P>Кнопки выбора появляются в группах выбора. Значение каждой отдельной кнопки может быть равно единице, если она включена, или нулю, если она отключена. Значением группы кнопок выбора является ключ, выбранной в данный момент кнопки. Проводится проверка включения только одной кнопки. Приложение может присвоить действие каждой отдельной кнопке выбора, но более приемлемым является присвоение действия группе кнопок выбора как единому целому и использование присылаемого ключа для определения, какая из кнопок выбрана в данный момент.</P>

<P Class=h55>Пример:</P>

<P>Допустим, что группа кнопок выбора определяет вид трехмерного объекта, который будет отображен после закрытия диалогового окна. При этом группа состоит из четырех кнопок (их может быть и больше):</P>


<pre><code> (action_tile "view_set" "(pick $value)")
 ...
 ...
 (defun pick_view (which)
((cond ((= which "front") (setq show_which 0))
((cond ((= which "top") (setq show_which 1))
((cond ((= which "left") (setq show_which 2))
((cond ((= which "right") (setq show_which 3))
)
 )</code></pre>

<P>Этот пример показывает, что все кнопки выбора связаны с одной переменной, которая может иметь несколько значений. Кроме, того, кнопки выбора могут выполнять еще и некоторые дополнительные действия, например отменять сделанный в диалоговом окне выбор.</P>


<A name="tit9"></A>
<P Class=h3>Обработка скользящих шкал</P>

<P>Действие скользящей шкалы проверяет код причины. В качестве примера покажем базовую схему функции управления скользящей шкалой. Она вызывается из связанного с ней выражения действия. Поле slider_info используется этой функцией для вывода в десятичной форме текущего значения состояния шкалы и является текстовым полем, которое дает пользователю возможность управлять состоянием скользящей шкалы, непосредственно вводя значения. Если пользователь ввел значение в поле slider_info, функция текстового поля изменит значение состояния скользящей шкалы:</P>

<pre><code> (action_tile "my_slider" "(slider_action $value $reason)")
 (action_tile "my_info" "(ebox_action $value $reason)")
 ...
 ...
 (defun slider_action (val why)
(if (or (= why 2)(= why 1))
(set_tile "slider_info" val)
 )
 )
 (defun ebox_action (val why)
(if (or (= why 2)(= why 1))
set_tile "myslider" val)
 )
 )</code></pre>

<A name="tit10"></A>
<P Class=h3>Обработка текстовых полей</P>

<P>Действия, управляющие текстовыми полями, аналогичны функциям обработки скользящих шкал, но при этом значение текстового поля всегда видимо и нет необходимости выполнять действия, связанные с промежуточными результатами.</P>

<P Class=h55>Пример проверки значения без вывода его заново:</P>

<pre><code> (action_tile "myeditbox "(edit_action $value $reason)
 ...
 ...
 (defun edit_action (val why)
(if (or (= why 2) (= why 4))
(set_tile "myeditbox" val)
)
)
 )</code></pre>


<A name="tit11"></A>
<P Class=h3>Определяемые приложением данные</P>

<P>Функция client_data-tile присваивает полю определяемые приложением значения переменных. Эти данные доступны аналогично переменной AutoLISP $data. Данные приложения имеют смысл только во время исполнения приложения. Использование данных приложения сравнимо с использованием определенных пользователем атрибутов. Основное различие состоит в том, что атрибуты пользователя предназначены только для чтения, в то время как данные приложения могут изменяться во время выполнения программы и пользователь может проверить определенный им атрибут в DCL-файле приложения, а данные приложения для пользователя недоступны. В AutoLISP данные приложения определены текстовыми строками.</P>

<P Class=h55>Пример:</P>

<P>Так как программа должна поддерживать список, выводимый в поле списка (или в раскрывающемся списке), данные приложения могут быть использованы для обработки этой информации. В AutoLISP следующая модификация определения функции (mk_list) возвращает список как аргумент:</P>
<pre><code> (defun mk_list (readlist displist)
 (setq count 1)
 (while (setq item (read readlist))
 (setq retlist (cons (nth item displist) retlist))
 (while (and (/= "" (substr readlist count 1))
 (while (and (/= "" (substr readlist count 1))
 (/= "" (substr readlist count 1)))
 (setq count (1+count))
)
 (setq readlist (substr readlist count))
)
 (reverse retlist)
)</code></pre>

<P>Это обстоятельство устраняет необходимость в переменной глобального списка. Следующие вызовы в основной части программы обработки диалоговых окон связывают короткий список с полем: вызывают функцию (client_data_ tile), затем передают список в функцию (mk_list) посредством выражения действия:</P>

<pre><code> (client_data_tile "colorsyslist"
"Red-Green-Blue Cyan-Magenta-Yeltow Hue-Saturation-Value")
 (action_tile "colorsyslist" "(setq usrchoice (mk_list $value $data))")</code></pre>

<hr width="90%" color="#7685C6" align="Right">
</Div>
 <Div Class="post_body" Align="left">
<a href='javascript:;'><Div Class="sp-body" title="Примеры разработки диалоговых окон" style="display: none;"></a>

<P>Рассмотрим создание диалоговых окон в LISP-программах на примере простейшей программы, создающей окно с одной кнопкой выхода.</P>

<pre><code>; Программа выведения на экран простого окона с кнопкой Оk
 ; создадим файл с расширением lsp (Sample.lsp)
 (defun c:hello ()
(setq dcl_id (load_dialog "hello.dcl"))
(if (not (new_dialog "hello" dcl_id) ) (exit))
(action_tile "accept" "(done_dialog)")
(start_dialog)
 (unload_dialog dcl_id)
 )</code></pre>

<P>Для корректной работы программы необходимо функцию (load_dialog "hello.dcl") дополнить полным путём к файлу hello.dcl (Например, так: (load_dialog "D:\\work\\hello.dcl")). Далее создадим текстовый файл hello.dcl по указанному пути со следующим содержанием:</P>
<pre><code> hello : dialog {label = "Sample Dialog Box";
{label = "Hello, world";}
:button {key = "accept"; label = "OK"; is_default = true;}
 }</code></pre>

<Br>
<p><Img Src=images/lisp/lisp_dcl601.gif></Center>

<P>Диалоговое окно имеет название Sample Dialog Box и содержит сообщение Hello, world. Размер кнопки и её содержание определены по умолчанию, но это легко изменить с помощью двух атрибутов:<Br><Br>

<Span Class="code">fixed_width</Span> - (изменнение размера кнопки до размров текста в ней);<br> 
<Span Class="code">alignment</Span> - (установка кнопки в центре диалогового окна).</P>

<p><Img Src=images/lisp/lisp_dcl602.gif></Center>
<hr width="90%" color="#7685C6" align="Right">
</Div>
 


</Ul><Br>


<A Name=3></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=99% BgColor=#9CA6CE>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../оболочка/images/raspor.gif></Td><Td align=left><span Class=h>Справочник</span></Td></Tr>
<Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<Ul>
 <Li><A Href=lisp_system.html Class="u">Список системных переменных в AutoCAD</A></Li>
</Ul><Br>

</Td></Tr></Table>

 </Td>
</Tr>

<Tr>
 <Td ColSpan=2>

<Table Border=0 CellSpacing=0 CellPadding=0>
 <Tr>
  <Td BackGround=../Оболочка/images/bg09.gif Width=458 Height=100 Valign=Bottom>
   <P Class=co>Copyright &copy; БГУИР, Кафедра Систем управления, 2017<Br>
   <Img Src=../Оболочка/images/raspor.gif Width=1 Height=8></P></Td>
  <Td BackGround=../Оболочка/images/bg10.gif Width=159 Height=100>
   <A Href=#Top onMouseOver="mOver(6)" onMouseOut="mOut(6)"><Img Src=../Оболочка/images/06a.gif Width=159 Height=46 Border=0 Alt="К началу документа" name="link6"></A><Br>
   <A Href=!zadanie.html onMouseOver="mOver(7)" onMouseOut="mOut(7)"><Img Src=../Оболочка/images/07a.gif Width=159 Height=54 Border=0 Alt="К первой странице" name="link7"></A></Td>
 </Tr>
</Table>

 </Td>
</Tr>
</Table>

</Body>
</HTML>