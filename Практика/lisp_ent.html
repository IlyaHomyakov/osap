<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>

<Head>
<Meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<Title>Электронный ресурс по учебной дисциплине ОСАПр. Работа с графической базой данных чертежа. Доступ к примитивам AutoCAD</Title>
<Meta Name="Description" http-equiv="description" Content="Электронный ресурс по учебной дисциплине ОСАПр. Работа с графической базой данных чертежа. Доступ к примитивам AutoCAD">
<Link Rel="stylesheet" Type="text/css" Href="../../../Оболочка/acad.css">

<Script>hljs.initHighlightingOnLoad();</Script>

<Script Language="JavaScript">
<!--
	function mOver(num) {if (document.images) {document.images['link'+num].src=eval('active'+num+'.src');}}
	function mOut(num) {if (document.images) {document.images['link'+num].src=eval('normal'+num+'.src');}}
//-->
</Script>
</Head>

<Body Bgcolor=#E6E6E6 TopMargin=1 LeftMargin=1 MarginWidth=0 MarginHeight=0 >
<div class=max>
<Script Language="JavaScript"><!--
if (document.images) {
	normal1=new Image(190,29);normal1.src="../../../Оболочка/images//01a.gif";
	active1=new Image(190,29);active1.src="../../../Оболочка/images//01p.gif";
	normal2=new Image(190,29);normal2.src="../../../Оболочка/images/02a.gif";
	active2=new Image(190,29);active2.src="../../../Оболочка/images/02p.gif";
	normal3=new Image(190,29);normal3.src="../../../Оболочка/images//03a.gif";
	active3=new Image(190,29);active3.src="../../../Оболочка/images//03p.gif";
	normal4=new Image(159,46);normal4.src="../../../Оболочка/images//09a.gif";
	active4=new Image(159,46);active4.src="../../../Оболочка/images//09p.gif";
	normal5=new Image(159,54);normal5.src="../../../Оболочка/images//10a.gif";
	active5=new Image(159,54);active5.src="../../../Оболочка/images//10p.gif";
	normal7=new Image(190,29);normal7.src="../../../Оболочка/images//7a.gif";
	active7=new Image(190,29);active7.src="../../../Оболочка/images//7p.gif";
	normal11=new Image(170,25);normal11.src="../../../Оболочка/images//02_1a.gif";
	active11=new Image(170,25);active11.src="../../../Оболочка/images//02_1p.gif";
	normal12=new Image(170,19);normal12.src="../../../Оболочка/images//02_2a.gif";
	active12=new Image(170,19);active12.src="../../../Оболочка/images//02_2p.gif";
	normal13=new Image(170,19);normal13.src="../../../Оболочка/images//02_3a.gif";
	active13=new Image(170,19);active13.src="../../../Оболочка/images//02_3p.gif";
	normal24=new Image(170,19);normal24.src="../../../Оболочка/images//04a.gif";
	active24=new Image(170,19);active24.src="../../../Оболочка/images//04p.gif";
	normal25=new Image(170,19);normal25.src="../../../Оболочка/images//05a.gif";
	active25=new Image(170,19);active25.src="../../../Оболочка/images//05p.gif";
	normal26=new Image(170,19);normal26.src="../../../Оболочка/images//06a.gif";
	active26=new Image(170,19);active26.src="../../../Оболочка/images//06p.gif";
	normal14=new Image(170,19);normal14.src="../../../Оболочка/images//l1_a.gif";
	active14=new Image(170,19);active14.src="../../../Оболочка/images//l1_p.gif";
	normal15=new Image(170,19);normal15.src="../../../Оболочка/images//z_a.gif";
	active15=new Image(170,19);active15.src="../../../Оболочка/images//z_p.gif";
	normal16=new Image(170,19);normal16.src="../../../Оболочка/images//l2_a.gif";
	active16=new Image(170,19);active16.src="../../../Оболочка/images//l2_p.gif";
	normal17=new Image(170,19);normal17.src="../../../Оболочка/images//z_a.gif";
	active17=new Image(170,19);active17.src="../../../Оболочка/images//z_p.gif";
	normal18=new Image(170,19);normal18.src="../../../Оболочка/images//l3_a.gif";
	active18=new Image(170,19);active18.src="../../../Оболочка/images//l3_p.gif";
	normal19=new Image(170,19);normal19.src="../../../Оболочка/images//z_a.gif";
	active19=new Image(170,19);active19.src="../../../Оболочка/images//z_p.gif";
	normal20=new Image(170,19);normal20.src="../../../Оболочка/images//l4_a.gif";
	active20=new Image(170,19);active20.src="../../../Оболочка/images//l4_p.gif";
	normal21=new Image(170,19);normal21.src="../../../Оболочка/images//z_a.gif";
	active21=new Image(170,19);active21.src="../../../Оболочка/images//z_p.gif";
	normal27=new Image(170,19);normal27.src="../../../Оболочка/images/15a.gif";
	active27=new Image(170,19);active27.src="../../../Оболочка/images/15p.gif";
}
//-->
</Script>

<Left>
<A Name="Top"></A>
<Table Border=0 Width=100% CellSpacing=0 CellPadding=0>
<Tr>
 <Td BackGround=../../../Оболочка/images/bg01.gif Width=190 Height=91 name="link19">&nbsp;</Td>
 <Td Rowspan=2 BackGround=../../../Оболочка/images/bg02_acad.gif Height=120 Valign=Bottom style="background-repeat:no-repeat;">

<Table BackGround=../../../Оболочка/images/raspor.gif Border=0 CellSpacing=0 CellPadding=0>
 <Tr>
  <Td Width=230></Td>
  <Td><P Class=h6>AutoLISP<Br><Img Src=../../../Оболочка/images/raspor.gif Width=1 Height=26></P></Td>
 </Tr>
</Table>

</Td></Tr>
<Tr>
 


<Td BackGround=../../../Оболочка/images/bg03.gif>
 <A Href=../../../Программа/!rabprog.html onMouseOver="mOver(26)" onMouseOut="mOut(26)"><Img Src=../../../Оболочка/images/06a.gif Width=190 Height=29 Border=0 
Alt="Рабочая программа" name="link26"></A><Br></Td>

</Tr>
<Tr>
 <Td BackGround=../../../Оболочка/images/bg09.gif Valign=Top>

<Table Border=0 CellSpacing=0 CellPadding=0>
<Tr><Td BackGround=../../../оболочка/images/bg03.gif Valign=Top>
	<A Href=../../../Теория/!lekcii.html onMouseOver="mOver(7)" onMouseOut="mOut(7)"><Img Src=../../../оболочка/images/7a.gif Width=190 Height=29 Border=0 
Alt="Лекции" name="link7"></A><Br>
 </Td>
 <Tr><Td BackGround=../../../оболочка/images/bg04.gif Width=190 Valign=Top>
 <a href="../../!zadanie.html"> <Img Src=../../../оболочка/images/8p.gif Border=0 Width=190 Height=29 Alt="Лабораторные работы"></a><Br></Td>
<Tr><Td BackGround=../../../оболочка/images/bg05_1.gif Width=190 Valign=Top>
  <A href="../lb1/!acad.html" onMouseOver="mOver(14)" onMouseOut="mOut(14)"><Img Src=../../../оболочка/images/l1_a.gif Width=170 Height=40 Border=0 Alt="Лабораторная работа 1" name="link14"></A><Br></Td></Tr>
<Tr><Td BackGround=../../../оболочка/images/bg06.gif Width=190 Height=36 Valign=Top>
   <A href="../lb1/laba1.html"  onMouseOver="mOver(15)" onMouseOut="mOut(15)"><Img Src=../../../Оболочка/images/z_a.gif Width=170 Height=20 Border=0 Alt="Задания 1" name="link15"></A><Br>
  <A href="../lb2/!mechanic.html" onMouseOver="mOver(18)" onMouseOut="mOut(18)"><Img Src=../../../Оболочка/images/l3_a.gif Width=170 Height=40 Border=0 Alt="Лабораторная работа 2" name="link18"></A><Br>
<A  href="../lb2/laba2.html" onMouseOver="mOver(19)" onMouseOut="mOut(19)"><Img Src=../../../Оболочка/images/z_a.gif Width=170 Height=20 Border=0 Alt="Задания 2" name="link19"></A><Br>
  <A href="../lb2/!mechanic.html" onMouseOver="mOver(20)" onMouseOut="mOut(20)"><Img Src=../../../Оболочка/images/l4_a.gif Width=170 Height=40 Border=0 Alt="Лабораторная работа 3" name="link20"></A><Br>
<A href="../lb3/laba3.html"1 onMouseOver="mOver(21)" onMouseOut="mOut(21)"><Img Src=../../../Оболочка/images/z_a.gif Width=170 Height=20 Border=0 Alt="Задания 3" name="link21"></A><Br>
 <A href="../lb4/!lisp.html" onMouseOver="mOver(16)" onMouseOut="mOut(16)"><Img Src=../../../Оболочка/images/l2_a.gif Width=170 Height=40 Border=0 Alt="Лабораторная работа 4" name="link16"></A><Br>
<A  href="../lb4/laba4.html" onMouseOver="mOver(17)" onMouseOut="mOut(17)"><Img Src=../../../Оболочка/images/z_a.gif Width=170 Height=20 Border=0 Alt="Задания 4" name="link17"></A><Br>
  <Img Src=../../../Оболочка/images/bg07.gif Width=190 Height=23><Br></Td></Tr>
 
 <Tr><Td BackGround=../../../оболочка/images/bg03.gif Valign=Top>
   <A Href=../../../Заочнику/!zaochnoe.html onMouseOver="mOver(27)" onMouseOut="mOut(27)"><Img Src=../../../Оболочка/images/15a.gif Width=190 Height=29 Border=0  Alt="Заочнику" name="link27"></A><Br>
  <A Href=../../../Контроль_знаний/!samocontrol.html onMouseOver="mOver(25)" onMouseOut="mOut(25)"><Img Src=../../../оболочка/images/05a.gif Width=190 Height=29 Border=0 
Alt="Самоконтроль" name="link25"></A><Br>
	 <Img Src=../../../оболочка/images/bg08.gif Width=190 Height=13><Br>
</Table></Td>
 <Td Valign=Top>
<P><Br></P>

<Center>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=95%><Tr><Td>

<Br>
<Table Border=0 CellPadding=0 CellSpacing=0>
<Tr><Td Bgcolor=#000000><Img Src=../../../оболочка/images/raspor.gif Height=2></Td>
<Tr><Td Valign=Center Height=30><span Class=h1>Работа с графической базой данных чертежа. Доступ к примитивам AutoCAD</span></Td></Tr>
<Tr><Td Bgcolor=#000000><Img Src=../../../оболочка/images/raspor.gif Height=2></Td></Tr>
</Table></Center><Br>


<P>Чуть ли не самой главной особенностью AutoLISP является то, что он позволяет осуществлять доступ к графической базе данных (ГБД) AutoCAD, многократно умножая возможности адаптации последнего к какому-либо типу задач. Попытаемся вкратце показать, как можно использовать возможности AutoLISP для работы непосредственно с объектами чертежа.</P>

<P>Любой создаваемый в AutoCAD чертеж состоит из отдельных примитивов, геометрическое описание которых хранится в специальном формате (формате AutoCAD) в файле чертежа (расширение .dwg). При загрузке чертежа AutoCAD заполняет графическую базу данных - заносит в нее системные настройки, создает список объектов и вносит в ГБД геометрическое описание этих объектов, присваивая при этом каждому примитиву уникальное имя. Итак, в сеансе редактирования каждый примитив AutoCAD (отрезок, дуга, окружность и т. п.) имеет свое имя, по которому его распознает сам AutoCAD. Поскольку имена меняются от одного сеанса редактирования к другому, не имеет смысла их хранить - даже не пытайтесь запомнить их. Вместо этого следует в программе на AutoLISP сначала найти имя примитива в базе данных AutoCAD с тем, чтобы впоследствии непосредственно манипулировать геометрическими характеристиками примитива или использовать их в макроопределениях меню. Попробуем извлечь это имя из ГБД при помощи AutoLISP. Нарисуйте отрезок и введите с командной строки AutoCAD cтроку</P>

<pre><code> Command:(setq ename (entlast))
 AutoCAD возвращает: Еntity name: 7ef74040</code></pre>

<P>Тем самым мы присвоили переменной ename имя последнего примитива (в данном случае отрезка). Напомним еще раз, что имена примитивов меняются от сеанса к сеансу, и вы наверняка увидите на экране другое имя. Имена примитивов в AutoCAD - шестнадцатеричные величины; имя примитива может быть, например, таким: 60000А14. Используя это имя, вы можете при помощи функции ENTGET получить доступ к данным, связанным с примитивом:</P>

<pre><code> (setq edata (entget ename))</code></pre>

<P>Имя примитива - это новый для нас тип данных AutoLISP, и если функции AutoLISP ENTGET требуется имя примитива, то бесполезно указывать число 60000018 - надо передать переменную ename, в которой это имя хранится.</P>
<P>В результате, выполнения команды вы получите малопонятное сообщение:</P>

<P Class=h5>((-1 . &lt;Entity name: 7ef74040gt;) (0 . "LINE") (330 . &lt;Entity name: 7ef5ecf8gt;) (5 . "F8")
(100 . "AcDbEntity")<Br> (67 . 0) (410 . "Model") (8 . "0") (100 . "AcDbLine") (10 -123.938 -28.7308 0.0) (11 12.2498 -34.8203 0.0)
(210 0.0 0.0 1.0))</P>

<P>Дело в том, что с точки зрения AutoLISP все данные, описывающие примитив, представляют собой список, состоящий, в свою очередь, из подсписков, в которых сгруппированы по функциональному назначению все данные о примитиве, как геометрические, так и общие: слой, цвет и т. п. Подсписки отличаются друг от друга по специальным кодам формата DXF (Drawing eXchange Format - формат обмена чертежами), которые позволяют определить, какой тип данных хранится в подсписке. Каждый подсписок имеет две части. Первая - код DXF, вторая - данные. Целое число 0, например, представляет собой код типа примитива. Код 8 говорит о том, что следующее за ним число - номер слоя. Код 10 - начальная точка примитива, код 11 - конечная, и т. п. Отметим, что набор кодов DXF различен для примитивов разных типов. Однако сами коды относятся ко всем примитивам - имя примитива, например, всегда хранится в подсписке с кодом DXF -1.</P>

<P>Представим полученный список edata в более понятном виде:</P>

<pre><code> ((-1 . &lt;Entity name: 7ef74040&gt;)	
;Имя примитива в ГБД чертежа. Меняется всякий раз при открытии чертежа и не хранится в DWG
 (0 . "LINE")                    			
;Тип примитива
 (330 . &lt;Entity name: 7ef5ecf8&gt;)  		
;Изменяемый указатель; arbitrary soft pointers to other objects within same DXF file or drawing
 (5 . "F8")                       			
;Указатель примитива; Текстовая строка до 16 шестнадцатиричных чисел
 (100 . "AcDbEntity")           			 
Маркер данных подкласса (со строкой производного класса)
 (67 . 0)                       			 
Пространство модели или пространство чертежа
 (410 . "Model")                			
;Строка
 (8 . "0")                      			 
Имя слоя
 (100 . "AcDbLine")             			
;Подкласс маркера данных (со строкой производного класса) 
 (10 -123.938 -28.7308 0.0)      		
;Начальная точка
 (11 12.2498 -34.8203 0.0)       		
;Конечная точка
 (210 0.0 0.0 1.0))	              		
;Направление выдавливания (fixed) APP: 3D вектор направления выдавливания</code></pre>

<P>Пользуясь DXF кодами, можно извлечь из списка edata любую информацию о примитиве. Такой доступ к рисунку более сложен, но предоставляет гибкие возможности по изменению практически всех свойств примитивов.</P>

<P>В AutoCAD имеется стандартное средство работы не с одним, а с несколькими примитивами. Это средство
называется набором. Практически все команды редактирования работают не с отдельными примитивами, а с
группой примитивов. Из AutoLISP также можно работать с наборами примитивов - предоставлять пользователю
возможность заносить примитивы в набор и затем их модифицировать. Набор формируется функцией SSGET:</P>

<pre><code>(ssget [режим] [точка1] [точка2])</code></pre>

<P>Необязательный аргумент режим - это строка, которая указывает способ выбора примитива. Им может быть
"W", "С", "L", "P", "WP", "СP" - соответствующие Рамке, Секущей рамке, Последнему и Текущему набору
примитивов AutoCAD, Многоугольнику и Секущему многоугольнику. Аргументы точка1 и точка2 - списки
точек, указывающие точки, относящиеся к выбору.</P>

<P Class=h55>Примеры функции SSGET:</P>
<pre><code> (ssget)					
;Создаёт набор из одного объекта чертежа
 (ssget "P")					
;Создаёт набор из последних выбранных примитивов
 (ssget "L")					
;Создаёт набор из последнего видимого примитива добавленного к базе данных
 (ssget '(2 2))				
;Создаёт набор из примитива, проходящего через точку (2, 2)
 (ssget "W" '(0 0) '(5 5))		
;Создаёт набор из примитивов в рамке от (0,0) до (5,5)
 (ssget "С" '(0 0) '(4 5))			
;Создаёт набор из примитивов, пересекаемых рамкой от (0,0) до (4,5)
 (ssget "X" список-фильтр)		
;Создаёт набор из примитивов в соответствии со списком-фильтром</code></pre>
<P>Выбранные объекты подсвечиваются только тогда, когда SSGET используется без аргументов.</P>
<P>Особый режим - режим SSGET "X" - фильтры выбора. В этом режиме функция SSGET просматривает весь рисунок и создает набор, состоящий из имен всех основных примитивов, удовлетворяющих заданным критериям.</P>
<P>Доступные коды для SSGET "X" представлены в следующей таблице:</P>

<Center>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Код</P></Td>
 <Td><P Class=tcb>Значение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>0</P></Td>
 <Td><P Class=tl>Тип примитива</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>2</P></Td>
 <Td><P Class=tl>Имя блока для описания блока (INSERT)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>6</P></Td>
 <Td><P Class=tl>Имя типа линии</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>7</P></Td>
 <Td><P Class=tl>Имя гарнитуры шрифта для определений текста или атрибутов</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>8</P></Td>
 <Td><P Class=tl>Имя слоя</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>38</P></Td>
 <Td><P Class=tl>Уровень (вещественное число)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>39</P></Td>
 <Td><P Class=tl>Высота (вещественное число)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>62</P></Td>
 <Td><P Class=tl>Код цвета (0="BYBLOCK, 256= "BYLAYER")</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tc>66</P></Td>
 <Td><P Class=tl>Следующий за атрибутом флаг в описании блока (INSERT)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tc>210</P></Td>
 <Td><P Class=tl>Вектор направления выдавливания (список из трех вещественных чисел)</P></Td>
</Tr>
</Table></Center>


<P>Для первых пяти кодов разрешается использовать глобальные символы.</P>
<P>Например, используя этот режим, можно создать набор, состоящий из всех отрезков, находящихся на слое "ЭТАЖ" зеленого цвета:</P>

<pre><code> (ssget "х" '((0 . "LINE")(8 . "ЭТАЖ")(62 . 3)))</code></Pre>

<P>В AutoLISP имеются хорошие средства работы с наборами примитивов. Рассмотрим их вкратце.</P>


<Center>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Примитив</P></Td>
 <Td><P Class=tcb>Действие</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(sslength набор)</P></Td>
 <Td><P Class=tl>Возвращает число примитивов в наборе. Если это число больше 32 767, то оно возвращается как действительное</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(ssname набор номер)</P></Td>
 <Td><P Class=tl>Возвращает имя примитива под номером из набора. Запомните, что первый примитив в наборе имеет номер 0! Если примитивов слишком много, используйте действительные числа (округляются до целых)</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(ssadd имя_примитива набор)</P></Td>
 <Td><P Class=tl>Если вызвать функцию без аргументов, ssadd создаст новый набор без единого примитива. Если вызвать только с аргументом имя_примитива, будет создан набор, содержащий один примитив. Если вызвать с обоими указанными аргументами, примитив имя_примитива будет добавлен в набор</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(ssdel имя_примитива набор)</P></Td>
 <Td><P Class=tl>Удаляет имя_примитива из набора и возвращает новый набор</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(ssmemb имя_примитива набор)</P></Td>
 <Td><P Class=tl>Если примитив имя_примитива находится в наборе, то возвращается имя примитива, если нет - nil</P></Td>
</Tr>
</Table></Center>


<P>Рассмотрим далее функции, позволяющие извлекать имена примитивов из ГБД по их порядку.</P>

<Center>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
 <Td><P Class=tcb>Функция</P></Td>
 <Td><P Class=tcb>Назначение</P></Td>
</Tr>
<Tr Bgcolor=#DCDCDC>
 <Td><P Class=tl>(entnext [имя_примитива])</P></Td>
 <Td><P Class=tl>Будучи вызвана без параметров, возвращает имя первого неудаленного примитива в ГБД. Если задан аргумент имя_примитива, будет возвращено имя первого неудаленного примитива, следующего в ГБД за примитивом имя_примитива. Если примитива нет, будет возвращен nil. Возвращаются как основные примитивы, так и субпримитивы (например, вершины полилинии, полученные в результате аппроксимации последней сплайном)</P></Td>
</Tr>
<Tr Bgcolor=#EAEAEA>
 <Td><P Class=tl>(entlast)</P></Td>
 <Td><P Class=tl>Возвращается имя последнего основного неудаленного примитива в ГБД</P></Td>
</Tr>
</Table></Center>


<P>Из AutoLISP можно непосредственно модифицировать данные о существующих в ГБД примитивах. Однако если мы хотим добавить новый примитив, то должны использовать команды отрисовки или редактирования AutoCAD. Это ограничение связано с желанием защитить ГБД от неграмотного программиста: неправильно пользуясь командами AutoCAD, вы не сможете испортить саму ГБД - самое большее, что вы испортите, это свой чертеж.</P>
<P>Примитивы можно удалять из чертежа командой</P>

<pre><code> (entdel ename)</code></pre>

<P>AutoLISP возвращает имя примитива, например:</P>

<P Class=h5>&lt;Entityname:60000018&gt;<Br>
&lt;Имя примитива: 60000018&gt;</P>

<P>Интересно, что если вы повторите эту операцию, то примитив будет восстановлен. Этот способ позволяет удалять из ГБД невидимые примитивы, что невозможно обычным выбором объектов (нельзя выбрать невидимый объект).</P>
<P>Для того, чтобы модифицировать геометрические характеристики примитива непосредственно в ГБД , надо уметь находить в DXF-списке данных примитива (наша переменная edata) подсписки, в которых хранится нужная информация. Выбор и изменение различных данных, относящихся к примитиву, осуществляется по коду DXF (это всегда целое число) с помощью функций assoc и subst:</P>

<pre><code> (assoc элемент_списка список)</code></pre>

<P>Извлекает из списка элемент списка по ключу элемент_списка. Если элемент_списка не найден, assoc возвращает nil.</P>
<P>При помощи этой функции можно извлечь, например, из списка goods ((1 "car" "volvo")(2 "price" 80000)) подсписок (2 "price" 80000):</P>

<pre><code> (assoc 2 goods) возвращает список (2 "price" 80000)
 (subst новый_элемент старый_элемент список)</code></pre>

<P>Возвращает копию исходного списка с заменой всех найденных подсписков, идентичных старому_элементу, на новый_элемент. Если вхождений не обнаружено, subst возвращает копию старого списка (не nil!):</P>

<pre><code> (subst '(2 "price" 100000) '(2 "price" 80000) goods)</code></Pre>
<P>возвращает:</P>
<pre><code> ((1 "car" "volvo")(2 "price" 100000))</code></pre>

<P>Используя эту технику, попробуем извлечь из списка edata имя примитива:</P>

<pre><code> Command:(assoc 0 edata)
AutoLISP возвращает:(0 . "LINE")</code></pre>

<P>В приведенном только что примере мы фактически сказали AutoLISP: "Возврати мне подсписок с DXF-кодом 0". AutoLISP просмотрел DXF-список примитива, нашел подсписок с кодом 0 и возвратил его. Разумеется, целиком. Полученный по коду подсписок все еще содержит DXF-код, который необходимо убрать: первый элемент списка, уже "отработал" свое и больше не понадобится. Для этой цели лучше всего использовать функцию CDR:</P>

<pre><code> Command:(cdr (assoc 0 edata))
AutoLISP возвращает:"LINE"</code></pre>

<P>Извлекая из DXF-списков нужную информацию, можно программно обрабатывать ее и затем, внеся изменения в DXF-список примитива при помощи функции subst, модифицировать ГБД при помощи функций entmod и entupd.</P>

<pre><code> (entmod список)</code></pre>

<P>С помощью данной функции преобразуется список в формат, возвращаемый функцией ENTGET, и обновляется информация базы данных о примитиве, имя которого указано в группе -1 списка. С помощью функции ENTMOD нельзя изменить тип примитива. Все объекты, на которые ссылается список примитива (гарнитура шрифта, тип линии, имена форм и блоков), должны быть известны AutoCAD к моменту ее вызова. Исключением является имя слоя: если неизвестный AutoCAD слой поименован в списке, ENTMOD создает новый слой со стандартными значениями.</P>

<pre><code> (entupd имя_примитива)</code></pre>
<P>Функция регенерации отдельного примитива, не обязательно основного.</P>
<P>Приведем пример того, как можно из AutoLISP модифицировать вершину полилинии:</P>
<pre><code> (setq e1 (entnext))		;Переменной е1 присваивается имя полилинии
 (setq e2 (entnext e1))		;Переменной e2 присваивается имя первой вершины
 (setq ed (entget e2))		;В списке ed данные о вершине 1
 (setq ed				;Модификация переменной ed
  (subst(10 1.0 3.7)		;Этот список помещается на место старого
  (assoc 10 ed)			;вхождения списка с первым элементом 10
  )
 )
 (entmod ed)			;Обновляет данные в ГБД
 (entupd e1)			;Обновляет полилинию на экране</code></pre>
<P>Заметим, что если вы попытаетесь извлечь данные о вставке блока (INSERT), то получите информацию о самой вставке, а не об определении блока.</P>
<P>Итак, для модификации примитива (группы примитивов) непосредственно в базе данных нужно:</P>
<Ul>
 <Li>предложить пользователю выбрать примитив (функция entsel) или группу примитивов (функция ssget). Используя функцию ssget, можно выбирать примитивы из ГБД программно, без обращения к пользователю - по их свойствам (тип примитива, слой и т. п.);</Li>
 <Li>извлечь из ГБД данные, относящиеся к этому примитиву (если использовался набор, то сначала следует извлечь имя примитива из набора - функция ssname, затем извлечь из ГБД данные, относящиеся к этому примитиву, - функция entget);</Li>
 <Li>средствами работы со списками AutoLISP модифицировать данные о примитиве в переменной - списке данных (функции assoc, subst);</Li>
 <Li>модифицировать саму ГБД: внести изменения в чертеж (функции entmod и entupd).</Li>
</Ul>

<P>Информацию о слоях, типах линий, видах, гарнитурах шрифтов, блоках, ПСК, размерных стилях и видовых экранах AutoCAD хранит в справочных таблицах. Для работы с ними в AutoCAD предусмотрены функции TBLNEXT и TBLSEARCH, которые просматривают таблицу и выдают содержащуюся в ней информацию. Содержимое таблиц изменять не разрешается.</P>

<pre><code> (tbinext имятаблицы [первый])</code></pre>

<P>Первым аргументом функции является строковая константа имени символьной таблицы. Допустимые имена таблиц - "LAYER", "LTYPE", "VIEW", "STYLE", "BLOCK", "UCS", "DIMSTYLE", "VPORT".</P>

<P>При повторном вхождении TBLNEXT возвращает следующее вхождение в указанную таблицу. Если аргумент первый присутствует и не равен nil, чтение таблицы начинается сначала. Если вхождений в таблицу нет, возвращается nil. Если вхождение найдено, возвращается список кодов и значений типа DXF. Точки входа, вызываемые из таблицы "BLOCK", содержат группу - 2 с именем первого элемента в описании блока. Это имя можно использовать только в функциях ENTGET и ENTNEXT, т. е. они программно не модифицируются:</P>

<pre><code> (tblsearch имятаблицы символ [следующий])</code></pre>

<P>Если аргумент следующий присутствует и не равен nil, точка входа TBLNEXT изменяется так, чтобы следующий вызов TBLNEXT возвращал точку входа, следующую за возвращенной.</P>

<P Class=h55>Пример:</P>

<pre><code> (tblnext "BLOCK")
 Возможный возврат:
 ((0 . "BLOCK")					;тип символа
 (2 . "BORDER")					;имя символа
 (70 . 0)						;флаги
 (10 . 9.7 2.0 0.0)				;X, Y, Z базовой точки
 (-2 . Имя примитива: 40000126)		;первый примитив
 )</code></pre>
<P>Как уже говорилось, имена примитивов действительны только в текущем сеансе редактирования. Однако в AutoLISP есть средство, позволяющее узнавать примитивы из других сеансов редактирования. Это средство называется меткой. Метки - это просто номер примитива в ГБД. Метки присваиваются примитивам автоматически в процессе создания (если были включены), и с ними можно работать из AutoLISP. Для этого в AutoLISP существует функция handent.</P>

<P Class=h5>(handent метка)</P>

<P>Возвращает имя примитива, который указывается строковым параметром метка. После того как получено имя примитива, оно может быть использовано для дальнейшей работы.</P>



<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>


<Table Border=0 CellPadding=0 CellSpacing=0>
<Tr><Td Bgcolor=#000000><Img Src=../../../оболочка/images/raspor.gif Height=2></Td>
<Tr><Td Valign=Center Height=30><span Class=h1>Функции доступа к примитивам AutoCAD</span></Td></Tr>
<Tr><Td Bgcolor=#000000><Img Src=../../../оболочка/images/raspor.gif Height=2></Td></Tr>
</Table></Center><Br>

<P>Рисунок в системе AutoCAD имеет организацию, аналогичную организации базы данных, в которой элементы (графические примитивы и неграфические объекты) имеют списковую структуру. Каждый примитив обладает своим типом. Перечислим все эти типы примитивов в алфавитном порядке:</P>

<P class="h5">
3DFACE 3DSOLID<br>
ACAD_PROXY_ENTITY ACAD_TABLE<br>
ARC<br>
ARCALIGNEDTEXT <br>
ARC_DIMENSION<br>
ATTDEF<br>
ATTRIB<br>
BODY<br>
CIRCLE<br>
DIMENSION<br>
ELLIPSE<br>
HATCH<br>
IMAGE<br>
INSERT<br>
LARGE_RADIAL_DIMENSION<br>
LEADER<br>
LINE<br>
LWPOLYLINE<br>

MLINE<br>
МТЕХТ<br>
OLE2FRAME <br>
POINT<br>
POLYLINE<br>
RAY<br>
REGION<br>
RTEXT<br>
SEQEND<br>
SHAPE <br>
SOLID <br>
SPLINE <br>
TEXT<br>
TOLERANCE<br>
TRACE<br>
VERTEX<br>
VIEWPORT<br>
WIPEOUT<br>
XLINE<br>
</P>

<P>Чаще всего наименование типа совпадает с английским именем команды системы AutoCAD, которая создает графический объект.</P>

<P>Функции, рассматриваемые в данном разделе, работают с примитивами рисунка, обращаясь непосредственно к их внутренней структуре. LISP имеет средства выбора графических объектов как по их порядковому номеру, так и по определенным признакам (цвету, слою и т. п.).</P>

<P class="h3">Функция entlast</P>

<P>Извлекает последний неудаленный основной примитив рисунка. Синтаксис функции:</P>

<pre><code> (entlast)</code></pre>

<P>Функция возвращает nil, если в рисунке нет неудаленных примитивов (например, когда вы только что создали новый рисунок). Иначе возвращается последний основной примитив В следующем виде:</P>

<p class="h5"><Entity name: 7ef 8bf 68> (<Имя объекта: 7ef8bf68>).</P>

<P>Фактически полученное имя примитива определяет адрес в базе данных рисунка, по которому начинается информация о примитиве.Полученное значение для дальнейшего использования следует сохранить в переменной, например:</P>

<pre><code> (setq eela (entlast))</code></pre>

<p class="h3">Функция entnext</P>

<P>Вычисляет следующий примитив (подпримитив).</P>

<pre><code> (entnext [<примитив>])</code></pre>

<P>В качестве единственного аргумента функции entnext может выступать ранее полученный примитив текущего рисунка. Если функция вызывается без аргумента, то она возвращает первый неудаленный примитив в базе рисунка.</P>

<P>При наличии аргумента функция возвращает следующий примитив либо nil, если в качестве аргумента указан последний примитив рисунка (т. е. последний графический объект базы рисунка).</P>

<p class="h55">Пример:</P>
<pre><code> (setq el (entnext))		возвращает первый неудаленный примитив рисунка
 (setq е2 (entnext el))		возвращает примитив, следующий за el
 (setq еЗ (entnext е2))		возвращает примитив, следующий за е2</code></pre>
<P>
Функция entlast возвращает последний основной примитив. Это означает, что если последним созданным графическим объектом рисунка является сложный объект (например, полилиния типа POLYLINE), то вслед за ним в базе рисунка следуют подпримитивы, т. е. вершины (имя примитива — VERTEX), а завершается перечисление подпримитивов полилинии примитивом SEQEND.</P><P>
Пример, приведенный в листинге 1.13, предполагает, что объект типа POLYLINE (полилиния или сеть) является последним основным примитивом.</P>
<pre><code> ; Выбираем последний примитив
 ; (в предположении, что им является POLYLINE)
 (setq eela (entlast))
 (setq v1 (entnext eela))
 ; v1 - примитив VERTEX, являющийся первой вершиной POLYLINE
 (setq v2 (entnext vl))
 ; v2 - примитив VERTEX, являющийся второй вершиной POLYLINE</code></pre>
<Br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=95%>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>

<Tr><Td Valign=ToP><P Class=pr>Замечание:&nbsp;&nbsp;</P></Td>
<Td Valign=Center><P Class=prt> В компактной полилинии (примитиве типа LWPOLYLINE) нет подпримитивов, и информация обо всех вершинах может быть извлечена из основного примитива.</P></Td></Tr>

<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<p class="h3">Функция entsel</P>
<P>Функция entsel предлагает пользователю указать один объект, выдавая запрос, текст которого задан в качестве аргумента.
</P>
<pre><code> (entsel [<запрос>])</code></pre>

<P>Аргумент <запрос> — любая строка текста.</P>

<P>Возвращаемое значение — список, состоящий из двух элементов: имени выбранного примитива и точки, которой пользователь указал объект (такая точка, как правило, оказывается вне самого примитива, поскольку точность указания мышью зависит от величины прицела). Можно задать объект вводом на клавиатуре ключевого слова <b>Last</b> (Последний) — тогда в возвращаемом списке координаты точки будут нулевыми.</P>
<p class="h55">Пример:</P>
<pre><code> (setq esl (entsel "Выберите объект: "))
 возвращает (<Entity name: 7ef66fa0> (475.13 248.759 0.0))</code></pre>
<P>Указанный пользователем объект фигурирует в качестве первого элемента списка, являющегося возвращаемым значением, и может быть извлечен из такого списка, например, с помощью функции car.</P>

<p class="h3">Функция entdel</P>
<P>Позволяет удалять неудаленные основные примитивы и восстанавливать примитивы, ранее удаленные в данном сеансе редактирования.
</P>
<pre><code> (entdel <примитив>)</code></pre>
<P>Функция возвращает имя удаляемого (восстанавливаемого) примитива. Следует иметь в виду, что при операции сохранения рисунка все примитивы, помеченные как удаленные, из рисунка стираются и уже больше не могут быть восстановлены.</P>
<p class="h55" Пример использования функции entdel
</P>
<pre><code> ; Строим отрезок для манипуляций
 (command "__.LINE" '(16.0 66.1) '(250.3 145.9) "")
 (setq kl (entdel (entlast)))
 ; Только что нарисованный отрезок удален (entdel kl)
 ; Удаленный примитив восстановлен</code></pre>

<p class="h3">Функция entget
</P>
<P>Получает список с характеристиками примитива и является основным инструментом извлечения информации о геометрии и свойствах.
</P>
<pre><code> (entget <примитив> [<приложения>])</code></pre>
<P>Здесь аргумент <примитив>— это имя примитива для получения его данных, аргумент <приложения> — это список с именами приложений, с помощью которых к примитиву привязаны расширенные данные (о расширенных данных см. разд. 1.14).</P>
<P>Предположим, в рисунке первым объектом является отрезок (тип примитива — LINE). Тогда выражение</P>
<pre><code> (setq le (entget (entnext)))
 должно вернуть примерно такой список:
 ((-1 . <Entity name: 7ef66fa0>> (0 . "LINE")  (330 . <Entity name: 7ef66cf8>) 
 (5 . "EC")  (100 . "AcDbEntity")  (67 . 0)  (410 . "Model")
 (8 . "О")  (100 . "AcDbLine")   (10 214.31 409.132 0.0)
 (11 608.276 172.218 0.0)   (210 0.0 0.0 1.0))</code></pre>
<P>
В этом списке элементами являются точечные пары и списки, причем и в тех и в других первыми элементами выступают целые числа, называемые DXF-кодами. Под соответствующим кодом в точечных парах и списках находятся данные определенного типа:</P>
<P>код 1 указывает имя примитива (<Entity name: 7ef66fa0>);<br>
код 0 — тип примитива ("line");<br>
код 5 — метку (внутренний номер примитива в рисунке);<br>
код 8 — имя слоя ("0");<br>
код 10 — координаты начальной точки (214.31 409.132 0. 0);<br>
код 11 — координаты конечной точки (608.276 172.218 0.0);<br>
код 210— направление вектора нормали к плоскости, в которой создан примитив;<br>
код 410 — имя вкладки пространства модели или листа.</P>
<P>Остальные коды, не имеющие принципиального значения, здесь не рассматриваются. С помощью функции assoc можно из списка с характеристиками объекта извлечь нужную точечную пару, а затем функцией cdr получить данные необходимого DXF-кода.</P>
 
<P>Продолжим пример с отрезком:</P>
<pre><code> (cdr (assoc 0 le)) возвращает "line" (тип примитива)
 (cdr (assoc 8 le)) возвращает "0" (имя слоя)
 (cdr (assoc 10 le)) возвращает (214.31 409.132 0.0)
 (cdr (assoc 11 le)) возвращает (608.276 172.218 0.0)</code></pre>
<P>
Кроме того, по коду 62 можно было бы извлечь номер цвета4 примитива, по коду 6 - имя типа линий, по коду 48 - собственный масштаб типа линий, по коду 311 - вес линий (умноженный на 100). В рассмотренном выше списке le точечных пар с такими DXF-кодами нет, поэтому для них действуют значения по умолчанию: ByLayer (ПоСлою) или 1.</P>
<P>Рассмотрим, какой примерный список можно было бы получить для окружности (примитива типа CIRCLE):
</P>
<pre><code> ((-1 . <Entity name: 7ef7c008>) (0 . "CIRCLE")
 (330 . <Entity name: 7ef66cf8>)  (5 . "F1")  (100 . "AcDbEntity")  (67 . 0) 
 (410 . "Model")  (8 . "0")  (100 . "AcDbCircle")  (10 1263.06 418.244 0.0) 
 (40 . 85.6843)   (210 0.0 0.0 1.0))</code></pre>
<P>Для окружности DXF-коды -1,0, 410, 8,210 имеют тот же смысл, что и для всех примитивов (в том числе и для примитива типа LINE). Под кодом 40 находится радиус окружности, а точечная пара с DXF-кодом 10 хранит в себе данные о центре.</P>
<P>Поэтому для рассматриваемой окружности:
</P>
<pre><code> (cdr (assoc 40 le)) возвращает85.6843 (радиус)
 (cdr (assoc 10 le)) возвращает (1263.06 418.244 0.0) (точка центра)</code></Pre>
<P>Сравнивая справочную информацию, выдаваемую командой LIST (СПИСОК), и список, выводимый функцией entget, можно получить геометрический смысл DXF-кодов для примитивов других типов.
</P>

<p class="h3">Функция entmake
</P>
<P>Создает новый примитив по списку, структура которого аналогична структуре списка, возвращаемого функцией entget. Возможно построение примитива с расширенными данными. Функция entmake не может создать примитив типа VIEWPORT, но применима к объектам символьных таблиц .</P>
<pre><code>(entmake <список>)</code></Pre>
<P>При использовании полной палитры цветов DXF-код 420 содержит значение цвета, а DXF-код 430 — имя из альбома цветов. Аргумент <список> — это список, описывающий примитив (кроме точечной пары с DXF-кодом -1). По такому списку можно воссоздать в рисунке примитив с помощью функции entmake.</P>
<P>Возвращаемое значение — аргумент <список> или nil, если создание объекта невозможно.
</P><p class="h55">Пример:</P>
<pre><code> (entmake '((0 . "CIRCLE") (10 500.0 0.0 0.0) (40 . 50.0)))</code></pre>
<P>
создает новый примитив— окружность с центром в точке (500 0 0) и радиусом 50; остальные свойства (слой, цвет и т. д.), данные о которых отсутствуют в списке, берутся по умолчанию; возвращаемое значение— ((о . "circle") (10 500.0
0.0 0.0)  (40 . 50.0))<br>
</P>
<pre><code>
 (entmake  '((0   .   "LAYER")   (100 . "AcDbSymbolTableRecord")
 (100  .  "AcDbLayerTableRecord")   (2  .   "MyNew")   (70 . 0)   (62 . 1)
 (6 . "Continuous")))</code></pre>
 <P>
 создает новый объект в таблице слоев — слой с наименованием MyNew, цветом 1 и типом линий CONTINUOUS
</P>

<p class="h3">Функция entmakex
</P><P>Создает новый примитив или неграфический объект по списку с данными, аналогично функции entmake. Является основным инструментом создания словарей и Х-записей.</P>
<pre><code> (entmakex <список>)</code></pre>
<P>Возвращаемое значение— новый примитив или nil, если создание объекта невозможно.
</P><p class="h55">Пример:
</P>
<pre><code> (entmakex '((0 . "CIRCLE") (10 500.0 0.0 0.0) (40 . 50.0) )) создает новый примитив — окружность с центром в точке (500 0 0) и радиусом 50.</code></pre>

<p class="h3">Функция entmod
</P>
<P>Функция entmod похожа на функцию entmake, но получает в качестве аргумента список, который содержит точечную пару с DXF-кодом -1 (т. е. существующий в рисунке примитив) и модифицирует примитив в соответствии с новым списком (в списке могут изменяться любые данные, кроме имени примитива, типа примитива и метки, т. е. точечных пар с кодами -1,0 и 5):</P>

<P>Функция entmod изменяет примитив в базе рисунка и возвращает значение аргумента <список> при успешном завершении или nil — при невозможности выполнить изменение. Данная функция не работает с примитивом VIEWPORT.</P>

<P>В листинге на примере отрезка с цветом ByLayer (ПоСлою) показан метод изменения примитива с помощью функции entmod.
</P>
<p class="h55"> Пример использования функции entmod
</P>
<pre><code> ; Выбираем отрезок с цветом ByLayer (ПоСлою)
 (setq le (car (entsel)))
 ; Для отрезка возвращается список примерно такого вида: ; ((-1 . <Entity name: 7ef66fa0>)  (0 . "LINE")
 ;  (330 . <Entity name: 7ef66cf8>)  (5 . "EC")   (100 . "AcDbEntity")
 (67  . 0)   (410 . "Model")  (8 . "0")  (100 . "AcDbLine")
 ;  (10 214.31 409.132 0.0)   (11 608.276 172.218 0.0)   (210 0.0 0.0 1.0))
 ; В списке нет точечной пары с DXF-кодом 62
 ;  (это означает, что цвет имеет значение ByLayer (ПоСлою))
 (setq le (append le (list (cons 62 1))))
 ; К списку добавлена точечная пара для красного цвета
 (entmod le)
 ; Цвет отрезка изменился на красный</code></pre>
<P>
Если бы в данном примере список с данными отрезка уже содержал точечную пару с DXF-кодом 62, то изменение цвета пришлось бы выполнить заменой значения, например:</P>
<pre><code> (setq le (subst (cons 62 5)  (assoc 62 le) le)) возвращает СПИСОК, В котором
 точечная пара цвета заменена на точечную пару с синим цветом (номер 5)
 (entmod le) изменяет цвет отрезка на синий</code></pre>

<p class="h3">Функция entupd
</P>
<P>Перерисовывает примитив на экране с учетом изменений, внесенных, например, функцией entmod.
<pre><code> (entupd <примитив>)</code></pre>
<P>Аргумент <примитив> — это имя примитива в том виде, в котором оно выводится, например, функцией entlast.
Возвращаемое значение — имя примитива или nil (при ошибке). Пример:</P>
<pre><code> (entupd (entlast)) перерисовывает последний примитив</code></pre>

<p class="h3">Функция handent</P>
<P>Получает имя примитива или неграфического объекта по его метке, (handent <метка>)
</P><P>Аргумент <метка>— это текстовая строка с шестнадцатеричной меткой в том виде, в каком она возвращается функцией entget.
Возвращаемое значение — имя примитива или nil (при ошибке). Пример:</P>
<pre><code> (handent (cdr (assoc 5 le)))  возвращает примитив по данным его метки (le — список с данными примитива)</code></pre>

<p class="h3">Функция nentsel
</P>
<P>Запрашивает объект и для простого примитива возвращает такой же список из имени примитива и точки указания, как и функция entsel. Однако если указанный пользователем примитив является трехмерной полилинией (POLYLINE), то первым элементом возвращаемого списка будет имя подпримитива начальной вершины (VERTEX) участка, на котором указывалась полилиния. Если указанный пользователем объект является вхождением блока (INSERT), то возвращается список из двух или четырех элементов (см. ниже).</P>
<pre><code> (nentsel [<запрос>])</code></pre>
<P>Аргумент <запрос>— строка. Если аргумент не задан, то в качестве подсказки выводится стандартный запрос: <b>Select object: </b>(Выберите объект:).
Функция nentsel работает с блоками (примитивами типа INSERT) следующим образом. В случае если пользователь указал атрибут блока, то функция возвращает список из двух элементов: первым является имя объекта-атрибута, а вторым — точка указания атрибута. В случае если пользователь указал не атрибут, а объект, принадлежащий вхождению блока, то возвращается список из четырех элементов: первым является примитив, с помощью которого был указан блок, вторым — точка указания, третьим — матрица размером 4x3 для преобразования точек из системы координат объекта (СКО) в МСК, четвертым — список с именем блока, содержащим указанный примитив (если примитив входит в блок, который вложен в другой блок, то список содержит все имена вкладываемых блоков, начиная от самого внутреннего и кончая самым внешним).</P>
<P>Матрица размером 4x3, которая выдается в качестве третьего элемента возвращаемого функцией nentsel значения, имеет вид: ((m00 m01 m02) (ml0 m11 m12» (m20 m21 m22) (m30 m31 m32)). Тогда преобразование точек из СКО в МСК идет по системе уравнений:</P>
<P>X' = X*m00 + Y*m10 + Z*m20 + m30<br>
У' = Х*m01 + Y*m11 + Z*m21 + m31<br>
Z' = Х*m02 + Y*m12 + Z*m22 + m32</P>
<P>Здесь (X Y Z) — координаты точки до преобразования, (X' Y' Z') — координаты точки после преобразования.</P> 
<p class="h55">Пример:
</P><p class="h5">(nentsel "Укажи блок: ") возвращает для блока (<Entity name: 7ef7c068> (1179.16 400.02 0.0)   ((1.0 0.0 0.0)   (0.0 1.0 0.0)   (0.0 0.0 1.0) (1230.23 403.664 0.0))   (<Entity name: 7ef7c070>))
</P>

<p class="h3">Функция nentselp
</P>
<P>Функция nentselp аналогична функции nentsel, но если указанным примитивом является вхождение блока (INSERT), то возвращает список, в котором третьим элементом является матрица преобразования размером не 4x3, а 4x4 (см. ниже), (nentselp [запрос]  [<точка>])</P>
<P>Если задан аргумент <точка>, то запрос не выдается и аргумент выступает в качестве точки указания.
</P>
<P>Функция nentselp работает аналогично функции nentsel, но в случае если пользователь указал объект, принадлежащий вхождению блока, то, как и nentsel, тоже возвращается список из четырех элементов, однако третьим элементом в списке является матрица размером 4x4, которая служит для преобразования точек из системы координат объекта (СКО) в МСК. Матрица имеет вид: ((n00 n01 n02 n03) (n10 n11 n12 n13) (n20 n21 n22 n23) (0.0 0.0 0.0 1.0)). Преобразование точек из СКО в МСК идет по такой системе уравнений:</P>
<P>X' = Х*n00 + Y*n01 + Z*n02 + n03 <br>
Y' = Х*n10 + Y*n11 + Z*n12 + n13 <br>
Z' = X*n20 + Y*n21 + Z*n22 + n23</P>
<P>Смысл списков (х y z) и (X' Y' Z') тот же, что и для функции nentsel. 
</P>
<p class="h55">Пример:
<pre><code> (nentselp "Укажи блок: ") возвращает для блока (<Entity name: 7ef7c068> (1180.99 445.58 0.0)   ((1.00.0 0.0 1230.23)   (0.0 1.0 0.0 403.664) (0.0 0.0 1.0 0.0)   (0.0 0.0 0.0 1.0))   (<Entity name: 7ef7c070>))</code></pre>


<p class="h3">Наборы
</P>
<P>Следующая группа функций — это функции, работающие с наборами объектов. Набор — это временное множество, в которое входят имена основных примитивов рисунка (они собираются по какому-то условию или признаку-фильтру). Неосновные примитивы (составные части блока или вершины полилинии) не могут входить в набор.
Имя набора обычно сохраняется в какой-нибудь переменной, чтобы затем можно было извлечь из набора нужные примитивы для анализа или операций редактирования.</P>
<P>Наборы уничтожаются при закрытии рисунка.
</P>



<Table Border=0 CellPadding=0 CellSpacing=0 Width=95%>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>

<Tr><Td Valign=ToP><P Class=pr>Замечание:&nbsp;&nbsp;</P></Td>
<Td Valign=Center><P Class=prt> При необходимости сохранять наборы примитивов в рисунке следует оформлять их в виде групп с помощью команды GROUP (ГРУППА). Группы относятся к неграфическим объектам, существующим внутри рисунка.</P></Td></Tr>

<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<P>Количество одновременно открытых наборов в рисунке не должно превышать 128. В ранних версиях системы AutoCAD количество наборов, которые могут быть одновременно открыты, было меньше (например, в 10-й версии оно равнялось всего шести).</P>
<P>Для того чтобы закрыть ненужный набор, переменной, в которой хранится имя этого набора, следует присвоить значение nil.</P>

<p class="h3">Функция ssget
</P>
<P>Функция ssget формирует набор по запросу или признаку,
<pre><code> (ssget [<метод>] [<точка1> [<точка2>]]  [<список>]  [<фильтр>])</code></pre>
Аргумент <метод> — это текстовая строка, принимающая одно из значений, характеризующих метод выбора примитивов (для возможности использования и в локализованной версии системы AutoCAD все перечисляемые строки должны спереди дополняться символом подчеркивания).</P>
<P>К основным значениям относятся следующие:
</P>
<P>"X" — выбор всех примитивов рисунка, включая объекты на замороженных слоях и вне видимой части экрана, с учетом возможного аргумента <фильтр>;<br>
"A" — выбор всех примитивов рисунка, включая объекты на замороженных слоях и вне видимой части экрана;<br>
"I" — текущий набор из объектов, отмеченных с помощью ручек;<br>
"Р" — последний сформированный ранее набор;<br>
"W" — выбор рамкой;<br>
"WP" — выбор многоугольником;<br>
"С" — выбор секущей рамкой;<br>
"CP" — выбор секущим многоугольником;<br>
"F" — выбор секущей линией;<br>
"L" — выбор последнего видимого примитива.</P>
<P>Дополнительные значения (как правило, являются установками каких-то особенностей выбора):
</P>
<P>":D" — разрешение на повторное включение примитивов в набор;<br>

":A" — отмена разрешения на повторное включение примитивов в набор;<br>

":E" — разрешение на выбор всех примитивов, попадающих в прицел устройства указания;<br>

":L" — запрещение выбора примитивов на блокированных слоях;<br>

":N" — разрешение на выбор основных примитивов с помощью подпримитивов (сегментов подробной полилинии или сети , компонентов блока); используется только при графическом варианте выбора и только для указания рамкой, секущей рамкой и точкой; может привести к повторению примитивов в наборе, поскольку, например, можно отметить одну и ту же подробную полилинию с помощью любого из ее участков (см. также функцию ssnamex);<br>
":S"— допускает только один интерактивный выбор (по умолчанию возможен многошаговый выбор примитивов).</P>
<P>Функция располагает и другими недокументированными возможностями, наследуемыми от соответствующих функций ObjectARX (например, "M", ".", "#" , ":O",
":?",":$", Комбинирование режимов типа " :D:E" и т. д.).</P>
<P>Аргумент <точка1> при отсутствии аргумента <точка2> определяет дополнительное условие для добавления в набор: включаемый примитив должен проходить через точку, заданную аргументом <точка1>. Если заданы оба аргумента <точка1> и <точка2>, то определяемые ими точки являются углами простой или секущей рамки (когда в качестве метода выбора применяются рамки, т. е. "W" или "С").</P>
<P>Аргумент <список> представляет собой список, элементами которого являются точки, используемые в методах "F", "WP", "CP".
</P><P>Аргумент <фильтр> — это список со структурой, аналогичной структуре списка, возвращаемого функцией entget, что позволяет оставить только те примитивы, которые удовлетворяют дополнительным признакам (например, определенному цвету, слою, весу и т. д.).</P>
<P>Возвращаемое значение функции ssget — имя созданного набора (или nil, если создать набор невозможно). Имя набора возвращается в следующем виде:
</P><p class="h5">
  <Selection set: 2></P>
<P>Фактически имя набора — это адрес в базе данных рисунка, по которому начинается информация об объектах, включенных в набор.
</P><p class="h55">Примеры:</P>
<pre><code> (ssget) выдает стандартный запрос Select objects: (Выберите объекты:) и затем создает набор в соответствии с интерактивными действиями пользователя
 (ssget "_:S") аналогичен предыдущему варианту, но разрешает сделать только один выбор
 (ssget '(125.4 58.1)) создает набор из всех примитивов, проходящих через
 точку (125.4 58.1)
 (ssget "_X" '(125.4 58.1)) выдает сообщение об ошибке (несовместимость режимов)
 (ssget '(125.4 58.1) '((0 . "POLYLINE" ))) создает набор из всех примитивов типа POLYLINE, проходящих через точку (125.4 58.1)
 (ssget "_С" '(14.3 -5.2) '(27.6 106.1)) создает набор из примитивов, выбираемых секущей рамкой с углами в точках (14.3 -5.2) И (27.6 106.1)
 (ssget "_F" '((l.0 0.0) (2.0 1.0) (10.0 1.0) (12.0 0.0))) создает набор из примитивов, пересекаемых ломаной линией, имеющей четыре вершины
 (ssget "_X" (list (cons 0 "LWPOLYLINE") (cons 8 "SET"))) создает набор из всех примитивов типа LWPOLYLINE, размещенных на слое SET
 (ssget   "_X"   '((0   .   "LWPOLYLINE")    (8   .   "SET, ACR,BELL") ) )  создает набор из
 всех примитивов типа LWPOLYLINE, размещенных на слоях SET, ACR и BELL
 (ssget "_X" ' ((0 . "*LINE") )) создает набор из всех примитивов рисунка, являющихся объектами типа *LINE (т.е. LINE, SPLINE, POLYLINE, LWPOLYLINE)
 (ssget "_X" ' ((8 . "СТЕНА[1-3]"))) создает набор из всех примитивов рисунка на слоях СТЕНА 1, СТЕНА2, СТЕНАЗ
 (ssget "_A") создает набор из всех примитивов рисунка, аналогично методу
 "_Х" С пустым фильтром, Т. е. (ssget "_Х"), (ssget "_Х"  '()) ИЛИ (ssget "_Х" nil)</code></pre>
<P>
В рисунке одновременно может быть открыто не более 128 наборов. При достижении такого предела функция ssget отказывается создавать следующие наборы и возвращает для них nil. Чтобы удалить ненужные наборы, следует присвоить значение nil переменным, хранящим имена этих наборов.
Из примеров видно, что в фильтрах со строковыми значениями можно использовать те же возможности, что и в функции wcmatch (т. е. применять символы *, #, @, ?, [,] и т. д.).</P>


<p class="h3">Фильтры со сложными условиями
</P>
<P>Для формирования <b>сложных условий</b> в фильтрах выбора применяются точечные пары со служебным DXF-кодом —4. В них используются следующие аналоги логических операторов: AND, OR, XOR, NOT. Каждый из этих операторов имеет два вида: открывающей скобки и закрывающей скобки, например: " 100, У> 230, Z любые (обратите внимание на комбинацию ">,>,*", используемую для трехкоординатного DXF-кода)
При проверке значения DXF-кода 210 (вектор нормали) применимы только операторы *, =, !=, /=, <>.</P>


<p class="h3">Функция ssadd
</P>
<P>Добавляет примитив в набор.
<pre><code> (ssadd [<примитив> [<набор>]])</code></pre>
<P>Аргументы: <примитив> — примитив, <набор> — набор. Возвращаемое значение — набор.
Если аргумент <набор> опущен, а аргумент <примитив> задан, то создается новый набор из одного примитива. Если оба аргумента опущены, то создается новый пустой набор (но его значение не равно nil).</P>
<P>Пример работы с функцией ssadd.
</P>
<pre><code> ; Строим вспомогательный отрезок
 (command "_.LINE"  '(14.0 79.2)   '(35.1 81.3)  "")
 (setq ssl (ssadd)); создает пустой набор
 (ssadd (entlast) ssl)
 ; В набор ssl добавлен последний примитив (типа LINE) </code></pre>

<p class="h3">Функция ssdel
</P>
<P>Удаляет примитив из набора,
<pre><code> (ssdel <примитив> <набор>)</code></pre>
</P>
<P>Аргументы: <примитив> — удаляемый примитив, <набор> — набор, из которого нужно выполнить удаление.
Возвращаемое значение— набор, если операция удаления выполнена, или nil, если примитив не содержится в наборе и удалить его нельзя.</P>
<p class="h55">Пример:
</P>
<pre><code> (ssdel (entlast) ssl) удаляет из набора ssl последний примитив (типа LINE) И возвращает <Selection set: 4></code></pre>

<p class="h3">Функция sslength
</P>
<P>Вычисляет длину набора, т. е. количество содержащихся в нем примитивов,
<pre><code> (sslength <набор>)</code></pre>
</P>
<P>Аргумент <набор> — набор. Возвращаемое значение — целое число.<Br>Примеры:</P>
<pre><code> (sslength (ssadd)) возвращает 0, т. к. функция ssadd создала пустой набор
 (sslength (ssget "_L")) возвращает 1, т.к. функция ssget создала набор из одного примитива (последнего видимого примитива рисунка)</code></pre>

<p class="h3">Функция ssmemb</P>
<P>Проверяет, входит ли примитив в набор,
<pre><code> (ssmemb <примитив> <набор>)</code></pre>
</P><P>Аргументы: <примитив> — примитив, <набор>— набор.</P>
<P>Возвращается примитив (значение аргумента <примитив>), если он входит в рассматриваемый набор, или nil — если не входит.
</P>
<p class="h55">Примеры:</P>
<pre><code> (setq nabor (ssget "_L")) создает набор из последнего примитива и возвращает <Selection set: 7>
 (ssmemb   (entlast)   nabor) возвращает примитив (например, <Entity name: 7ef7cOio>), т. к. последний примитив содержится в наборе nabor </code></pre>

<p class="h3">Функция ssname</P>
<P>Извлекает примитив из набора по порядковому номеру,
<pre><code> (ssname <набор> <номер>)</code></pre>
</P>
<P>Аргумент <набор> — набор. Аргумент <номер> определяет номер элемента в наборе. Значение должно быть либо целым числом от 0 до 32767, либо целым числом в вещественной форме больше 32767.0. Нумерация примитивов в наборе начинается с нуля.</P>
<P>Возвращаемое значение — примитив или nil, если примитива с данным номером в наборе нет.
</P><p class="h55">Примеры:</P>
<pre><code> (ssname   nabor   0)  возвращает  ИМЯ  примитива (например,  <Entity   name: 7ef7c010>)
 (ssname nabor 1) возвращает nil, т. к. в наборе nabor содержится только один объект</code></pre>

<p class="h3">Функция ssnamex
</P>
<P>Извлекает примитив из набора по порядковому номеру (заданных соответствующими аргументами <набор> и <номер>), но при этом выдается дополнительная информация о методах формирования набора (см. ниже). Если аргумент <номер> опущен, то выводится информация обо всех примитивах набора.</P>
<pre><code> (ssnamex <набор> [<номер>])</code></pre>
<P>Типы аргументов — как у функции ssname.
</P>
<P>Функция ssnamex возвращает список, в котором элементами являются описания способа выбора примитивов, попавших в набор. Если аргумент <номер> не задан, то длина возвращаемого списка равна количеству элементов, определяемых аргументом <набор>. Если аргумент <номер> задан, причем корректно, то возвращаемым значением будет список из одного элемента— описания способа выбора примитива с порядковым номером, равным значению аргумента <номер>. Если же аргумент <номер> задан неправильно, то функция ssnamex вернет nil. Описание способа выбора примитива— это список из трех элементов: (<метод> <примитив> <данные>). Параметр <метод>— целое число, которое соответствует методу выбора функции ssget и может принимать такие значения:</P>
<P>0 — не интерактивный выбор ("L", "A", "X" и т. п.);<br>
1 — выбор указанием точки;<br>
2 — "W" или "WP";<br>
3 — "с" или "CP";<br>
4 — "F".</P>
<P>Если на месте параметра <метод> стоит отрицательное число, то оно определяет многоугольник выбора (см. описание многоугольника ниже).
Параметр <примитив> описания способа выбора примитива является его именем в том виде, в котором оно выводится функцией entlast. Параметр <данные> может быть либо только числом 0, либо числом 0 и списком, уточняющим выбор, либо числом 0 и номером многоугольника. В уточняющем списке может быть точка.
с помощью которой выбран объект. Если использован номер многоугольника (а он должен быть отрицательным: -1, -2 и т. п.), то далее будет следовать описание многоугольника с соответствующим номером.</P>
<P>Описание многоугольника— это список такого вида: (<номер_многоугольника> <точка1> ... <точкаN>). Нумерация многоугольников начинается с -1 и изменяется путем добавления -1 к очередному номеру.
Описание точки (<точка1> и т. п.) — это список из трех (или двух) элементов: (<код> <база> [<вектор>]). Описание точки зависит от вида, на котором она выбиралась, и фактически представляет собой описание прямой, луча или отрезка. Параметр <код> является кодом описания точки (0 — прямая, 1 —луч, 2 — отрезок), параметр <база> представляет собой начальную точку описания, а необязательный параметр <вектор> — это либо направление, в котором продолжается бесконечная линия (прямая или луч), либо смещение в сторону, характерную для отрезка.</P>
<P>Например, если в набор nab5 включен один объект, который был указан точкой
(7.51 16.02) на обычном виде сверху В МСК, то выражение (ssnamex nab5 0) возвращает нечто похожее на ((1 <Entity name: 7ef7dal0> 0 (0 (7.51 16.02 0.0)))).
В этом примере возвращенный функцией ssnamex список состоит из одного элемента (списка), в котором присутствуют следующие составные части:</P>
<P><метод> — равен 1 (соответствует выбору указанием точки);<br>
<примитив> — <Entity name: 7ef7dal0>;<br>
<данные> — 0  (0 (7.51 16.02 0.0)), что соответствует точке (7.51 16.02 0.0),
примененной для выбора примитива.</P> 
<P>Другие примеры значений, возвращаемых функцией ssnamex:<br>

<p class="h5">((о <Entity name: 7ef7daio> 0)) — один примитив, выбранный неинтерактивным методом (например, "L");<br>

((3 <Entity name: 14ае568> 0 -1) (3 <Entity name: 14ае578> 0 -1) (-1 (0 (-147.787   129.133  0.0))    (0   (-64.2728   129.133  0.0))    (0   (-64.2728  22.3376
0.0)) (0 (-147.787 22.3376 0.0))))  — два примитива, выбранных секущим прямоугольником с номером -1 (для прямоугольника заданы четыре точки);<br>

((1 <Entity name: 14ае560> 0 (0 (74.2672 64.8218 0.0))) (2 <Entity name: 14ае570> 0 -1) (2 <Entity name: 14ае568> 0 -1) (-1 (0 (-177.446 158.755 0.0))    (0   (40.3151   158.755   0.0))    (0   (40.3151  83.1407  0.0))    (0   (-177.446
83.1407 0.0))))— три примитива, первый из которых выбран указанием с помощью точки (74.2672 64.8218 0.0), а второй и третий выбраны рамкой, которая фигурирует как многоугольник с номером -1.</P>
<P>В этих примерах параметр <вектор> описания точек нигде не использован, т. е. объекты выбирались на виде сверху в МСК.
Наборы— удобный инструмент для выбора нужных примитивов рисунка с заданными свойствами. После формирования набора с помощью функции ssname (или ssnamex) из него извлекаются объекты, с которыми далее выполняются необходимые операции (например: удаление, модификация и т. д.).</P>

<p class="h3">Функция sssetfirst
</P>
<P>Включает ручки у примитивов, входящих в наборы, заданные аргументами <набop1> и <набор2>, и подсвечивает пунктиром примитивы из набора, заданного аргументом <набор2> (что означает выбор их для следующей операции редактирования).</P>
<pre><code> (sssetfirst <набор1> [<набор2>])</code></pre>
<P>Аргументы — наборы или nil. В качестве первого аргумента в версиях 2004 — 2006 рекомендуется давать nil (см. примечание далее).
Возвращаемое значение — список с двумя наборами, переданными в качестве аргументов.</P>

<p class="h55">Пример использования функции sssetfirst
</P>
<pre><code> ; Строим вспомогательный отрезок 
 (command "_.LINE" '(276.5 42.0)   '(90.3 71.8)  "")
 (setq ssl (ssadd (entlast)))
 ; Создан набор ssl из одного отрезка
 ;Строим вспомогательную окружность
 (command "_.CIRCLE" '(180.0 93.0) 72.0)
 (setq ss2 (ssadd (entlast))) ;
 Создан набор ss2 из одной окружности
 (sssetfirst ssl ss2); Возвращает (<Selection set: 6> <Selection set: 8>)
 ; Включает ручки и подсвечивает окружность (sssetfirst nil ss2); тот же результат</code></pre>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=95%>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Br>
<Tr><Td Valign=ToP><P Class=pr>Замечание:&nbsp;&nbsp;</P></Td>
<Td Valign=Center><P Class=prt> До версии 2002 в этом примере AutoCAD включал ручки и у отрезка (без подсветки). Но начиная с версии 2004 с первым набором ничего не происходит. Поэтому имеет смысл в качестве первого аргумента функции essetfirst использовать только nil, если другого ив требует последующий вызов функции ssget first.</P></Td></Tr>

<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<p class="h3">Функция ssgetfirst
</P>
<P>Возвращает список с именами двух наборов, аналогичных по назначению аргументам <наОор1> и <наоор2> функции sssetfirst (в текущий момент у примитивов второго набора включены ручки и подсвечивание).</P>
<pre><code> (ssgetfirst)</code></pre>

<p class="h3">Пример работы с примитивами AutoCAD
</P>
<P>При создании прикладного программного обеспечения часто приходится работать с примитивами рисунка, из которых нужно извлекать данные, изменять их и передавать для дальнейшего использования. Самая распространенная схема получения доступа к графическим объектам такова.
</P><P>В качестве средств интерактивного выбора примитивов используются функции entsel или ssget. При необходимости сканирования рисунка для поиска в нем по определенному свойству (имени слоя, цвету и т. п.) выбор примитивов осуществляется с помощью функции ssget.</P>
<P>Функция entsel возвращает список, первым элементом которого является указанный пользователем примитив. Этот примитив может быть извлечен из списка с помощью функций car или nth.</P>
<P>Функция ssget возвращает имя набора, состоящего из некоторого количества имен примитивов (при неудачном выборе вместо имени набора может быть возвращено значение nil). Длина набора оценивается с помощью функции sslength, а извлечение из него нужного элемента выполняется функцией ssname.
</P><P>Далее к полученному примитиву применяется функция entget, которая возвращает список с набором точечных пар, содержащих характеристики рассматриваемого примитива. Затем с помощью функций assoc и cdr из этого списка читаются нужные свойства примитива.</P>
<P>Проиллюстрируем приведенную схему следующим примером. Предположим, что в рисунке детали на слое HOLES находятся отверстия (круги), построенные с помощью команды CIRCLE (КРУГ)- Необходимо прочитать все эти круги и сформировать два списка, в первом из которых собрать радиусы кругов, а во втором — точки с координатами центров. </P>
<p class="h55">Пример работы с примитивами рисунка</P>
<pre><code> ; Начальные значения списков радиусов (list_rad) и центров (list__cen)
 (setq list_rad  ‘() list_cen  ‘ ())
 ; Создание набора из кругов на слое HOLES
 (setq nab_cir (ssget "_X" (list (cons 8 "HOLES")   (cons 0 "CIRCLE"))))
 ; Проверка, сформировался ли набор nab_cir
 ; (если нет, то предыдущая операция вернет nil)
 (if (null nab_cir)
  
 (progn
 (princ "\nНет кругов на слое HOLES. "); сообщение об отсутствии
 (princ); тихий выход ); конец progn 
 (progn
 (setq i -1 nab_len (sslength nab_cir))

 ; Цикл по количеству элементов набора nab__cir 
 (repeat nab_len 
 (setq i (1+ i))
 ; Выбор следующего примитива и получение его списка
 (setq cirlist (entget (ssname nab_cir i)))
 (setq radcir (cdr (assoc 40 cirlist)))
 (setq cencir (cdr (assoc 10 cirlist)))
 ; Добавление радиуса и точки центра к спискам list_rad и list_cen
 (setq list_rad (append list_rad (list radcir)))
 (setq list_cen (append list_cen (list cencir)))
 ; конец repeat 

 ; Печать результирующих списков
 (princ "\nРадиусы: “)
 (princ list_rad)
 (princ "\nЦентры: ")
 (princ list_cen)
 ); конец prong
 ); конец if</code></pre>

<P>Программу следует сохранить (например, в файле D:\Temp\rcl.lsp), после чего ее можно загрузить в память:
(load "D:\\Temp\\rcl.lsp")</P>
<P>Если файл загрузится без ошибок, то система AutoCAD его сразу выполнит.
</P><P>Разберем схему работы программы. Для того чтобы выбрать из рисунка все круги на слое HOLES, используется функция ssget с фильтром по имени слоя и типу примитива: (ssget "_Х" (list (cons 8 "HOLES") (cons 0 "circle") )). Результат (набор) запоминается в переменной nab_cir.</P>
<P>Количество объектов, попавших в набор nab_cir, вычисляется с помощью выражения (ssiengtn nab_cir). Затем с помощью функции ssname поочередно получаются примитивы, включенные в набор: выражение (ssname nab_cir i) для разных i возвращает примитив с номером i-1.</P>
<P>Далее формируется список с характеристиками очередного объекта-круга с помощью выражения (entget (ssname nab_cir i)). После этого остается только извлечь с помощью функций cdr и assoc значения радиуса (DXF-код 40) и центра (DXF-код 10). Извлекаемые значения заносятся в результирующие списки list_rad И list_cen.</P>
<P>Возможный вид результата работы программы:<br>

Радиусы:  (66.0916 29.1292)<br>
Центры:  ((179.603 194.961 0.0)   (43.0525 184.539 0.0))((179.603 194.961 0.0) (43.0525 184.539 0.0))<br>
</P>

<p class="h3">Функции доступа к табличным данным
</P>
<P>Помимо примитивов в рисунке всегда присутствует определенный объем неграфической информации: описания блоков, таблицы слоев, таблицы видовых экранов, таблицы типов линий, таблицы размерных стилей и т. п. Все они хранятся в базе рисунка примерно в том же виде, что и примитивы.</P>
<p class="h3">Символьные таблицы
</P>
<P>Табличные данные основных неграфических объектов рисунка сгруппированы в символьные таблицы, имеющие следующие имена:
</P><P>BLOCK — таблица описаний блоков;<br>
LAYER — таблица слоев;<br>
LTYPE — таблица типов линий;<br>
STYLE — таблица текстовых стилей;<br>
DIMSTYLE — таблица размерных стилей;<br>
UCS — таблица именованных систем координат;<br>
VIEW — таблица именованных видов;<br>
VPORT — таблица конфигураций видовых экранов;<br>
APPID — таблица имен приложений, с которыми связываются расширенные данные (о расширенных данных см. разд. 1.14).
</P>
<P>В этих таблицах находятся соответствующие табличные объекты, внутренняя организация которых аналогична организации графических примитивов, а методы доступа похожи на методы доступа к графическим примитивам. В перечне присутствуют текстовые и размерные стили. Следует обратить внимание на то, что для стилей мультилиний и стилей таблиц (как графических примитивов) применено другое средство хранения данных — словари.
Название символьные таблицы введено разработчиком системы, оно не связано с примитивом ACADTABLE (таблица), а определяется именем используемого класса: AcDbSymbolTable.</P>
<P>Ниже рассматриваются функции языка LISP, осуществляющие доступ к объектам символьных таблиц.</P>

<p class="h3">Функция tblsearch
</P>
<P>Получает список с характеристиками объекта таблицы по его заголовку,
<pre><code> (tblsearch <таблица> <заголовок> [<следующий>])</code></pre>
</P>
<P>Аргументы: <таблица> — текстовая строка с именем таблицы, <заголовок> — текстовая строка с именем элемента таблицы, <следующий> — любое значение (важно только, nil или не nil).</P>
<P>Возвращаемое значение— список, соответствующий найденному объекту (или nil, если объект не обнаружен).
</P>
<P>Если параметр <следующий> задан и не равен nil, то указатель функции tblnext устанавливается на объект таблицы с данным заголовком (следующее обращение к функции tblnext вернет данные об объекте, расположенном в таблице после объекта, использованного в качестве аргумента в функции tblsearch).<Br>Примеры:</P>
<pre><code> (tblsearch "LAYER" "0") возвращает ((0 .  "LAYER")   (2 . "0")   (70 . 0) (62 . 7)   (6 . "Continuous"))
 (tblsearch "LTYPE" "CONTINUOUS") возвращает ((0 . "LTYPE")
 (2 . "Continuous")   (70 .0)   (3 . "Solid line")   (72 - 65)   (73 . 0) (40 . 0.0))
 (tblsearch "STYLE" "STANDARD") возвращает ((0 .  "STYLE") (2 . "Standard")   (70 . 0)   (40 . 0.0)   (41 . 1.0)   (50 . 0.0) (71 . 0)   (42 . 2.5)   (3 . "txt")   (4 . ""))</code></pre>


<p class="h3">Функция tblnext
</P>
<P>Читает характеристики очередного объекта из таблицы,
<pre><code> (tblnext <таблица> [<признак>])</code></pre>
</P>
<P>Аргументы: <I>таблица</I> — текстовая строка с именем таблицы. <I>признак</I> — любое значение (признак первого элемента таблицы — см. ниже).
Возвращаемое значение — список с характеристиками элемента таблицы или nil.</P>

<P>Если параметр <I>признак</I> задан и отличен от nil, то функция возвращает данные первого элемента таблицы (иначе возвращаются данные объекта, следующего за тем, который был прочитан в предыдущем обращении функции tblnext к той же таблице или в предыдущем обращении к функции tblsearch, вызванной с аргументом <I>следующий</I>, имеющим значение, отличное от nil). Если требуемого объекта нет (например, достигнут конец таблицы) или таблица пуста, то возвращается nil.</P>
<p class="h55">Пример:
</P>
<pre><code> (tblnext "LTYPE" T) возвращает список с характеристиками типа линий
 CONTINUOUS: ((0 . "LTYPE")  (2 . "Continuous")  (70 . 0)
 (3 . "Solid line")   (72 . 65)   (73 . 0)   (40 . 0.0))</code></pre>
<p class="h55">Пример использования функции tblnext совместно с функцией tblsearch:
</P>
<pre><code> (tblsearch "LTYPE" "continuous" T) возвращает ((0 . "LTYPE")
 (2 . "Continuous")   (70 .0)   (3 . "Solid line")  (72 . 65)  (73 . 0) (40 . 0.0))
 (tblnext "LTYPE") возвращает данные типа линий, следующего в таблице после CONTINUOUS</code></Pre>

<p class="h3">Функция tblobjname
</P>
<P>Определяет имя (адрес) объекта таблицы по его заголовку (имени).</P>
<pre><code> (tblobjname <таблица> <заголовок>)</code></pre>
<P>
Аргументы: <таблица> — текстовая строка с именем таблицы, <заголовок> — текстовая строка с именем элемента таблицы.
Возвращаемое значение— объект (его структура аналогична структуре примитива) в базе рисунка. Если объект с нужным заголовком не найден, то возвращается nil.</P>
<p class="h55">Пример:
</P>
<pre><code> (setq layer0 (tblobjname "LAYER" "0")) возвращает <Entity name: 7ef66c80> (entget layer0) возвращает СПИСОК ((-1 . <Entity name: 7ef 66c80>)
 (0 . "LAYER")  (330 . <Entity name: 7ef66cl0>)  (5 & "10")
 (100 . "AcDbSymbolTableRecord")  (100 . "AcDbLayerTableRecord")
 (2;* "0")  (70 . 0)  (62 . 215)  (420 . 10771353)  (6 . "Continuous")
 (290	(370 . -3)  (390 . <Entity name: 7ef66c78>))</code></pre>
<Br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=95%>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>

<Tr><Td Valign=ToP><P Class=pr>Замечание:&nbsp;&nbsp;</P></Td>
<Td Valign=Center><P Class=prt> В списке, полученном с помощью функций tblobjname и entget, больше данных по сравнению со списками, возвращаемыми функциями tblnext и tblsearch.</P></Td></Tr>

<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#800000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td><Img Src=../../../оболочка/images/raspor.gif Height=1></Td><Td Bgcolor=#FF0000><Img Src=../../../оболочка/images/raspor.gif Height=1></Td></Tr></Table>

<p class="h3">Схема работы с таблицами
</P>
<P>Схема использования рассмотренных функций, работающих с таблицами неграфических объектов, будет ясна из следующих примеров:
</P>
<pre><code> (setq lay1 (tblnext "LAYER" T)) возвращает список с данными первого слоя рисунка (первым слоем должен быть слой с именем "0"): ((0 . "LAYER")
 (2 . "О")   (70 . 0)   (62 .7)   (6 . "Continuous"))</code></pre>
<P>В этом списке в точечной паре с DXF-кодом 0 находится имя таблицы, в которой ищется неграфический объект, с кодом 2 — имя объекта (в нашем случае слоя), с кодом 6 — тип линий примитивов слоя по умолчанию (т. е. каким типом отображать объекты с типом линий ПоСлою (ByLayer)), с кодом 62 — цвет слоя по умолчанию, 70 — состояние слоя по отношению к операциям блокирования, замораживания. Нетрудно заметить, что аналогичные DXF-коды используются в списке, возвращаемом функцией entget для примитивов.</P>
<pre><code> (setq lay2 (tblnext "LAYER")) возвращает список с данными второго слоя
 рисунка, например: ((0 . "LAYER") (2 . "Стена1") (70 . 4) (62 . 253) (6 .  "BORDER"))
 (setq   lay2ent    (tblobjname   "LAYER"   "Стена1")) возвращает <Entity   name: 7ef66f98></code></pre>
<P>Теперь для объекта lay2ent с помощью функции entget можно получить список с данными.
Применяя функции tblnext, tblobjname и tblsearch, можно проанализировать наличие в рисунке таких элементов, как описания блоков, пользовательские системы координат или текстовые стили с определенными именами, и выбрать соответствующий вариант работы программы.</P>


<Hr Width="90%" Color="#7685C6" Align="Right">
<Br>

</Td></Tr></Table>
</Center>

 </Td>
</Tr>
<Tr>
 <Td ColSpan=2>

<Table Border=0 CellSpacing=0 CellPadding=0>
 <Tr>
  <Td BackGround=../../../оболочка/images/b1.gif Width=458 Height=100 Valign=Bottom>
   <P Class=co>Copyright &copy; БГУИР, Кафедра Систем управления, 2015<Br>
   <Img Src=../../../оболочка/images/raspor.gif Width=1 Height=8></P></Td>
  <Td BackGround=../../../оболочка/images/b2.gif Width=159 Height=100>
   <A Href=#Top onMouseOver="mOver(4)" onMouseOut="mOut(4)">
<Img Src=../../../оболочка/images/09a.gif Width=159 Height=46 Border=0 Alt="К началу документа" name="link4"></A><Br>
   <A Href=../../../index.html onMouseOver="mOver(5)" onMouseOut="mOut(5)">
<Img Src=../../../оболочка/images/10a.gif Width=159 Height=54 Border=0 Alt="К первой странице" name="link5"></A></Td>
 </Tr>
</Table>

 </Td>
</Tr>
</Table>

</Body>
</HTML>