<HTML>

<Head>
<Meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<Title>Электронный ресурс по учебной дисциплине ОСАПр. Теоретическая часть. Лекционный материал</Title>
<Meta Name="Description" http-equiv="description" Content="Электронный ресурс по учебной дисциплине ОСАПр. Теоретическая часть. Лекционный материал">
<Link Rel="stylesheet" Type="text/css" Href="../Оболочка/acad.css">

<Script Language="JavaScript">
	function mOver(num) {
		if (document.images) {
			document.images['link'+num].src=eval('active'+num+'.src');
		}
	}
	function mOut(num) {
		if (document.images) {
			document.images['link'+num].src=eval('normal'+num+'.src');
		}
	}
</Script>

<Style type='text/css'>
.times {
	font-family: "Verdana";
	font-size: 14px;
	font-style: italic;
}
.symtext {
	font-family: "Verdana";
	font-size: 14px;
	font-style: normal;
}
.suplex {
	font-family: "Verdana";
	font-size: 14px;
	font-style: normal;
	top: -3px;
	position: relative;
}
.sub {
	font-family: "Verdana";
	font-size: 9px;
	font-style: normal;
	top: 4px;
	position: relative;
}
.times20pt {
	font-family: "Verdana";
	font-size: 20pt;
	font-style: normal;
}
.index {
	font-family: "Verdana";
	font-size: 12px;
	font-style: normal;
	position: relative;
	top: 2px;
}
.unindex {
	font-family: "Verdana";
	font-size: 10px;
	font-style: normal;
	position: relative;
	top: -3px;
}
.naklon {
	font-style: italic;
}
.proizvodnaya {
	font-family: "Verdana";
	font-size: 16px;
	font-style: normal;
	left: 6px;
	top: -9px;
	position: relative;
}
.prl {
	font-family: "Verdana";
	font-size: 3px;
	font-style: normal;
	
}
.ravno {
	font-family: "Verdana";
	font-size: 12px;
	font-style: normal;
}
.big {
	font-family: "Times New Roman";
	font-size: 36px;
	font-style: normal;
	font-weight: lighter;
}
.index2 {
	font-family: "Verdana";
	font-size: 12px;
	font-style: normal;
	position: relative;
	top: 8px;
}
.unindex2 {
	font-family: "Verdana";
	font-size: 12px;
	font-style: normal;
	position: relative;
	top: -8px;
}
.subPLUS {
	font-family: "Verdana";
	font-size: 9px;
	font-style: normal;
	top: 4px;
	position: relative;
	left: -4px;
}
.sup {
	font-family: "Verdana";
	font-size: 9px;
	font-style: normal;
	top: -6px;
	position: relative;
	right: -2px;
}
</Style>
</Head>

<Body Bgcolor=#E6E6E6 TopMargin=1 LeftMargin=1 MarginWidth=0 MarginHeight=0>
<Div Class=max>
<Script Language="JavaScript">
if (document.images) {
	normal1=new Image(190,29);normal1.src="../Оболочка/images/01a.gif";
	active1=new Image(190,29);active1.src="../Оболочка/images/01p.gif";
	normal3=new Image(190,29);normal3.src="../Оболочка/images/03a.gif";
	active3=new Image(190,29);active3.src="../Оболочка/images/03p.gif";
	normal4=new Image(190,29);normal4.src="../Оболочка/images/04a.gif";
	active4=new Image(190,29);active4.src="../Оболочка/images/04p.gif";
	normal5=new Image(190,29);normal5.src="../Оболочка/images/05a.gif";
	active5=new Image(190,29);active5.src="../Оболочка/images/05p.gif";
	normal6=new Image(159,46);normal6.src="../Оболочка/images/06a.gif";
	active6=new Image(159,46);active6.src="../Оболочка/images/06p.gif";
	normal7=new Image(159,54);normal7.src="../Оболочка/images/07a.gif";
	active7=new Image(159,55);active7.src="../Оболочка/images/07p.gif";
}
</Script>

<A Name="Top"></A>
<Table Border=0 Width=100% CellSpacing=0 CellPadding=0>
<Tr>
 <Td BackGround=../Оболочка/images/bg01.gif Width=190 Height=91>&nbsp;</Td>
 <Td RowSpan=2 BackGround=../Оболочка/images/bg02.gif Height=120 Valign=Bottom>
<Table BackGround=../Оболочка/images/raspor.gif Border=0 CellSpacing=0 CellPadding=0>
 <Tr>
  <Td Width=185></Td>
  <Td Valign=top Height=63><P Class=h6>Конспект лекций ОСАПР</P></Td>
 </Tr>
</Table>

</Td></Tr>
<Tr>
  <Td BackGround=../Оболочка/images/bg03.gif>
    <A Href=../Программа/!rabprog.html onMouseOver="mOver(1)" onMouseOut="mOut(1)"><Img Src=../Оболочка/images/01a.gif Border=0 Width=190 Height=29 Alt="Рабочая программа" name="link1"></A><Br>
 </Td>
</Tr>
<Tr>
 <Td Height=100% RowSpan="2" Valign=Top BackGround=../Оболочка/images/bg00.gif>

<Table Border=0 CellSpacing=0 CellPadding=0>
<Tr><Td BackGround=../Оболочка/images/bg03.gif Valign=Top>
  <Img Src=../Оболочка/images/02p.gif Width=190 Height=29 Border=0 Alt="Лекции"></A><Br>
 </Td>
</Tr>
<Tr><Td BackGround=../Оболочка/images/bg03.gif Width=190 Valign=Top>
 <A Href=../Практика/!zadanie.html onMouseOver="mOver(3)" onMouseOut="mOut(3)"><Img Src=../Оболочка/images/03a.gif Width=190 Height=29 Border=0 Alt="Лабораторные работы" name="link3"></A><Br>
 <A Href=../Заочнику/!zaochnoe.html onMouseOver="mOver(4)" onMouseOut="mOut(4)"><Img Src=../Оболочка/images/04a.gif Width=190 Height=29 Border=0 Alt="Заочное" name="link4"><Br>
 <A Href=../Контроль_знаний/!samocontrol.html onMouseOver="mOver(5)" onMouseOut="mOut(5)"><Img Src=../Оболочка/images/05a.gif Width=190 Height=29 Border=0 Alt="Самоконтроль" name="link5"></A><Br>
 <Img Src=../Оболочка/images/bg08.gif Width=190 Height=13><Br>
</Table></Td>
 
 <Td Valign=Сenter Width=97%>
 <Br><Br>

 
<Ul>
 <Dt><A Class=m Href="##0.">Введение</A></Dt>
 <Dt><A Class=m Href="##1.">1. Современные технологии проектирования</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##1.1.">Интегрированные системы CAD/CAM/CAE</A></Dt>
  <Dt><A Class=m Href="##1.2.">Жизненный цикл изделия и его этапы</A></Dt>
  <Dt><A Class=m Href="##1.3.">Технологии управления производственной информацией</A></Dt>
  <Dt><A Class=m Href="##1.4.">Концепция CALS</A></Dt>
 </Ul>
 <Dt><A Class=m Href="##2.">2. Графические стандарты</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##2.1.">Форматы графических файлов</A></Dt>
  <Dt><A Class=m Href="##2.2.">Обмен графической информацией</A></Dt>
  <Dt><A Class=m Href="##2.3.">Стандартные графические примитивы</A></Dt>
 </Ul>
 <Dt><A Class=m Href="##3.">3. Принципы построения систем графического моделирования</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##3.1.">Основные этапы процесса проектирования</A></Dt>
  <Dt><A Class=m Href="##3.2.">Двухмерные графические системы</A></Dt>
  <Dt><A Class=m Href="##3.3.">Трёхмерные графические системы</A></Dt>
 </Ul>
 <Dt><A Class=m Href="##4.">4. Системы геометрического моделирования</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##4.1.">DUCT</A></Dt>
  <Dt><A Class=m Href="##4.2.">Система CATIA</A></Dt>
  <Dt><A Class=m Href="##4.3.">Системы фирмы Autodesk</A></Dt>
  <Dt><A Class=m Href="##4.4.">Система I-DEAS</A></Dt>
  <Dt><A Class=m Href="##4.5.">Система Unigraphics</A></Dt>
 </Ul>
 <Dt><A Class=m Href="##5.">5. Системы координат</A></Dt>
 <Dt><A Class=m Href="##6.">6. Матрицы преобразования</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##6.1.">Трансляция</A></Dt>
  <Dt><A Class=m Href="##6.2.">Вращение</A></Dt>
  <Dt><A Class=m Href="##6.3.">Отображение</A></Dt>
  <Dt><A Class=m Href="##6.4.">Масштабирование и зеркльное отображение</A></Dt>
 </Ul>
 <Dt><A Class=m Href="##7.">7.Представление кривых и работа с ними</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##7.1.">Типы уравнений</A></Dt>
  <Dt><A Class=m Href="##7.2.">Конические сечения</A></Dt>
  <Dt><A Class=m Href="##7.3.">Окружность и дуга окружности</A></Dt>
  <Dt><A Class=m Href="##7.4.">Эллипс и эллиптическая дуга</A></Dt>
  <Dt><A Class=m Href="##7.5.">Гипербола</A></Dt>
  <Dt><A Class=m Href="##7.6.">Парабола</A></Dt>
  <Dt><A Class=m Href="##7.7.">Эрмитовы кривые</A></Dt>
  <Dt><A Class=m Href="##7.8.">Кривая Безье</A></Dt>
  <Dt><A Class=m Href="##7.9.">B-сплайн</A></Dt>
  <Dt><A Class=m Href="##7.10.">Неоднородный рациональный В-сплайн (NURBS)</A></Dt>
 </Ul>
 
   <Dt><A Class=m Href="##8.">8.Представление поверхностей и работа с ними</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##8.1.">Типы уравнений поверхностей</A></Dt>
  <Dt><A Class=m Href="##8.2.">Билинейная поверхность</A></Dt>
  <Dt><A Class=m Href="##8.3.">Лоскут Куна</A></Dt>
  <Dt><A Class=m Href="##8.4.">Бикубический лоскут</A></Dt>
  <Dt><A Class=m Href="##8.5.">Поверхность Безье</A></Dt>
  <Dt><A Class=m Href="##8.6.">В-сплайновая поверхность</A></Dt>
  <Dt><A Class=m Href="##8.7.">Поверхность NURBS</A></Dt>
 </Ul>

   <Dt><A Class=m Href="##9.">9.Структуры для хранения данных о 3D-объектах</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##9.1.">Дерево CSG</A></Dt>
  <Dt><A Class=m Href="##9.2.">Структура данных B-Rep</A></Dt>
  <Dt><A Class=m Href="##9.3.">Структура декомпозиционной модели</A></Dt>
  <Dt><A Class=m Href="##9.4.">Воксельное представление</A></Dt>
  <Dt><A Class=m Href="##9.5.">Представление октантного дерева</A></Dt>
  <Dt><A Class=m Href="##9.6.">Ячеечное представление</A></Dt>
  <Dt><A Class=m Href="##9.7.">Булевы операторы</A></Dt>
  <Dt><A Class=m Href="##9.8.">Расчёт объёмных параметров</A></Dt>
 </Ul>

   <Dt><A Class=m Href="##10.">10.Удаление невидимых линий и поверхностей</A></Dt>
 <Ul>
  <Dt><A Class=m Href="##10.1.">Алгоритм удаления невидимых граней</A></Dt>
  <Dt><A Class=m Href="##10.2.">Алгоритм художника</A></Dt>
  <Dt><A Class=m Href="##10.3.">Алгоритм удаления невидимых линий</A></Dt>
 </Ul>
 
</Ul>
<Br><Br>




<A Name="#0."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=98% BgColor=#ABB3D5>
 <Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
 <Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif Width="1" Height="1"></Td>
 <Td Valign=Center><span Class=h>Введение</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br>


<P>В настоящее время при изготовлении чертежей и прочей конструкторской документации системы автоматизированного проектирования (САПР) практически полностью вытеснили традиционный способ черчения – кульман. Использование компьютера предоставляет конструкторам и технологам множество преимуществ в изготовлении чертежей, освобождает их от рутинной работы, а также резко повышает производительность труда (по некоторым оценкам в 2–2,5 раза). САПР ориентированы на работу в интерактивном режиме, предоставляя проектировщику оперативный доступ к графической информации, простой и эффективный язык управления ее обработкой с практически неограниченными возможностями контроля результатов. В результате удается автоматизировать самую трудоемкую часть работы (в процессе традиционного проектирования на разработку и оформление чертежей приходится около 70 % от общих трудозатрат конструкторской работы, 15 % – на организацию и ведение архивов и 15 % – собственно на проектирование, включающее в себя разработку конструкции, расчеты, согласования и т.д.).</P>

<P>В данном конспекте лекций раскрываются принципы автоматизации проектирования, а также рассматриваются вопросы архитектуры и информационного обеспечения САПР. Подробно изложены современные технологии проектирования, включая интегрированные системы CAD/CAM/CAE и концепцию CALS. Приводятся базовые сведения о принципах построения систем графического моделирования, а также об основных графических стандартах. Проводится сравнительный анализ наиболее распространенных систем графического моделирования: DUCT, CATIA, AutoCAD, I-DEAS, Unigraphics.</P>

<P>В пособии также изложены основные принципы работы автоматизированных систем для проектировании изделий и подготовки их производства (без углубления и детализации конкретных систем). Рассмотрены компоненты САПР, основные концепции графическою программирования, системы автоматизированной разработки чертежей, системы геометрического моделирования, представление кривых и поверхностей и работа с ними, стандарты обмена данными между системами.</P>
<Br><Br>




<A Name="#1."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=98% BgColor=#ABB3D5>
 <Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
 <Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif Width="1" Height="1"></Td>
 <Td Valign=Center><span Class=h>1. Современные технологии проектирования</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br>

<A Name="#1.1."><P Class=h3>Интегрированные системы CAD/CAM/CAE</P></A>

<P>Определяющими факторами успеха в промышленном производстве являются уменьшение времени выхода продукции на рынок,
повышение её качества и снижение стоимости. Практическая реализация этих требований обусловливает необходимость
модернизации проектно-технологических и производственных процессов как в рамках отдельных предприятий, так и в условиях
"расширенного предприятия", объединяющего всех поставщиков, соисполнителей и участников проектирования и производства
продукции. В настоящее время наиболее радикальным средством решения задач модернизации является внедрение интегрированных
информационных технологий на базе использования современных средств вычислительной техники и сетевых решений. К числу
наиболее эффективных технологий, дающих весомый выигрыш в короткие сроки, принадлежат системы автоматизированного
проектирования, инженерного анализа и технологической подготовки (CAD/CAM/CAE), а также системы управления
производственной информацией (PDM).</P>

<P>Первым, наиболее значительным результатом в области разработки программных средств САПР является создание интерактивных
графических редакторов (систем автоматизированного черчения CADD - Computer-Aided Design and Drafting). В сущности, все
графические редакторы работают одинаково: для них определены элементарные геометрические объекты (примитивы), а также
процедуры манипулирования с этими примитивами (редактирование). Поэтому в таких редакторах реализованы упрощённые
представления о процессе проектирования как о процессе создания геометрических объектов путём манипуляции с набором неких
элементарных геометрических объектов - геометрических примитивов. Очевидно, что такие представления недостаточно точно
отражают работу инженера-конструктора, не позволяют ему отличить её от деятельности чертёжника, которая полностью
ограничивается рамками изготовления технической документации.</P>

<P>Специализация графических редакторов для САПР привела к появлению целого ряда утилит, одни из которых встраивались в
ядро редактора (например, утилита образмеривания), а другие предполагалось применять как независимые сервисные программы
(утилита параметрического проектирования и пр.). Это, безусловно, улучшило эффективность использования САПР, но ничего не
изменило принципиально. В настоящее время развитие программных средств САПР идёт в направлении решения довольно небольшого
круга проблем, к которым в первую очередь относятся: эффективность твердотельного моделирования, параметризация, а также
ассоциативность и программный интерфейс.</P><Br>


<A Name="#1.2."><P Class=h3>Жизненный цикл изделия и его этапы</P></A>

<P>Анализ развития информационных технологий в производственных задачах показывает, что основной тенденцией является все более полный охват стадий жизненного цикла продукции. Гибкие производственные системы решали задачи, касающиеся исключительно производства изделий. В компьютеризированном интегрированном производстве круг решаемых задач значительно расширился и включил в себя разработку, проектирование и изготовление, материально-техническое обеспечение и другие задачи предприятия. Тем не менее остались нерешенными следующие задачи: взаимодействие с заказчиком, взаимодействие партнерами-поставщиками, послепродажное сопровождение изделия и многие другие.</P>

<P>К середине 90-х г. XX в. появилось осознание необходимости создания интегрированной информационной системы, поддерживающей весь жизненный цикл изделия.</P>

<P><I>Жизненный цикл</I> (ЖЦ) продукции – это совокупность процессов, выполняемых от момента выявления потребностей общества в определенной продукции до момента удовлетворения этих потребностей и утилизации продукции. К основным стадиям ЖЦ относятся: маркетинг; проектирование и разработка продукции; планирование и разработка процессов; закупки материалов и комплектующих; производство или предоставление услуг; упаковка и хранение; реализация; монтаж и ввод в эксплуатацию; техническая помощь и сервисное обслуживание; послепродажная деятельность или эксплуатация; утилизация и переработка в конце полезного срока службы.</P>

<P>Многообразие процессов в ходе ЖЦ и необходимость их интенсификации требуют активного информационного взаимодействия субъектов (организаций), участвующих в поддержке ЖЦ продукции. С ростом числа участников растет объем используемой и передаваемой информации.</P>

<P>Потребность в создании интегрированной системы поддержки ЖЦ изделия и организации информационного взаимодействия компонентов такой системы приводят к необходимости создания интегрированной информационной среды (ИИС), в основе которой лежит использование открытых архитектур, международных стандартов, совместное использование данных и программно-технических средств.</P>

<P>В сложных долговременных проектах ИИС обеспечивает взаимодействие проектных организаций и производственных предприятий, поставщиков, организаций сервиса и конечного потребителя на всех стадиях ЖЦ. В проектах, финансируемых или контролируемых государством, к необходимой информации могут иметь доступ уполномоченные государственные структуры.</P>

<P>Данный подход характеризуется следующими особенностями:
<br>
•	в отличие от компьютерной автоматизации и интеграции отдельных процессов, например, в производстве решаются задачи информационной интеграции всех процессов ЖЦ;
<br>
•	решаемые задачи выходят за границы отдельного предприятия, участники информационного взаимодействия могут быть территориально удалены друг от друга, располагаться в разных городах и даже странах;
<br>
•	совместно используемая информация очень разнородна: это маркетинговые, конструкторско-технологические, производственные данные, коммерческая и юридическая информация и т.д. Для ее совместного использования должны быть стандартизованы способы, технологии представления и корректной интерпретации данных;
<br>
•	основной средой передачи данных является глобальная сеть Интернет.
</P>


<Br>


<A Name="#1.3."><P Class=h3>Технологии управления производственной информацией</P></A>

<P>В рамках технологии CALS развиваются современные технологии управления производственной информацией, часто называемые
PDM-системами (Product Data Management). Они следят за большими, постоянно обновляющимися массивами данных и инженерно-технической информации. В отличие от баз данных PDM-системы интегрируют информацию любых форматов и типов, поступающую от различных источников, предоставляя ее пользователям в структурированном виде, отражающем особенности современного промышленного производства. Системы PDM отличаются также и от интегрированных систем офисного документооборота, поскольку текстовые документы являются далеко не самыми «нужными» на производстве (куда важнее геометрические модели, данные для функционирования автоматических линий, станков с ЧПУ и т.п.). Системы PDM обобщают такие широко известные технологии, как управление инженерными данными (Engineering Data Management – EDM), управление документами, управление информацией об изделии (Product Information Management – PIM), управление техническими данными (Technical Data Management – TDM), управление технической информацией (Technical Information Management – TIM), управление изображениями и пр.
</P>

<P>Любая информация, необходимая на том или ином этапе жизненного цикла изделия, может управляться системой PDM, которая
предоставляет корректные данные всем пользователям и всем промышленным информационным системам. Наряду с данными PDM
управляет и проектом - процессом разработки изделия, контролируя собственно информацию об изделии, о состоянии объектов
данных, об утверждении вносимых изменений, осуществляя авторизацию и другие операции, которые влияют на данные об изделии
и режимы доступа к ним каждого конкретного пользователя.</P>

<P>Системы PDM играют роль связующего звена между этапом инженерно-конструкторской подготовки нового изделия и системами
MRP (<I>Manufacturing Resource Planning</I>) или, другими словами, разного рода АСУ, решающими задачи автоматизации
управления финансами, складским хозяйством, снабжением и сбытом, а также техническим обслуживанием. О важности такого рода
систем свидетельствует хотя бы такой факт, что только 25 % рабочего времени персонала компании, начиная от проектировщика
и кончая руководителем проекта, тратится на собственно творческую работу, а остальное время идёт на поиск информации и
стыковку потоков данных, поступающих от разных подразделений. Часто оказывается, что проще заново разработать деталь, чем
найти информацию, подготовленную некоторое время назад.</P>

<P>Место систем PDM в общей производственной цепочке показано на рис. 1.1. Они занимают промежуточное положение между
системами MPR и системами CAD/CAM/CAE, которые в русскоязычной литературе называют одним термином - интегрированные САПР.
В англоязычной литературе под указанными терминами понимают следующее:</P>

<P>CAD (Computer-Aided Design) – общий термин для обозначения всех аспектов проектирования с использованием средств вычислительной техники; обычно охватывает создание геометрических моделей изделия (твердотельных, трехмерных, составных), а также генерацию чертежей изделия и их сопровождений;</P>

<P>САМ (Computer-Aided Manufacturing) – общий термин для обозначения программных систем подготовки информации для станков с ЧПУ; традиционно исходными данными для таких систем были геометрические модели деталей, получаемые из систем CAD;</P>

<P>САЕ (Computer-Aided Engineering) – общий термин для обозначения информационного обеспечения автоматизированного анализа проекта (прочностные расчеты, коллизии кинематики и т. п.) или оптимизации производственных возможностей.</P>

<Center><Img src="images/001.png"><P Class=c>Рис. 1.1. Взаимосвязь систем автоматизации производственных процессов</P></Center>

<P>Главное направление развития современных САПР - повышение их интеллектуальных функций, т.е. способности "понимать"
намерения конструкторов. В простейшем случае в системе запоминается лишь "история" или последовательность шагов,
выполняемых проектировщиком. Такие системы удобны при создании библиотек стандартных деталей и элементов, но для более
сложных ситуаций требуется более "интеллектуальная" реализация пользовательского интерфейса. Поэтому в САПР начинает всё
шире использоваться объектная технология, в соответствии с которой САПР должны не работать с файлами, а обрабатывать
объекты. Объекты образуют собой "целостности", включающие множественные непротиворечивые представления одной и той же
"сущности". Например, деталь может представлять интерес для дизайнера с позиции эстетики формы, для инженера - с позиции
вычислительной сложности поверхности, для технолога - с позиции применимости процесса штамповки для её изготовления. Объект
позволяет объединить подобные представления, а это открывает прямой путь к эффективной реализации идей С-технологии, т.е.
параллельного проектирования и инжиниринга (concurrent design and engineering).</P>

<P>С-технология (конструкторско-технологическое проектирование) - это принципиально новый, интегрированный подход к
проектированию. В её основе лежит идея совмещенного проектирования изделия, а также процессов его изготовления и
сопровождения, координируемых с помощью специально создаваемой для этой цели распределенной информационной среды. Подобная
технология позволяет использовать проектные данные, начиная с самых ранних стадий проектирования, одновременно различными
группами специалистов. Например, в трёх главных конструкторских бюро компании Boeing действуют 220 групп
"проектирование-производство", которые координируют параллельные разработки и состоят из специалистов таких разнообразных
областей, как конструирование, технология материалов, производство и взаимодействие с клиентами. С-технология обеспечивает
устранение известных недостатков последовательного проектирования, в частности, в случае, когда ошибки проекта изделия
неожиданно обнаруживаются на последних его стадиях. Кроме того, появляется возможность легко и быстро вносить изменения в
проект, причем таким образом, чтобы изменения не вызывали повторного проектирования созданных деталей и узлов. Сегодня
"перепроектирование" продолжает оставаться существенной затратной компонентой любой разработки.</P>

<P>Следует обратить внимание на интересные инициативы в области САПР, возникшие в Германии, связанные с проблемой роста несовместимости решений, предлагаемых многочисленными производителями информационной техники, включая и CAD/CAM/CAE-системы. Решение этой проблемы стало настолько насущным, что поставлен вопрос о стандартизации систем CAD/CAM/CAE и информационной техники в целом. Концерн Daimler-Benz выступил с предложением под названием «Инициатива по передовой информационной технике», которое поддержали British Aerospace, FIAT, Renault, SAAB, Volkswagen и многие другие компании. Другой проект под названием CAD2000 объединил компании Audi, BMW, Mercedes-Benz, Porsche, Volkswagen. Эти проекты пытаются решить громадную по масштабам и сложности проблему поиска стандартных решений, способных удовлетворить огромное множество прикладных требований от проектирования до изготовления, а также управления информационными данными и библиотеками стандартных компонентов.</P>
<br>

<A Name="#1.4."><P Class=h3>Концепция CALS</P></A>

<P>Современное представление о процессе проектирования исходит из его «генетического» единства с процессом производства. С этой точки зрения проектирование является информационной моделью производства, а никак не процессом изготовления технической документации. Следует отметить, что ранее конструкторы не имели инструментов для проверки адекватности указанных процессов, поэтому и появилась специальность технолога, который по сути дела осуществляет «переформатирование» описания из форм, адекватных процессу проектирования, в форму, адекватную процессу производства. Но с появлением современных средств вычислительной техники стала возможна непосредственная передача информации от компьютеров к элементам производства, хотя, как правило, необходимость изготовления технической документации сохраняется.</P>

<P>Впервые работы по созданию интегрированных систем, поддерживающих ЖЦ продукции, были начаты в 80-х г. XX в. в оборонном комплексе США. Новая концепция была востребована жизнью как инструмент совершенствования управления материально-техническим обеспечением армии США. Предполагалось, что реализация новой концепции, получившей обозначение CALS (Computer Aided Logistic Support – компьютерная поддержка процесса поставок), позволит сократить затраты на организацию информационного взаимодействия государственных учреждений с частными фирмами в процессах формализации требований, заказа, поставок и эксплуатации военной техники. Появилась реальная потребность в организации ИИС, обеспечивающей обмен данными между заказчиком, производителями и потребителями, а также повышение управляемости, сокращение бумажного документооборота и связанных с ним затрат. Доказав свою эффективность, концепция последовательно совершенствовалась, дополнялась и, сохранив существующую аббревиатуру (CALS), получила более широкую трактовку – Continuous Acquisition and Life cycle Support – непрерывная информационная поддержка поставки и ЖЦ продукции.</P>

<P>Первая часть – Continuous Acquisition [Support] (непрерывная поддержка поставки) означает непрерывность информационного взаимодействия с заказчиком в ходе формализации его потребностей, формирования заказа, процесса поставки и т.д. Вторая часть – Life Cycle Support (поддержка ЖЦ изделия) – означает системность подхода к информационной поддержке всех процессов ЖЦ изделия, в первую очередь процессов эксплуатации, обслуживания, ремонта и утилизации и т.д.</P>

<P>В период 1990–2000гг. в мире был выполнен ряд проектов, направленных на апробацию и внедрение принципов CALS в различных отраслях промышленности. Поскольку термин CALS всегда носил военный оттенок, в гражданской сфере широкое распространение получили термины Product Life Cycle Support (PLCS) или Product Life Management (PLM) – «поддержка жизненного цикла изделия». К PLM относятся практически все средства и системы автоматизации: конструкторские и технологические САПР (CAD/CAM/CAE, CAPP), системы ERP (MRP), средства управления взаимодействием с клиентами (CRM), цепочками поставок (SCM), техническим обслуживанием (сервисом) и т.д. Сюда же относятся PDM-системы, которым отводится ключевая роль в организации информационного взаимодействия всех участников ЖЦ изделия через ИИС.</P>

<Br><Br>




<A Name="#2."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=98% BgColor=#ABB3D5>
 <Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
 <Tr><Td Width=30><Img Src=raspor.gif Width="1" Height="1"></Td>
 <Td Valign=Center><span Class=h>2. Графические стандарты</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br>

<A Name="#2.1."><P Class=h3>Форматы графических файлов</P></A>

<P>При автоматизированном проектировании возникает необходимость обмениваться графической информацией между различными подсистемами, которые в общем случае могут быть реализованы не только в различной программной среде, но и на различных аппаратных средствах. При этом важно правильно выбрать формат записи данных, который, с одной стороны, должен обеспечивать минимальный размер файлов, а с другой – сохранение точности графической модели изделия. Поэтому рассмотрим подробнее вопросы кодирования графической информации или, сокращенно, графические форматы. Для записи графической информации используются два принципиально различных формата – растровый и векторный. Первый применяется при обработке изображений, полученных c помощью сканера, а также при редактировании фотоизображений; второй – в системах автоматизированного проектирования и графических пакетах.</P>

<P>Растровый формат (Adobe Photoshop, Paint) описывает изображение как совокупность точек (dots), число которых
определяется разрешением, измеряемым в специальных единицах - dpi или dpc (число точек на 1 дюйм или на 1 см
соответственно). Для цветных и полутоновых изображений определяется также "глубина цвета" - число двоичных разрядов,
отводимых для хранения информации о цвете. Например, для изображений типа RGB глубина 24 бита означает, что на каждый
основной цвет (красный - R, зеленый - G, синий - В) отводится по 8 бит, поэтому цветовая палитра состоит из примерно 16
млн. цветов.</P>

<P>Основной недостаток растрового формата - большой объём графического файла. Так, даже для растрового изображения со
сравнительно невысоким разрешением 1024<Font Face=Symbol>&acute;</Font>768 точек и 256 цветами требуется 768 кб. Поэтому в
графических пакетах используются различные алгоритмы сжатия, что затрудняет преобразование растрового формата и создаёт
множество проблем при использовании его в САПР.</P>

<P>Векторный формат (AutoCAD, CorelDRAW, Visio и др.) описывает изображение как совокупность простейших примитивов (линия, ломаная, кривая Безье, эллипс, прямоугольник и т. д.), для каждого из которых задаются соответствующие атрибуты: координаты вершин или других характерных точек, толщина и цвет контурной линии, тип и цвет заливки и т. д. Кроме того, задается расположение элементов относительно друг друга (какой из них расположен сверху, а какой – снизу). Главное достоинство векторных файлов по сравнению с растровыми – меньший размер и удобство редактирования, но при их выводе на экран производится множество математических операций. Поэтому скорость вывода векторных изображений обычно меньше, чем растровых, хотя этот недостаток довольно эффективно устраняется при помощи специальных процессоров – графических ускорителей.</P>

<P>Существует целый ряд программ, переводящих графические данные из векторного формата в растровый. Но обратная задача
(перевод растровых изображений в векторные) является довольно сложной и решается только в наиболее совершенных графических
пакетах. Не менее сложные проблемы возникают и при преобразованиях одного векторного формата в другой, так как многие
графические пакеты используют уникальные математические модели для элементов изображения. В настоящее время применяют
несколько десятков форматов представления графических данных. Рассмотрим наиболее распространённые из них.</P>

<P Class="r">Таблица 1</P>

<P Class="c">Форматы графических файлов</P>

<Center>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
  <Td><P Class=tcb>Тип</P></Td>
  <Td><P Class=tcb>Название</P></Td>
  <Td><P Class=tcb>Описание</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
  <Td><P Class=tc>BMP</P></Td>
  <Td><P Class=tl>ByteMaP</P></Td>
  <Td><P Class=tl>Растровый. Поддерживается практически любым Windows-приложением. Его главная особенность - независимость
   от типа адаптера и монитора при кодировании цвета. Используется алгоритм сжатия RLE (Run-Length Encoded). Размер файлов
   довольно большой. Использует индексированные цвета либо цветовую модель RGB.</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>PCX</P></Td>
  <Td><P Class=tl>PC Paintbrush</P></Td>
  <Td><P Class=tj>Растровый. Первоначально он использовался в программе Paintbrush, но постепенно
   получил широкое распространение в других графических редакторах. Используется алгоритм сжатия RLE,
   позволяющий уменьшать размер файла на 40...70%, если число цветов не превышает 16. Он поддерживает исключительно
   индексированный цвет и имеет преимущественно историческое значение.</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
  <Td><P Class=tc>TIFF</P></Td>
  <Td><P Class=tl>Tagged Image File Format</P></Td>
  <Td><P Class=tj>Растровый. Создан в качестве универсального формата для хранения сканированных изображений с цветовыми
   каналами. Импортируется в программы настольных издательских систем. Позволяет хранить изображения с любой глубиной
   цвета и цветовой моделью. Поддерживаются дополнительные каналы масок, калибровочная информация, многочисленные
   алгоритмы сжатия без потерь информации. В последней, шестой спецификации позволяет хранить простейшие объектные
   контуры. Ориентирован на типографскую печать. Приводит к значительным размерам файлов (цветное изображение размера А4
   при разрешении 300 dpi может занимать около 40 Мб).</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>GIF</P></Td>
  <Td><P Class=tl>Graphics Interchange Format</P></Td>
  <Td><P Class=tj>Растровый. Создан специально для передачи изображений в компьютерных сетях. К моменту создания обладал
   самым эффективным методом сжатия без потерь информации. "Второе дыхание" обрёл с появлением версии 89а (хранение в одном
   файле нескольких изображений для анимации). Может использовать "прозрачный цвет".</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
  <Td><P Class=tc>PNG</P></Td>
  <Td><P Class=tl>Portable Network Graphics</P></Td>
  <Td><P Class=tl>Растровый. Предназначен для передачи изображений в сетях. Поддерживает полноцветные RGB- и
   индексированные изображения. Имеет эффективный алгоритм сжатия без потерь информации. Может использовать "прозрачный
   цвет".</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>JPEG</P></Td>
  <Td><P Class=tl>Joint Photographic Experts Group</P></Td>
  <Td><P Class=tj>Растровый. Использует сжатие с потерями информации. Работает с полноцветными изображениями в моделях RGB
   и CMYK, а также полутоновыми. Широко используется для верстки Web-страниц и хранения фотографий.</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
  <Td><P Class=tc>JPEG 2000</P></Td>
  <Td><P Class=tl>Joint Photographic Experts Group 2000</P></Td>
  <Td><P Class=tj>Новый вариант JPEG. Имеет высокие степени сжатия за счёт снижения качества. Усовершенствованный
   алгоритм сжатия позволяет добиваться большей эффективности, меньше жертвуя качеством. Исключает характернй для JPEG
   эффект, связанный с блочной обработкой изображений (видимые квадраты 8<Font Face=Symbol>&acute;</Font>8 пикселов).
   Существует в двух вариантах: стандартном (Standard, расширение jp2) и оптимизированном для Web (Codestream, расширение
   jpc).</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>PSD</P></Td>
  <Td><P Class=tl>PhotoShop Document</P></Td>
  <Td><P Class=tj>Собственный формат Adobe Photoshop. Поддерживает все функции своего приложения: слои, каналы, контуры,
   установки печати, системы цветокоррекции. Работает со всеми типами растровых изображений и цветовых моделей,
   многоканальными изображениями и дуплексами.</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
  <Td><P Class=tc>CGM</P></Td>
  <Td><P Class=tl>Computer Graphics Metafile</P></Td>
  <Td><P Class=tl>"Метафайл", т.е. обеспечивает кодирование как векторных, так и растровых изображений. Достоинство -
   независимость от аппаратных и программных средств, что позволяет эффективно осуществлять обмен данными между различными
   программами и платформами. Но для хранения чертежей и рисунков этот формат практически не применяется.</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>DWG</P></Td>
  <Td><P Class=tl>Drawing</P></Td>
  <Td><P Class=tj>Векторный. формат САПР AutoCAD.</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
  <Td><P Class=tc>DXF</P></Td>
  <Td><P Class=tl>Drawing eXchange Format</P></Td>
  <Td><P Class=tj>Векторный. Поддерживается практически всеми САПР и графическими пакетами. Позволяет хранить трёхмерные
   объекты.</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>CDR</P></Td>
  <Td><P Class=tl>CorelDRaw</P></Td>
  <Td><P Class=tj>Векторный. Формат программы CorelDraw позволяет сохранять не только векторные изображения, но и
   растровую графику и текст.</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
  <Td><P Class=tc>3DS</P></Td>
  <Td><P Class=tl>3D Studio</P></Td>
  <Td><P Class=tl>Универсальный формат, отличный способ передачи финальных вариантов полигональной графики.</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>EMF</P></Td>
  <Td><P Class=tl>Enhanced MetaFile</P></Td>
  <Td><P Class=tj>Аппаратно-независимый формат хранения векторной графики.</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
  <Td><P Class=tc>EPS</P></Td>
  <Td><P Class=tl>Encapsulated PostScript</P></Td>
  <Td><P Class=tj>Использует как векторный, так и растровый способы записи графических данных. Соответствующий файл
   представляет собой набор команд, выполняемых интерпретатором языка PostScript при выводе изображения. При этом EPS-файл
   не зависит ни от операционной системы, ни от аппаратных средств. Однако программы, поддерживающие этот формат, часто не
   обеспечивают полной совместимости.</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>IGES</P></Td>
  <Td><P Class=tl>Int. Graphical Exchange Standard</P></Td>
  <Td><P Class=tj>Представляет собой набор протоколов для передачи графических данных и вывода их на экран монитора.
   Первоначально он применялся для поддержки удаленных терминалов, но в настоящее время используется в ряде CAD-приложений,
   оперирующих с трёхмерными изображениями.</P></Td>
 </Tr>
 <Tr BgColor=#EAEAEA>
  <Td><P Class=tc>WMF</P></Td>
  <Td><P Class=tl>Windows MetaFile</P></Td>
  <Td><P Class=tj>Обеспечивает кодирование как векторных, так и растровых данных и является аналогом формата PICT для
   оболочки Windows. Служит для передачи векторов через буфер обмена (Clipboard). Понимается практически всеми программами
   Windows, связанными с векторной графикой. Искажает цвет, не может сохранять ряд параметров, которе могут быть присвоены
   объектам в различных векторных редакторах, не может содержать растровые объекты.</P></Td>
 </Tr>
</Table>
</Center>
<Br><Br>

<A Name="#2.2."><P Class=h3>Обмен графической информацией</P></A>

<Table Border=0 CellPadding=0 CellSpacing=0>
 <Tr><Td>

<P>При организации обмена графической информацией в компьютерной графике различают несколько уровней графических стандартов
(рис. 2.1.). Эти стандарты обеспечивают связь между:<Br><Br>

а) графическими утилитами и устройствами графического вывода;<Br>
б) прикладными программами и графическими утилитами;<Br>
в) различными САПР.<P><Br>

<P>Для обеспечения связи между графическими утилитами и устройствами вывода наиболее часто используется стандарт VDI
(Virtual Device Interface - интерфейс виртуального устройства), который в настоящее время переименован в CGI (Computer
Graphics Interface - интерфейс компьютерной графики).</P>

<P>Наиболее распространенным стандартом, обеспечивающим связь между прикладными программами и графическими утилитами,
является GKS (Graphical Kernel System - графическая корневая система). Иногда используется и более ранний стандарт CORE,
основные функции которого реализованы в GKS. А наиболее совершенным из стандартов этого класса является PHIGS
(Programmers Hierarchical Interface for Graphics - программистский иерархический графический интерфейс), описывающий
сложные иерархические структуры графических данных, в том числе и трехмерные.</P>

<P>Для обеспечения связи между различными САПР используется ряд стандартов, наиболее распространенным из которых является
IGES (стандартный протокол обмена графической информацией). В этом стандарте различные данные классифицируются в терминах
сущностей, которые могут принадлежать к одной из трех категорий: геометрии (точки, отрезки, дуги, плоскости и т.п.),
аннотации (размеры, осевые линии, стрелки и т.п.), структуры (геометрические группы, макроопределения и т.д.). Чтобы
использовать IGES, любая САПР снабжается двумя программами - препроцессором и постпроцессором (рис. 2.2.).</P>

 </Td>
 <Td>&nbsp;&nbsp;</Td>
 <Td>

 <Center><Img src="images/002.png"><P Class=c>Рис. 2.1. Графические стандарты</P></Center>

 </Td></Tr>
</Table><Br>

<Center><Img src="images/003.png"><P Class=c>Рис. 2.2. Связь между двумя различными САПР через формат IGES</P></Center>

<br>
<A Name="#2.3."><P Class=h3>Стандартные графические примитивы</P></A>

<P>Международный стандарт GKS (Grapfical Kernel System) принят в 1985г. и предназначен для обеспечения переносимости и совместимости программных средств машинной графики. Согласно этому стандарту, любое изображение должно строиться из типовых базовых элементов – <I>примитивов вывода</I>
(рис. 2.3.). В GKS определено шесть основных примитивов вывода: полимаркер, полилиния, текст, заполнение области, массив пикселей, обобщенный примитив вывода.</P>

<P><I>Полимаркер</I> используется для указания характерных точек на экране, которые отображаются в виде ярких точек, крестов, квадратов и т. д. <I>Полилиния</I> представляет собой набор отрезков прямых (ломаную), соединяющих заданную последовательность точек. <I>Текст</I> – это строка символов, располагающаяся в указанной позиции. <I>Заполнение области</I> представляет собой многоугольник, заполненный штриховкой, узором или фоновой окраской. <I>Массив пикселей</I> позволяет задать цвет индивидуально для каждой точки некоторой области (пикселя). И, наконец, <I>обобщенный примитив вывода</I> представляет собой стандартное средство определения более сложных элементов (прямоугольник, эллипс и т. д.), вид и количество которых зависят от специфики конкретных графических пакетов.</P>

<Br>

<Center><Img src="images/003a.png"><P Class=c>Рис. 2.3. Основные графические примитивы вывода GKS</P></Center>

<br>
<P>С каждым из примитивов в GKS связан набор параметров – атрибутов, определяющих его геометрические и качественные свойства. Для основных примитивов вывода используются следующие атрибуты:</P>

<Ul>
 <Li>полимаркер - тип маркера, его цвет и масштаб</Li>
 <Li>полилиния - тип, цвет и толщина линии</Li>
 <Li>текст - шрифт, размеры, цвет и ориентация символов</Li>
 <Li>заполнение области - вид штриховки, цвет</Li>
 <Li>массив пикселей - цвет пикселей</Li>
</Ul>

<P>GKS позволяет разделить изображение на отдельные сегменты, которые могут обрабатываться и отображаться независимо друг от друга. Предусмотрены также средства для включения одного сегмента в другой. При создании графической модели объекта и его изображения используются три типа систем координат: глобальная, нормализованная приборная и собственно приборная.</P>

<P>Ввод в GKS определяется как связь с одним из пяти допустимых логических устройств ввода:</P>

<Ul>
 <Li>локатор	выдает положение в глобальной системе координат;</Li>
 <Li>значение	выдает значение числа;</Li>
 <Li>выбор	выдает число, определяющее возможный вариант ответа;</Li>
 <Li>указание	выдает имя сегмента и идентификатор примитива;</Li>
 <Li>строка	обеспечивает ввод строки символов.</Li>
</Ul>

<P>Ввод может происходить в одном из трех режимов: <I>запрос, опрос, событие</I>. Первый из указанных режимов аналогичен операции чтения обычных языков программирования: система ожидает события ввода, после чего передает в программу соответствующее значение. При этом в любой момент допустимо наличие только одного запроса на ввод. Второй режим применяется для ввода от таких устройств, у которых на выходе постоянно существует какое-либо значение (например положение указателя мыши). А третий режим используется для ввода от устройств, инициирующих прерывания. Эти прерывания запоминаются в очереди и обрабатываются в соответствии с принятой дисциплиной обслуживания. Появление GKS в качестве первого международного стандарта оказало существенное влияние на развитие машинной графики и ее применение в САПР.</P>




<Br><Br>




<A Name="#3."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=98% BgColor=#ABB3D5>
 <Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
 <Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif Width="1" Height="1"></Td>
 <Td Valign=Center><span Class=h>3. Принципы построения систем графического моделирования</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br>

<A Name="#3.1."><P Class=h3>Основные этапы процесса проектирования</P></A>

<P>Можно выделить два подхода к конструированию.</P>

<P>Первый подход базируется на двухмерной геометрической модели - <I>графическом изображении</I> (ГИ) и использовании компьютера
как электронного кульмана, позволяющего значительно ускорить процесс конструирования и улучшить качество оформления
конструкторской документации. Центральное место в этом подходе к конструированию занимает чертёж, который служит средством
графического представления изделия, содержащего информацию для решения графических задач, а также для изготовления изделия
(рис. 3.1.).</P>

<Center><Img src="images/004.png"><P Class=c>Рис. 3.1. Схема традиционной технологии конструирования</P></Center>

<P>При таком подходе исходной является следующая постановка вопроса: использование ЭВМ при решении графических задач
должно быть рациональным и достаточно эффективным. Это может быть реализовано при решении задачи: созданное на ЭВМ ГИ
должно использоваться многократно или в различных вариациях, а формирование текстовых документов происходить автоматически
в результате созданных чертежей и схем. Так, с помощью вычислительной техники облегчаются: оформление конструкторских
документов, насыщенных изображениями стандартных, типовых, унифицированных составных частей, например электрических и
других принципиальных, функциональных схем, печатных плат, модулей, приборов, электронных блоков, стоек, шкафов, пультов и
т.д.; модернизация существующих конструкций (частичное изменение, а не создание принципиально нового); разработка
текстовых документов (спецификаций, перечней элементов и др.).</P>

<P>В основе второго подхода лежит компьютерная пространственная геометрическая модель изделия (рис. 3.2.), которая является
более наглядным способом представления оригинала. При этом чертёж играет вспомогательную роль, а методы его создания
основаны на методах компьютерной графики, методах отображения пространственной модели.</P>

<Center><Img src="images/005.png"><P Class=c>Рис. 3.2. Схема современной технологии конструирования</P></Center>

<P>Процесс формирования моделей изделий можно разбить на несколько этапов.</P>

<P>На <I>первом</I> этапе (рис. 3.3.) реальный объект (в примере - деталь) подвергается абстракции, в результате которой
определяется информационная модель.</P>

<P>На <I>втором</I> этапе в информационной модели выделяют уровни структуризации данных и их взаимосвязи, чаще всего с учётом
процессов обработки информации. Таким образом, осуществляются уточнение и структурирование информации с логической точки
зрения. Существенным моментом в этом представлении является то, что оно должно отражать характеристики не одной детали, а
целого класса деталей на различных стадиях проектирования, фиксируемых в технической документации.</P>

<P>При формировании
информационной модели предполагается использование множества конструктивных элементов для получения деталей произвольной
формы, геометрических элементов - точек, контуров, поверхностей, элементарных и сложных объектов, которые обеспечивают
обработку геометрической информации для всех процессов автоматизированного проектирования. Таким образом, строится модель
данных, которая отражает их логическую структуру.</P>

<Center><Img src="images/006.png"><P Class=c>Рис. 3.3. Внутримашинное представление о реальном объекте</P></Center>

<P>На <I>третьем</I> этапе осуществляется процесс преобразования модели данных во внутримашинное представление - формирование
модели доступа. Модель доступа (или размещения) ориентирована на физическое размещение данных в памяти ЭВМ, в модели
хранения.</P>

<P>Таким образом, на <I>четвёртом</I> этапе определяется модель хранения, которая описывает способ организации данных,
сформированных в модели доступа, в физической памяти и управления ими. Существуют три способа записи данных на физические
носители: последовательный, списковый и прямой. В AutoCAD, например, используется списковый способ записи геометрических
данных, что даёт возможность пользователю хранить данные на физических носителях независимо от их логической
последовательности.</P>

<br>
<A Name="#3.2."><P Class=h3>Двухмерные графические системы</P></A>

<P>Двумерные графические системы широко применяются при автоматизации чертёжных работ. Чертежи любой сложности строятся из
базовых графических элементов: точек, прямых, окружностей и других кривых. Каждый из этих элементов задается группой
характерных точек, координаты которых могут определяться в абсолютной (мировой) системе координат или относительно
предыдущей введённой точки (инкрементный ввод). При этом используют несколько способов задания точек:</P>

<Ul>
 <Li>указанием на экране с помощью мыши;</Li>
 <Li>введением чисел с клавиатуры;</Li>
 <Li>"привязкой" к некоторому элементу чертежа, в окрестности которого располагается указатель.</Li>
</Ul>

<P>Первый способ используют в основном для создания эскизов, а второй и третий - для построения точных изображений.
Особенно удобным является третий способ, который позволяет "захватить" ближайший к курсору уже построенный элемент и
ввести точные координаты конца или середины отрезка, центра окружности, точки пересечения прямых и т.д.</P>

<P>В средствах двухмерной графики обычно имеется несколько способов построения одного и того же элемента. Например,
отрезок можно построить по двум точкам либо по начальной точке, длине и углу наклона, а окружность - по центру и радиусу,
по трём точкам, по двум точкам и радиусу и т.д. Кроме того, в таких системах имеется ряд средств, автоматизирующих процесс
черчения. Рассмотрим их подробнее.</P>

<P><B>Автоматическое построение скругления и фаски.</B> Для получения скругления или фаски необходимо указать мышью на
стороны угла и ввести значение радиуса скругления или размер фаски. Отрезки на стыке угла и скругления (фаски)
автоматически "срезаются" (рис. 3.4.).</P>

<Center><Img src="images/007.png"><P Class=c>Рис. 3.4. Автоматическое построение скругления и фаски</P></Center>

<P><B>Автоматическая штриховка и закраска.</B> Для получения штриховки надо ввести угол и шаг штриховки, а затем указать
мышью на внутреннюю часть области, которую надо заштриховать. Аналогично выполняется и закраска (рис. 3.5.).</P>
 
<Center><Img src="images/008.png"><P Class=c>Рис. 3.5. Автоматическая штриховка</P></Center>

<P><B>Автоматическая простановка размеров.</B> Для простановки размера необходимо указать образмериваемые элементы и точку
уровня размерной линии. После этого система автоматически вычислит числовое значение размера, выведет его на экране и
нарисует выносные и размерные линии (рис. 3.6.).</P>

<Center><Img src="images/009.png"><P Class=c>Рис. 3.6. Автоматическая простановка размеров</P></Center> 

<P>На любом этапе выполнения компьютерного чертежа можно удалить и модифицировать графические элементы изображения. Обычно
двухмерные САПР позволяют выполнять следующие операции редактирования.</P>

<P><B>Отсечение.</B> Эта процедура позволяет удалить лишние вспомогательные линии на чертеже. Например, после указания
мышью на секущую прямую и окружность из чертежа удаляется сегмент окружности. Такая же процедура может быть выполнена для
любой комбинации графических элементов (рис. 3.7.).</P>

<Center><Img src="images/010.png"><P Class=c>Рис. 3.7. Отсечение</P></Center> 
 
<P><B>"Резиновое" растяжение.</B> Процедура растяжения позволяет пользователю растягивать или сжимать изображенные на
экране формы. Можно, в частности, с помощью мыши переместить любую из вершин ломаной. При этом в процессе редактирования
перемещаемая вершина соединяется с соседними при помощи пунктирных ("резиновых") линий, и сразу же после отпускания кнопки
мыши пунктирные линии заменяются сплошными (рис. 3.8.).</P>

<Center><Img src="images/011.png"><P Class=c>Рис. 3.8. "Резиновое" растяжение</P></Center> 

<P><B>Вспомогательная сетка.</B> Для получения изображения с регулярной структурой удобно использовать сетку, которая не
является частью чертежа и предназначена для визуальной координации. В таком режиме осуществляется автоматический "захват"
ближайшего узла и от конструктора не требуется очень точного указания точки. В результате можно легко ввести точки с
заданным шагом. На печать изображение сетки не выводится (рис. 3.9.).</P>

<Center><Img src="images/012.png"><P Class=c>Рис. 3.9. Привязка к узлам сетки</P></Center> 

<P><B>Создание сплайнов.</B> В большинстве двухмерных пакетов имеются средства для автоматической генерации гладких кривых
(сплайнов), проходящих через заданные точки. Такие процедуры очень удобны при создании нестандартных геометрических форм и
позволяют дополнить автоматизированное черчение элементами автоматизированного проектирования (рис. 3.10.).</P>

<Center><Img src="images/013.png"><P Class=c>Рис. 3.10. Построение сплайна</P></Center> 

<P><B>Увеличение и панорамирование.</B> Средства увеличения позволяют увеличить или уменьшить любую область чертежа для
более детального просмотра или редактирования. Чтобы проанализировать другие элементы чертежа, область просмотра может
быть панорамирована (сдвинута) в любом направлении, что позволяет использовать один сборочный чертеж для изделий любого
размера и сложности, отказавшись от множества небольших чертежей, как принято в традиционном черчении. При необходимости
можно получить твёрдую копию любой области чертежа (рис. 3.11.).</P>

<Center><Img src="images/014.png"><P Class=c>Рис. 3.11. Увеличение и панорамирование</P></Center> 

<P><B>Копирование, поворот и перенос.</B> Любой элемент изображения или группу элементов можно скопировать, переместить
и/или повернуть. Для двухмерного поворота достаточно задать положение центра вращения и угол поворота. При переносе обычно
вводятся две точки, определяющие вектор смещения. Перенос и поворот, а также копирование широко применяются при вставке в
чертёж стандартных элементов, вызываемых из стандартных библиотек (рис. 3.12.).</P>

<Center><Img src="images/015.png"><P Class=c>Рис. 3.12. Копирование (а), параллельный перенос (б) и поворот (в)</P></Center> 

<P><B>Преобразования.</B> Кроме поворота и переноса многие графические пакеты имеют и более сложные средства
манипулирования изображением: зеркальное отражение и пошаговое размножение. Используя эти средства, очень удобно строить
чертежи регулярных структур. Например, для создания чертежа зубчатой рейки достаточно построить половину профиля одного
из зубьев, далее применить операцию зеркального отражения, а затем размножить полученный образ. Можно также провести
масштабирование изображения (рис. 3.13.).</P>

<P><B>Выбор элементов и объединение их в группы.</B> В большинстве графических пакетов операции редактирования могут
выполняться как над отдельным элементом, так и над группой элементов. Например, для сдвига части чертежа нет
необходимости перемещать все элементы по отдельности. Вместо этого достаточно "выбрать" их путем указания на каждый из
элементов либо осуществить "окнирование" (выделение на чертеже прямоугольной области, все элементы которой выбираются
автоматически). В дальнейшем операции редактирования производятся одновременно над всеми элементами полученного набора.
Можно, например, изменить цвет и тип линий всех элементов, произвести масштабирование и т.д.</P>

<P>Иногда удобнее объединить выбранные элементы в группы (<B>блоки</B>). В результате получается составной графический
элемент, который при редактировании рассматривается как единое целое. В группы можно объединять и составные элементы,
образуя многоуровневые иерархические структуры. При необходимости можно выполнить и обратную операцию - разделить
составной элемент на отдельные составляющие.</P>

<Center><Img src="images/016.png"><P Class=c>Рис. 3.13. Зеркальное отражение (а), размножение (б) и масштабирование (в)</P></Center> 

<P><B>Расслоение.</B> Во многих двухмерных САПР реализован принцип "расслоения", позволяющий разделить чертеж на несколько
частей, наложенных друг на друга. С точки зрения традиционного черчения, это эквивалентно созданию нескольких чертежей,
каждый из которых выполнен на прозрачной пластине. Причем можно рассматривать каждую пластину по отдельности либо,
складывая их, получать совместное изображение. При выполнении чертежей механических конструкций можно, например,
разместить все геометрические элементы в одном слое, а все размеры и пояснительные надписи - в другом.</P>

<P>Двумерные системы позволяют построить упрощённые геометрические модели реальных физических объектов, состоящие из трёх независимых проекций (видов).
При их использовании модель куба, например, задаётся 12 двухмерными точками с координатами XY, поэтому при внесении изменений конструктор должен
редактировать отдельно каждую из проекций.</P><Br>


<A Name="#3.3."><P Class=h3>Трёхмерные графические системы</P></A>

<P>В трёхмерных системах используются точки с тремя координатами, что позволяет автоматически устанавливать проекционные
связи. Так, в этом случае куб описывается восемью трёхмерными точками <I>XYZ</I>, по которым находятся проекции <I>XY</I>,
<I>YZ</I> и <I>XZ</I>. При использовании таких систем обычно начинают с построения трёхмерного изображения, а двумерные
виды формируются на последнем этапе, при выводе чертежей. Иногда двумерные чертежи полностью заменяются трёхмерной
компьютерной моделью, по которой генерируются программы для станков с ЧПУ.</P>

<P>Системы трёхмерного моделирования широко применяются в интегрированных САПР/АСТПП. Они часто дополняются средствами
автоматического анализа физических характеристик (вычисление массы, центра масс, моментов и тензоров инерции и др.), а
также модулями, обеспечивающими оценку прочности и технологичности.</P>

<P>Методы трёхмерного моделирования, используемые в САПР, делятся на три группы: каркасное, поверхностное и твердотельное
(сплошное) моделирование (рис. 3.14.).</P>

<Center><Table>
<Tr><Td><Img src="images/017a.png">&nbsp;</Td><Td><Img src="images/017b.png">&nbsp;</Td><Td><Img src="images/017c.png"></Td></Tr>
<Tr><Td><P Class=c>a</P></Td><Td><P Class=c>б</P></Td><Td><P Class=c>в</P></Td></Tr>
</Table>

<P Class=c>Рис. 3.14. Геометрические модели трёхмерных объектов:<Br>
а - каркасная (Wire-frame); б - поверхностная (Surface); в - твердотельная (Solid)</P></Center> 

<P><B>Каркасное моделирование</B> (рис. 3.14, а). Модель каркасного типа полностью описывается в терминах точек и линий. Её главным достоинством являются
простота и невысокие требования к компьютерной памяти, а недостатки связаны с отсутствием информации о гранях, заключенных между линиями, и с
невозможностью различить внешнюю (незаполненную) и внутреннюю (заполненную) области. Наиболее широко каркасное моделирование применяется при имитации
несложного пространственного движения инструмента (например, при фрезеровании по трём осям).</P>

<P>При использовании каркасных моделей в САПР необходимо учитывать следующие ограничения:</P>

<Ul>
 <Li><I>неоднозначность</I> - отсутствие возможности однозначно оценить ориентацию и видимость граней, что не позволяет различать виды сверху и снизу, а
  также автоматизировать удаление скрытых линий;</Li>
 <Li><I>приближённое представление криволинейных граней</I> - невозможность точно описать криволинейные поверхности (цилиндры, конусы и др.), которые
  реально не имеют рёбер; иногда для таких поверхностей вводят фиктивные рёбра, располагаемые через регулярные интервалы (рис. 3.15.);</Li>
 <Li><I>невозможность обнаружить столкновения</I> - отсутствие информации о поверхностях, ограничивающих форму, не позволяет обнаружить столкновения между
  объектами, что важно при моделировании роботов, проектировании планов размещения оборудования и т.д.;</Li>
 <Li><I>погрешности оценки физических характеристик</I> - возможность некорректного вычисления массы, центра тяжести, момента инерции и т.д.,
  обусловленная недостатком информации об ограничивающих поверхностях;</Li>
 <Li><I>отсутствие средств "затенения" поверхностей</I> - у модели, состоящей только из рёбер, невозможно произвести закраску поверхностей различными
  цветами.</Li>
</Ul>

<Center><Img src="images/018.png"><P Class=c>Рис. 3.15. Приближённое представление криволинейных поверхностей<Br>
в каркасных моделях (вводятся фиктивные рёбра)</P></Center> 

<P><B>Поверхностное моделирование</B> (Модель поверхностного типа (рис. 3.14, б) задается в терминах точек, линий и поверхностей. В отличие от каркасной модели она обеспечивает:</B>

<Ul>
 <Li>точное представление криволинейных граней;</Li>
 <Li>автоматическое распознавание граней и их закраску;</Li>
 <Li>автоматическое удаление невидимых линий (рис. 3.16.);</Li>
 <Li>распознавание особых линий на гранях (отверстий и т. д.);</Li>
 <Li>обнаружение столкновений между объектами.</Li>
</Ul>

<Center><Img src="images/019.png"><P Class=c>Рис. 3.16. Удаление невидимых линий при поверхностном моделировании</P></Center> 

<P>Метод поверхностного моделирования наиболее эффективен при проектировании и изготовлении сложных криволинейных поверхностей (корпусов автомобилей и
др.). При этом можно использовать:</P>

<Ul>
 <Li><I>базовые геометрические поверхности</I> (плоскости, цилиндры, кубы, результат перемещения образующей кривой в заданном направлении и т.д., - рис. 3.17., а);
 <Li><I>поверхности вращения</I> (результат вращения линии вокруг оси,  - рис. 3.17., б);
 <Li><I>пересечения и сопряжения поверхностей</I>;
 <Li><I>аналитические поверхности</I> (задаются математическим уравнением);
 <Li><I>скульптурные поверхности или поверхности "свободных форм"</I>, которые не могут быть описаны одним математическим уравнением, а задаются при помощи
  методов сплайн-интерполяции образующих кривых (корпуса автомобилей, фюзеляжи самолетов, лопатки турбин), - рис. 3.17., в; 3.18.
</Ul>

<Center><Table>
<Tr><Td><Img src="images/020a.png"></Td><Td><Img src="images/020b.png"></Td><Td><Img src="images/020c.png"></Td></Tr>
<Tr><Td><P Class=c>a</P></Td><Td><P Class=c>б</P></Td><Td><P Class=c>в</P></Td></Tr>
</Table>

<P Class=c>Рис. 3.17. Поверхностные модели, полученные путём перемещения кривой в заданном направлении (а), вращения кривой
(б) и при помощи сплайн-интерполяции (в)</P></Center> 

<P>В современных трёхмерных системах широко используются <I>составные поверхности</I>, составленные из криволинейных
четырёхугольников, ограниченных гладкими кривыми. Внутренняя область каждого такого участка определяется путём
интерполяции. При изображении составных поверхностей на экране создается сетка, натянутая на многогранный каркас.</P>

<Center><Img src="images/021_1.png"><Br><Img src="images/021_2.png">
<P Class=c>Рис. 21. Поверхностная модель элемента кузова автомобиля</P></Center>
 
<P>На базе методов поверхностного моделирования построен ряд мощных графических систем, широко применяемых в промышленности. Однако поверхностные модели
имеют ряд недостатков, которые могут быть устранены только в рамках твердотельного моделирования. К ним относятся:</P>

<Ul>
 <Li><I>неоднозначность</I> при моделировании реальных твёрдых тел;</Li>
 <Li><I>сложность</I> процедур удаления невидимых линий и отображения внутренних областей.</Li>
</Ul>

<P><B>Твердотельное моделирование</B> (рис. 3.14., в). Модель твердотельного типа описывает трёхмерный объём, который
занимает рассматриваемое физическое тело. Внутреннее представление твердотельной геометрической модели выражается его
границами (например, гранями, рёбрами и вершинами). В этом случае используются данные трёх типов: <I>геометрические</I>
(координаты вершин, описанные аналитически, рёбра и поверхности, описанные уравнениями); <I>топологические</I>, позволяющие с
помощью понятий <I>"внутри / вне"</I> определить топологию объекта; <I>вспомогательные</I> - например, цвет, степень прозрачности.</P>

<P>В отличие от каркасных и поверхностных твердотельная модель обеспечивает:</P>

<Ul>
 <Li><I>полное описание заполненного объема</I> и возможность разграничения внешних и внутренних областей, на основе чего
  автоматизируется процесс обнаружения столкновении;
 <Li>автоматизацию процесса <I>удаления скрытых линий</I>;
 <Li>автоматизацию процесса <I>построения разрезов и сечений</I>, что требуется при создании сборочных чертежей сложных изделий;
 <Li>применение <I>современных методов анализа</I> конструкций (точное вычисление массы и габаритов, расчёт прочности и
  деформаций методом конечных элементов и т. д.);
 <Li>эффективное <I>управление цветами и источником освещения</I>, получение тоновых изображений;
 <Li>более точное моделирование кинематики и динамики многозвенных механизмов (роботов, станков и т. д.).
</Ul>

<P>Объёмные тела, образованные из более простых объектов, называются <I>составными</I> графическими объектами. При этом
используются логические операции объединения, пересечения, вычитания. Операция сборки составных графических объектов
осуществляется с использованием их представления в виде иерархической структуры в форме <I>дерева построения</I>.<P>
<P>Существует
целый ряд способов построения твердотельных моделей, однако в САПР наибольшее распространение получили два из них: метод
конструктивного представления (C-Rep) и метод граничного представления (B-Rep).</P>

<P><I>Метод конструктивного представления</I> (C-Rep) основан на создании моделей из типовых твердотельных примитивов с заданными размерами, ориентацией и точкой привязки. При определении взаимоотношений между соседними примитивами используются булевы операции: «объединение», «разность» и «пересечение». Твердотельные примитивы могут выбираться из библиотеки или генерироваться путем движения произвольной поверхности вдоль некоторой кривой. В результате происходит «захват» (sweeping) части трехмерного пространства, принадлежащей примитиву.</P>

<P><I>Метод граничного представления</I> (B-Rep) также оперирует с примитивами, связанными при помощи булевых операций. При этом модель описывается совокупностью ребер и граней, определяющих граничную поверхность твердого тела. Эти данные дополняются информацией о топологии примитива и особенностях его геометрии. Метод B-Rep более удобен при модификации примитивов, но требует большего объема компьютерной памяти.</P>

<P>Методы твердотельного моделирования, основанные на булевых операциях, особенно удобны при вычислении поверхностных и весовых параметров тел, расчете напряжений, имитации операций механической обработки. В последнем случае операции резания металла (точение, фрезерование, сверление и т. п.) могут быть легко описаны при помощи булевой разности. Естественным приложением булевой алгебры является также анализ столкновений (коллизий), которые обнаруживаются при помощи операции пересечения.</P>

<Br><Br>



<A Name="#4."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=98% BgColor=#ABB3D5>
 <Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
 <Tr><Td Width=30><Img Src=raspor.gif Width="1" Height="1"></Td>
 <Td Valign=Center><span Class=h>4. Системы геометрического моделирования</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br>


 <Br>
<A Name="#4.1."><P Class=h3>DUCT</P></A>

<P>Концепция этой системы была разработана в конце 60-х г. XX в. на инженерном факультете Кембриджского университета. Ее промышленный вариант распространяется с 1983г. фирмой DELCAM (Delta Computer-Aided Manufacturing). Система DUCT позволяет конструктору создавать трехмерные каркасные и поверхностные модели объектов, визуализировать их на экране монитора, а также вычислять площадь поверхности, объем, координаты центра тяжести объекта и генерировать сетку конечных элементов для анализа потоков и расчетов на прочность.</P>

<P>При помощи системы DUCT автоматизированы процессы создания литейных форм и штампов, подготовки чертежей изделий и программ для станков с ЧПУ. При этом учитываются припуски на толщину стенок, усадки, зазоры при механической обработке.</P>

<P>Встроенный в DUCT каркасный редактор позволяет быстро и просто задать форму объекта. Поверхности создаются на основе поперечных сечений, определяемых набором точек. Эти сечения могут размещаться и ориентироваться относительно заранее построенной кривой (спина), играющей роль «хребта», вдоль которого вытянута поверхность. Для интерполяции поперечных сечений по заданным точкам используются кривые Безье.</P>

<P>При генерации поверхности, состоящей из отдельных элементов (лоскутов), имеется возможность задавать границы в виде сложных кривых. При этом автоматически обеспечивается гладкость в местах сопряжений лоскутов. Можно выполнить скругление угла, образованного двумя или тремя поверхностями, причем радиус скругления может быть как постоянным, так и переменным. Из набора поверхностей можно создать единый объект в виде оболочки, соединяющей в себе преимущества твердотельного и поверхностного моделирования. При визуализации объекта, используя несколько цветов и различные источники света, генерируется цветное изображение. Если позволяет производительность компьютера, формируются цветные динамические модели.</P>

<P>Ядро системы DUCT составляет реляционная база данных, в которой хранится вся информация о деталях и чертежах. При этом информация может располагаться в любой из объединенных в сеть рабочих станций. Имеется возможность создавать параметрические чертежи. Система также имеет библиотеку типовых деталей и интерфейсы с языком Си.</P>

<P>Графический интерфейс пользователя включает в себя набор многоуровневых меню, отображающих на экране списки параметров выбранной команды. Пользователь может также создавать свои собственные меню и прикладные программы. Для этого в системе имеется специальный командный язык.</P>

<P>Система DUCT предоставляет пользователю широкий набор методов механической обработки. При фрезеровании можно задать форму инструмента или выбрать из библиотеки различные фрезы: шаровую, торцевую, либо торцевую со скругленными кромками. При этом осуществляется проверка на минимальный радиус кривизны поверхности. Недоступные области высвечиваются на экране и затем могут быть обработаны инструментом меньшего радиуса. Для этого следует задать направление резания, скорость подачи и скорость вращения шпинделя, припуск для черновой обработки. Траектория движения инструмента генерируется, визуализируется на экране вместе с изображением инструмента и при необходимости корректируется. Система DUCT позволяет осуществлять 2,5-, 3- и 5-координатное фрезерование, токарную обработку и 4-координатную электроэрозионную обработку.</P>

<P>DUCT может функционировать на стандартных рабочих станциях с операционной системой UNIX. Программное обеспечение построено по модульному принципу. К числу основных модулей относятся DUCTmodel, Advanced model, DUCTshade, DUCTnc, DUCTdraft и др. Для передачи данных используются стандарты IGES, VDA-FS и DXF. Имеются также прямые интерфейсы с системами PDGS и CADDS.</P>

 <Br>
<A Name="#4.2."><P Class=h3>Система CATIA</P></A>

<P>Система CATIA, разработанная французской фирмой Dassault Systemes, появилась на мировом рынке САПР в 1981 г. Первоначально она предназначалась для самолетостроения, но постепенно нашла применение в автомобильной и других отраслях промышленности. В настоящее время система CATIA распространяется фирмой IBM и активно используется такими фирмами, как Boeing, Chrysler, ГАЗ и ВАЗ. Большинство пользователей системы CATIA использует рабочие станции IBM, но систему можно также установить на мэйнфреймах, UNIX-станциях RISC/6000 и рабочих станциях фирм Hewlett-Packard и Silicon Graphics.</P>
<Center><Img Src=images/catia_1.png><Br>
<P>Система имеет программные модули для автоматизированного проектирования в следующих областях:</P>

<Ul>
<Li>конструирование механизмов и узлов (Mechanical Design);
<Li>формообразование поверхностей и дизайна (Shape Design and Styling);
<Li>анализ и моделирование (Analysis and Simulation);
<Li>подготовка производства (Manufacturing);
<Li>инженерные расчеты (Equipment and System Engineering).
</Ul>

<P>Система CATIA обладает одной из самых совершенных методик проектирования поверхностей (модули Surface Design, Advanced Surface Design, FreeForm Design) и анализа их качества по кривизне, гладкости, непрерывности в областях сопряжения и т. д. При необходимости поверхностные модели могут быть преобразованы в твердотельные. Сложные кривые строятся на базе кривых Безье. Поверхности, которые нельзя описать стандартными типами элементов, могут быть аппроксимированы точками с заданными координатами, по которым строятся бипараметрические полиномиальные функции.</P>

<P>В рамках системы CATIA можно использовать целый ряд приложений, входящих в «архитектуру прикладных программ» (САА – CATIA Application Architecture). Они позволяют выполнить динамический анализ механизмов (CATDADS), моделирование роботизированных комплексов (Robuse), подгото-вить постпроцессоры и программы для станков с ЧПУ, создать проекты трубопроводов и пневмосистем (3D-Tubing), а также создать фотореалистические изображения (Visualisation Studio). В результате сотрудничества IBM с фирмой BMW создан уникальный модуль проверки собираемости изделия (Fitting Simulation), который моделирует весь процесс сборки изделия с учетом доступности, способов установки и используемой оснастки. Этот же модуль позволяет оценить возможность съёма узла для ремонта или обслуживания.</P>

<P>К числу существенных достоинств системы CATIA относятся совершенная схема построения параметрически связанных моделей и возможность постпараметризации. Конструктор может начать построение модели, руководствуясь лишь функциональностью и технологичностью, не занимаясь на первом этапе параметризацией. Далее, на любом этапе, можно определить параметры и связи между ними, при этом допускается задать лишь наиболее существенные параметры, а остальные оставить по умолчанию. При изменении параметров конструктор может позволить ассоциативно распространить изменения на все объекты либо ограничить изменения некоторой зоной (т.е. определить некоторые параметры как локальные). На любом этапе можно принять решение о разрыве связи. Система CATIA также позволяет рассчитать трехмерные допуски (Functional DIMENSIONING and 3D-Tolerancing), размерные цепи любой сложности и оптимальные допуски, промоделировать поведение механизмов при варьировании размеров деталей.</P>

<Center><Img Src=images/catia_2.png><Br>

<P>Новым нетрадиционным средством системы CATIA, не характерным для других САПР, является «проектирование при помощи правил», реализующее по существу, концепцию конструктивно-технологической базы знаний. Оно позволяет конструктору определить свои собственные правила проектирования и использовать их в повседневной работе. Например, при проектировании гидро- и пневмосистем можно определить шаг расстановки крепежа, допустимые и запретные зоны расположения, зоны безопасного расстояния от элементов конструкции, материалы и т. д.</P>

<P>При помощи системы CATIA можно автоматизировать и некоторые процессы управления предприятием (финансами, складским хозяйством, кадрами и т. д.). Для этого используются коммерческие сетевые реляционные базы данных (Oracle, DB2) и интерфейсы с наиболее распространенными системами управления предприятиями (R3, Triton).</P>

 <Br>
<A Name="#4.3."><P Class=h3>Системы фирмы Autodesk</P></A>

<P>Наиболее распространенным и известным программным продуктом фирмы Autodesk является пакет AutoCAD, первые версии которого были ориентированы на двумерное черчение и выпуск конструкторской документации. В процессе совершенствования этот пакет превратился в развитую среду трехмерного моделирования проектов в архитектуре, строительстве, машиностроении, картографии и других отраслях. Последние версии пакета AutoCAD могут выполняться как на ПК под управлением Windows, так и на UNIX-платформах (Silicon Graphics, Hewlett-Packard, Sun SPARC-Station, IBM R/6000). Ядро системы написано на языке C++ и представляет собой объектно-ориентированную среду, являющуюся основой для множества прикладных программ, создаваемых как самой фирмой Autodesk, так и ее партнерами. Их число уже превысило 5000.</P>

<Center><Img Src=images/auto_1.png><Br>



<P>Для машиностроения фирмой Autodesk разработан интегрированный пакет Autodesk Mechanical Desktop (AMD), в который входят практически все необходимые инженеру-конструктору средства моделирования геометрических объектов. Он объединяет в себе возможности известных программных продуктов Autodesk:</P>

<P>Система имеет программные модули для автоматизированного проектирования в следующих областях:</P>

<Ul>
<Li>AutoCAD – в качестве графической среды;
<Li>AutoCAD Designer – для конструирования деталей и сборочных узлов;
<Li>AutoSurf – для моделирования сложных NURBS-поверхностей;
<Li>IGES Translator – для обмена файлами с другими системами САПР;
<Li>MCAD – система меню для организации взаимодействия с другими машиностроительными приложениями.
</Ul>

<P>Модуль AutoCAD Designer позволяет автоматизировать процесс создания рабочих чертежей деталей и сборочных единиц. Он дает возможность пользователю оперировать с привычными конструкторско-технологическими элементами (сопряжение, фаска, отверстие и т. д.). В нем реализован принцип параметрического моделирования, что позволяет довольно гибко вносить изменения на любой стадии проектирования.</P>

<P>Процесс создания трехмерных моделей в AutoCAD Designer происходит в два этапа: сначала задается плоский эскиз детали, а затем ему придается третье измерение. При конструировании сборочной единицы пользователю достаточно задать параметрические связи между существующими объектами, ограничивая число степеней свободы проектируемой механической системы. Для разработанных моделей автоматически генерируются двухмерные проекции (виды), причем постоянно действует двунаправленная параметрическая связь модель-чертеж. Возможности параметрического черчения позволяют вносить изменения как на самой трехмерной модели, так и на ее двумерных видах путем корректировки отдельных размеров. В модуле также имеются встроенные функции, обнаруживающие взаимное пересечение деталей в сборочных единицах.</P>

<P>Модуль AutoSurf обеспечивает построение и редактирование формо-образующих кривых и сложных поверхностей, построение на их основе новых объектов, создание каркасных (проволочных) моделей, проецирование различных контуров на плоскость или поверхность. В этом модуле реализована NURBS-технология, основанная на наиболее эффективных методах работы с произвольными поверхностями, которые описываются неоднородными рациональными В-сплайнами. Поэтому AutoSurf получил широкое распространение в автомобильной и аэрокосмической промышленности.</P>

<P>IGES-транслятор используется для корректного обмена графическими моделями с другими системами CAD/CAM/CAE. Например, dwg-файлы формата AutoCAD после обработки в AutoSurf могут передаваться в другие системы, осуществляющие расчеты прочности, генерации программ
для ЧПУ и т.д.</P>

<P>Как показывает опыт, наибольший эффект при проектировании машиностроительных конструкций может быть достигнут только при совместном использовании модулей AutoCAD Designer и AutoSurf, когда некоторые трудности моделирования поверхностей произвольной формы в AutoCAD Designer устраняются средствами AutoSurf, а проблемы построения проекционных видов в AutoSurf решаются за счет средств AutoCAD Designer. Объединение этих двух программ не только обеспечивает двусторонний обмен данными на основе формата AutoCAD (dwg-файлы), но и позволяет по-новому организовать доступ к основным функциям AMD. В этом пакете выделены четыре основных функциональных модуля:</P>

<P>1) параметрического твердотельного моделирования;</P>

<P>2) параметрического моделирования сборочных единиц;</P>

<P>3) моделирования поверхностей произвольной формы;</P>

<P>4) генерирования двухмерных чертежей.</P>

<Center><Img Src=images/auto_2.bmp><Br>

<P>Первые два модуля являются составными частями программы AutoCAD Designer, третий модуль включает основные функции AutoSurf, a четвертый представляет собой универсальный инструмент, применимый как для стандартных трехмерных объектов AutoCAD, так и для комбинаций разнородных трехмерных объектов.</P>

<P>При создании плоского эскиза изделия используются стандартные для AutoCAD команды рисования и редактирования двухмерных объектов. Затем устанавливаются зависимости на горизонтальность, вертикальность, параллельность, перпендикулярность, коллинеарность, концентричность, проекции, касания, равенство радиусов и координаты X и Y. При этом от конструктора не требуется соблюдения большой точности в отношении размеров, параллельности или перпендикулярности. Поэтому в отличие от стандартных приемов AutoCAD здесь не используются режимы «шаг», «сетка», а также функции объектной привязки. Эскиз создается концептуально.</P>

<P>Далее выполняется профилирование эскиза, в процессе которого на модель накладываются геометрические связи и почти горизонтальные линии становятся строго горизонтальными, почти замкнутые – замкнутыми и т. д. При этом программа выдает сообщение о том, сколько связей или размеров требуется, чтобы однозначно определить профиль.</P>

<P>Для простановки параметрических размеров используется единая команда, которая в зависимости от заданных примитивов автоматически определяет тип размера (линейный, угловой, радиальный и т.д.). Этим размерам соответствуют свои переменные, которые могут использоваться в математических формулах, что обеспечивает формирование изображения детали при помощи таблицы. Если требуется указать размер, зависящий от размера других деталей, используются глобальные переменные.</P>

<P>Геометрия эскиза может быть любой сложности, но в нем должен быть один замкнутый контур. Он используется в дальнейшем при построении третьего измерения или создании так называемой базовой формы одним из следующих способов: выдавливание, вращение, перемещение вдоль двухмерной криволинейной направляющей, сдвиг плоского эскизного контура, а также путем отсечения фрагментов от твердотельных объектов произвольными поверхностями. Далее к базовой форме добавляются стандартные конструкторско-технологические элементы: отверстия (в том числе с зенковкой, разверткой и резьбовые), фаски, сопряжения (галтели) или элементы произвольной формы.</P>

<P>Следует учитывать, что базовая форма представляет собой твердое тело и формообразование в AutoCAD Designer осуществляется при помощи булевых операций над пространственными множествами (объединение, вычитание и пересечение). Например, добавление отверстия к модели сводится к вычитанию объема, а при задании фасок может выполняться как вычитание, так и объединение.</P>

<P>AutoCAD Designer реализует функцию параметризации как на уровне отдельной модели, так и сборочной единицы. Поэтому процесс сборки почти полностью автоматизирован: пользователь должен только задать связи, ограничивающие число степеней подвижности, а программа сама генерирует сборочные чертежи и спецификации. При этом сборочная единица представляется в виде иерархической структуры, в которой строго заданы как взаимосвязи отдельных компонент, так и последовательность процесса сборки.</P>

<P>Процесс моделирования сборочных единиц в AutoCAD Designer состоит из следующих этапов:</P>

<Ul>
<Li>определение компонентов сборочной единицы;
<Li>вставка компонентов в сборочную единицу;
<Li>наложение и редактирование связей между компонентами;
<Li>сборка компонентов и анализ сборочной единицы;
<Li>создание сборочного чертежа.
</Ul>

<P>Чтобы начать процесс сборки, все компоненты необходимо явно определить как доступные для сборки («материализовать»). Вставка компонентов в рабочее пространство AMD подобна вставке блоков в AutoCAD, причем один и тот же компонент (деталь) может быть использован неоднократно. Детали и подузлы представлены в виде иерархической структуры сборочного узла. Конструктор должен строго придерживаться определенной последовательности сборки, вводя сначала «базовые» компоненты, а затем «присоединяемые» к ним. При этом не требуется внимательно следить за взаимной ориентацией и положением собираемых деталей, так как в дальнейшем они скорректируются автоматически за счет введения параметрических связей. Возможно свободно-координатное расположение деталей, которое задается относительно друг друга по их ребрам, осям или граням, а степени свободы компонентов отображаются графически.</P>

<P>Окончательная сборка изделия осуществляется путем определения связей, определяющих взаимное расположение компонентов:</P>

<Ul>
<Li><I>Insert</I> (вставить соосно) – задаются цилиндрические поверхности, которые получат общую ось, расстояние между ними и направление соединения;
<Li><I>Mate</I> (встык) – задаются сопрягаемые поверхности, линии или точки двух компонентов, а также расстояние между ними (отступ);
<Li><I>Flush</I> (заподлицо) – задаются грани двух компонентов, нормали к которым ориентируются параллельно в одном направлении;
<Li><I>Angle</I> (угловая зависимость) – нормали указанных граней пары компонентов ориентируются под заданным углом;
<Li><I>Oppose</I> (под углом в противоположных направлениях) – нормали указанных граней пары компонентов ориентируются в противоположных направлениях под заданным углом.
</Ul>

<P>После задания типа связи необходимо указать компоненты, к которым применяется заданная связь; затем компоненты перестраиваются на экране автоматически с учетом введенных связей, имитируя процесс сборки.</P>

<P>После сборки изделия производится расчет массоинерционных характеристик, площади поверхности, массы и объема деталей и сборочных узлов, моментов инерции и анализ взаимодействия деталей в сборочных узлах.</P>

<P>При генерации сборочных чертежей пользователь может задать любую совокупность проекционных видов и разрезов сборочной единицы, позволя-ющих уяснить взаимное расположение компонентов. При этом устанавливается двунаправленная ассоциативная связь между моделью и ее чертежом, автоматически удаляются штриховые и невидимые линии, наносятся размеры и выноски. Кроме того, возможно построение изометрических проекций в так называемом разобранном виде (exploded view), что удобно при подготовке руководств по сборке и эксплуатации. В AMD имеются также средства простановки номеров позиций на сборочных чертежах и автоматического заполнения спецификаций, форма которых определяется пользователем. Спецификация, соответствующая стандартам ANSI, ISO, DIN, JIS и ЕСКД, может размещаться в поле чертежа или выводиться во внешний файл.</P>

<P>Средствами AutoSurf осуществляется моделирование как примитивных поверхностей (конус, шар, цилиндр), так и сложных поверхностей произвольной формы (трубчатых, поверхностей натяжения, изгиба, перехода), а также плавное сопряжение произвольных поверхностей. Во внутреннем формате AutoSurf контуры и оболочки точно описываются математическими уравнениями, однако при выводе на экран поверхности преобразуются в каркасы, что существенно сокращает время регенерации изображения. Кроме того, в AutoSurf каркасы используются как исходные данные при построении поверхностей сложной формы. Имеются функции вычисления площади поверхности и объема. Всего в AutoSurf существуют четыре типа поверхностей:</P>

<P>1) элементарные;</P>

<P>2) вращения (получаемые перемещением элементов каркаса);</P>

<P>3) движения (получаемые натяжением оболочки на каркас);</P>

<P>4) производные (получаемые из существующих).</P>

<P>Для их построения можно использовать 16 различных способов, применяя разные типы каркасных элементов: сплайны, полилинии, дуги, окружности, эллипсы, линии с векторами вращения. Но несмотря на разнообразие методов построения, внутренний формат представления всех без исключения поверхностей основан на одном и том же математическом аппарате – аппарате неоднородных рациональных В-сплайнов (NURBS). Поверхности AutoSurf могут быть представлены на экране либо в тонированном виде, либо в виде каркаса, который является лишь вспомогательным средством отображения. Для тонирования трехмерных моделей и создания фотореалистических изображений в стандартную поставку пакета AutoCAD включен модуль AutoVision.</P>

<Br>
<A Name="#4.4."><P Class=h3>Система I-DEAS</P></A>

<P>Торговая марка I-DEAS объединяет целый ряд программных продуктов, которые можно рассматривать как интегрированный комплекс CAD/CAM/CAE. Эти программные средства созданы фирмой SDRC (Structural Dynamics Research Corporation) и предназначены для автоматизации разработки металлических конструкций в аэрокосмической, автомобильной и других отраслях промышленности. Отличительными особенностями I-DEAS являются возможность распределения пользовательских лицензий по неоднородным локальным сетям, которые содержат рабочие станции разных производителей (HP, IBM, SUN и др.), а также наличие встроенных средств конечно-элементного моделирования, оптимизации и автоматизации испытаний.</P>

<P>Типовой набор модулей I-DEAS для решения задач проектирования металлоконструкций (Product Design Package) включает в себя следующие модули:</P>

<Ul>
<Li>I-DEAS Master Modeler – базовый модуль трехмерного моделирования (проволочного, поверхностного, твердотельного);
<Li>I-DEAS Master Surfacing – модуль трехмерного моделирования деталей со сложными “скульптурными” поверхностями;
<Li>I-DEAS Master Assembly – модуль для трехмерного моделирования сборочных узлов и простейших механизмов;
<Li>I-DEAS Drafting – модуль создания чертежей изделия;
<Li>I-DEAS Data Translation – модуль преобразования форматов графических данных.
</Ul>

<P>При помощи модуля I-DEAS Master Modeler создается твердотельная геометрическая модель, которая используется в качестве исходной в большинстве других задач (при прочностном анализе, черчении, подготовке программ для ЧПУ и т.д.). В нем реализована NURBS-геометрия, а также «параллельная ассоциативность», поддерживающая групповую работу нескольких конструкторов. Кроме того, «история» процесса проектирования запоминается в виде дерева, любую ветвь которого можно редактировать.</P>

<P>Модуль I-DEAS Master Surfacing позволяет создавать модели деталей со сложными «скульптурными» поверхностями. При этом предполагается, что первичный эскиз подготовлен при помощи модуля I-DEAS Master Modeler, в котором реализована NURBS-геометрия с двойной точностью, а также моделирование при помощи кривых Безье высокого порядка. Для контроля гладкости полученной поверхности используются специальные средства визуализации, выявляющие участки с резкими изломами.</P>

<P>Модуль I-DEAS Master Assembly позволяет создавать трехмерные модели сборочных узлов, состоящих из большого числа мелких элементов, каждый из которых также может быть сборочным узлом. При вставке элемента в механизм конструктору не требуется точного позиционирования, достаточно лишь задать связи между элементами, по которым далее находится точное взаимное расположение деталей. Для созданной сборки можно автоматически сформировать спецификацию, а для группы сборок – построить таблицы входимости, содержащие списки сборочных узлов, в которые входят заданные детали. Кроме того, имеются функции анализа собираемости созданного узла и оценки допусков при помощи I-DEAS Tolerance Analysis. Модель простейшего механизма также можно построить с помощью модуля Master Assembly, но при создании моделей сложных пространственных механизмов применяется специальный модуль I-DEAS Mechanism Design, который также позволяет провести полный динамический анализ (вычислить силы, моменты, перемещения, скорости, ускорения и т. д.).</P>

<P>Модуль I-DEAS Drafting предназначен для получения чертежей изделия, созданного в модулях I-DEAS Master Modeler, I-DEAS Master Surfacing, I-DEAS Master Assembly, либо применяется как самостоятельная система двухмерного черчения. Для взаимодействия с пользователем I-DEAS Drafting использует «Динамический навигатор» – специальное средство, поддерживающее как однопользовательскую, так и многопользовательскую работу. По геометрии главной модели (мастер-модели) легко создаются проекции, сечения, разрезы, проставляются размеры. Чертежи взаимосвязаны с главной моделью в обоих направлениях, т. е. изменение любого размера на чертеже сразу же отражается в мастер-модели и наоборот. В процессе черчения также автоматически создается спецификация, которая обновляется динамически при изменении числа объектов, их атрибутов и т. д.</P>

<P>I-DEAS Data Translation представляет собой набор модулей для чтения и записи графических файлов в форматах IGES, STEP, VDA-FS, DXF, а также для обмена данными с пакетами Pro/ENGINEER, CATIA, CAD AM, CADDS и другими.</P>

<Br>
<A Name="#4.5."><P Class=h3>Система Unigraphics</P></A>

<P>Система Unigraphics фирмы EDS широко распространена в аэрокосмической и автомобильной промышленности, а также в машиностроении. Ее отличительными особенностями являются наличие средств гибридного трехмерного моделирования, ассоциативной базы данных, развитых средств моделирования сборочных узлов и создания чертежей. В состав системы Unigraphics входит несколько десятков модулей, основными из которых являются:</P>

<Ul>
<Li>UG/Gateway – поддерживает интерфейс системы с пользователем и взаимодействие между ее отдельными компонентами;
<Li>UG/Solid Modeling – базовый модуль трехмерного гибридного моделирования (проволочного, поверхностного, твердотельного и их модификаций);
<Li>UG/Features Modeling – позволяет редактировать и параметрически задавать стандартные элементы изделий, такие, как отверстия, щели, выступы, прокладки, стержни, трубы, желоба и т. д.;
<Li>UG/Freeform Modeling – модуль трехмерного моделирования сложных «скульптурных» поверхностей;
<Li>UG/User-Defmed Features – позволяет представлять произвольные группы деталей в виде одного параметризованного стандартного объекта, который может использоваться всеми конструкторами;
<Li>UG/Drafting – модуль автоматизированного черчения, поддерживающий все основные промышленные стандарты (ANSI, ISO, DIN, JIS) и включающий в себя средства формирования ортогональных и изометрических проекций, разрезов, сечений и т. д.;
<Li>UG/Assembly Modeling – позволяет создавать ассоциативные параметрические модели сложных сборочных узлов в режиме групповой работы конструкторов;
<Li>UG/Mechanisms – модуль проектирования и моделирования двухмерных и трехмерных механических систем непосредственно в среде пакета Unigraphics, позволяющий осуществить полный кинематический анализ, оценить зазоры между элементами, выявить столкновения, вычислить силы, моменты и т. д.
</Ul>

<P>Кроме этого, в состав Unigraphics входит целый ряд модулей для подготовки автоматизированного производства, базовыми из которых являются UG/CAM Base и UG/Postprocessor. Имеются также модули, ориентированые на конкретные технологические процессы: UG/MF-Flowcheck – для литья; UG/Lathe – для токарных работ; UG/Planar Milling, UG/Fixed-Axis Milling, UG/Variable-Axis Milling – для фрезерования; UG/Sheet Metal Design, UG/Sheet Metal Fabrication, UG/Sheet Metal Nesting – для изготовления изделий из листового металла. Используя средства пакета Unigraphics, можно создавать фотореалистические изображения разрабатываемых изделий (UG/Photo) и их трехмерные прототипы (UG/Rapid Prototyping).</P>

<Br><Br>


<A Name="#5."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=98% BgColor=#ABB3D5>
 <Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
 <Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif Width="1" Height="1"></Td>
 <Td Valign=Center><span Class=h>5. Системы координат</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br><Br>

<Table Border=0 CellPadding=0 CellSpacing=0>
 <Tr><Td>

<P>Для вывода изображения объекта на экран необходимо решить две основные задачи:</P>

<Ol>
 <Li>указать положение всех точек объекта в пространстве;</Li>
 <Li>определить положение их образов на экране.</Li>
</Ol>

<P>Для задания положения точек в пространстве и на мониторе используются системы координат. Необходимо знать, как связаны между собой различные системы координат, особенно это важно для проектирования трёхмерного объекта на плоский экран. Проекция на экране строится по тем же законам, что и проекция реального объекта на сетчатке человеческого глаза.</P>

<P>Положение точки на экране определяет <I>система координат устройства</I> (<I>device coordinate system</I>). Она состоит
из горизонтальной оси <I>X</I> и вертикальной оси <I>Y</I> (рис. 22). Начало отсчёта выбирается произвольно. Осей <I>X</I>
и <I>Y</I> достаточно для задания положения любой точки экрана, поэтому третья ось, перпендикулярная первым двум, не
определяется. Положение любой точки задаётся двумя целыми числами <I>X</I> и <I>Y</I>, равными числу пикселов между
началом координат и точкой по осям <I>X</I> и <I>Y</I>. Однако одна и та же точка может задаваться разными парами <I>X</I>
и <I>Y</I> в зависимости от положения начала координат, направления осей и масштаба. Эти параметры для разных графических
устройств устанавливаются произвольно (рис. 5.1.).</P>

 </Td>
 <Td>&nbsp;&nbsp;</Td>
 <Td>

 <Center><Img src="images/022.png"><P Class=c>Рис. 5.1. Системы координат устройства</P></Center> 

 </Td></Tr>
</Table><Br>

<P><I>Виртуальная система координат устройства</I> (<I>virtual device coordinate system</I>) позволяет избежать описанной
выше проблемы. Она фиксирует точку отсчёта, направление и масштаб осей для всех рабочих станций. "Виртуальный" означает,
что данная система отсчёта существует только в воображении программиста. Обычно начало отсчёта располагается в левом
нижнем углу экрана, ось <I>X</I> откладывается вправо, а ось <I>Y</I> - вверх. Точка в виртуальной системе координат, на
любом экране попадает в одно и то же место. Графическая программа передаёт виртуальные координаты подпрограмме драйвера
устройства, которая преобразует их в координаты конкретного устройства.</P>

<P>Виртуальная и обычная системы координат устройства позволяют задавать положение точки на плоском экране. Теперь
рассмотрим системамы координат для работы с трёхмерным пространством. Основных трёхмерных систем координат всего три:
<I>внешняя система координат</I> (<I>world coordinate system, WCS</I>), <I>система координат модели</I> (<I>model
coordinate system</I>) и <I>система координат наблюдателя</I> (<I>viewing coordinate system</I>).</P>

<P>WCS - это внешняя по отношению к объектам мира, опорная система координат. Такая система может использоваться для
описания расположения и ориентации парт, стульев и доски, если интересующий нас мир представляет собой класс.</P>

<P>После того, как определена мировая система координат, необходимо описать форму объекта. Она определяется координатами
его характеристических точек по отношению к системе координат, связанной с ним, - системой координат модели (<I>model
coordinate system</I>). Координаты точек объекта, определённые таким образом, не изменяются, когда объект перемещается или
вращается в пространстве. Система координат модели перемещается вместе с тем объектом, к которому она привязана.
Расположение и ориентация любого объекта задаются относительным положением и ориентацией модельной системы координат
данного объекта по отношению к внешней системе координат. Относительное расположение и ориентация систем координат
определяются матрицей преобразования, которая позволяет получить координаты любой точки любого объекта во внешней
системе.</P>

<P>Следующий шаг - проецирование трёхмерных объектов или их точек на экран подобно тому, как они проецируются на сетчатку
человеческого глаза. В компьютерной графике используется два вида проекций: перспективная и параллельная (рис. 5.2.).</P>

<Center><Table>
<Tr><Td><Img src="images/023a.png"></Td><Td><Img src="images/023b.png"></Td></Tr>
<Tr><Td><P Class=c>a</P></Td><Td><P Class=c>б</P></Td></Tr>
</Table>

<Center><P Class=c>Рис. 5.2. Два вида проекций: а - перспективная; б - параллельная</P></Center>

<P>Оба вида требуют задания двух точек: точки зрения и точки наблюдения. Точка зрения (viewpoint) - это глаз наблюдателя.
Точка наблюдения (viewsite) - это точка объекта, определяющая направление "луча зрения". Вектор, проведенный от точки
зрения к цели, задаёт направление наблюдения.</P>

<P>В <I>перспективной проекции (perspective projection)</I> все точки объекта соединяются с центром проекции, лежащем на линии,
соединяющей точку зрения и цель (в противном случае проекция называется косоугольной). Точки пересечения этих линий с
экраном образуют проекцию. Экран располагается между точкой зрения и целью. В <I>параллельной проекции (parallel projection)</I>
линии от всех точек объекта проводятся в направлении наблюдателя параллельно направлению наблюдения, а точки пересечения
этих линий с экраном формируют проекцию. Экран, как и в перспективной проекции, располагается перпендикулярно направлению
проектирования. Такая проекция называется ортогональной.</P>

<P>В AutoCAD определяются две системы координат: мировая система координат World Coordinate System (WCS) и
пользовательская система координат User Coordinate System (UCS). Ось <I>X</I> мировой системы координат направлена
горизонтально, <I>Y</I> - вертикально, а ось <I>Z</I> проходит перпендикулярно плоскости <I>XY</I>. Началом координат
является точка пересечения осей <I>Х</I> и <I>Y</I>. Первоначально она совмещается с левым нижним углом чертежа. В любой момент активна только одна система координат, которую принято называть текущей. Она управляется командой UCS, в ответ на которую выдается список возможных опций:</P>

<P>Origin/ZAxis/3point/OBject/View/X/Y/Z/Prev/Restore/Save/Del/?/ <World>:</P>

<P>Рассмотрим основные из них.</P>

<Ul>
<Li>World UCS – переход в мировую систему координат.
<Li>Object UCS – выравнивание системы координат по существующему объекту.
<Li>View UCS – выравнивание системы координат в направлении текущего вида, то есть определение новой системы координат с плоскостью XY, расположенной перпендикулярно направлению вида, иначе говоря, параллельно экрану.
<Li>Origin UCS – смещение начала координат.
<Li>3Point UCS – определение положения системы координат по трем точкам.
<Li>XAxis Rotate UCS – поворот системы координат вокруг оси X.
<Li>YAxis Rotate UCS – поворот системы координат вокруг оси Y.
<Li>ZAxis Rotate UCS – поворот системы координат вокруг оси Z.
</Ul>

<P>В САПР AutoCAD ввод координат с клавиатуры возможен в абсолютных или относительных координатах. Ввод абсолютных
координат производится в следующих форматах:</P>

<Ul>
<Li><I>декартовы (прямоугольные) координаты</I>. Ввод координат заключается в указании расстояния от начала координат до точки по каждой из осей x, y, z, а также направления (положительного или отрицательного).
<Li><I>полярные координаты</I>. Задаются в формате r < А, где r – радиус, А – угол от предыдущей точки. Угол задается в градусах против часовой стрелки. Значение 0 соответствует положительному направлению оси ОХ.
</Ul>

<P><B>Относительные координаты</B> задают смещение от последней введенной точки. При вводе точек в относительных координатах можно использовать любой формат записи в абсолютных координатах: @dx,dy – для декартовых,
@r < А – для полярных.
</P>

<P>Пример построения в абсолютных координатах:</P>

<P>From point: 40,20 – из точки 1</P>

<P>To point: 190,20 – в точку 2</P>

<P>Пример построения в относительных координатах:</P>

<P>From point: 40,20 – из точки 1</P>

<P>To point: @150,0 – в точку 2</P>

<P>Пример построения в полярных координатах:</P>

<P>From point: 40,20 – из точки 1</P>

<P>To point: @150<0 – в точку 2</P>

<br><br>




<A Name="#6."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=97% BgColor=#ABB3D5>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif></Td><Td align=left><span Class=h>6. Матрицы преобразования</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table><Br>

<P>Проецирование точек на объект в трёхмерном пространстве требует преобразования координат из одной системы в другую.
При этом сначала необходимо перевести координаты точек объекта из модельной системы в мировую. Текущее положение объекта
обычно задаётся через повороты и смещения относительно исходного положения, в котором модельная система координат
совпадала с мировой. Следовательно, мировые координаты точек объекта можно получить трансляцией и поворотом
соответствующих точек из их исходного положения, в котором их модельные координаты совпадали с мировыми. Большинство
графических библиотек выполняют эти преобразования самостоятельно, а программисту остаётся задать только смещение и
поворот для интересующего его объекта. Однако проектировщику всё равно нужно знать законы преобразований, чтобы рисовать
объекты в нужных местах без проб и ошибок, в особенности если эти объекты перемещаются достаточно сложным образом.</P>

<P>Получив мировые координаты всех точек объекта в его текущем положении, необходимо вычислить координаты этих точек в
наблюдательской системе. Перевод координат из одной системы в другую называется <I>отображением (mapping)</I>. Отображение
между мировой и наблюдательской системами координат обычно также осуществляется графической библиотекой самостоятельно,
по заданным координатам точки зрения, точки наблюдения и направлению вектора вертикали (в мировых координатах).</P><Br>


<A Name="#6.1."><P Class=h3>Трансляция</P></A>

<P>При трансляции объекта на величины <I>a</I>, <I>b</I> и <I>с</I> в направлениях <I>х</I>, <I>y</I> и <I>z</I>
соответственно по отношению в начальному положению, в котором модельная системакоординат совпадала с мировой (рис. 17),
мировые координаты точек объекта в новом положении (<I>X<sub>w</sub></I>, <I>Y<sub>w</sub></I>, <I>Z<sub>w</sub></I>)
вычисляются следующим образом:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<Tr><Td><Center><Img src="images/formuly/6.1.png"></Td><Td Width=40px><P Class=r>(6.1)</P></Td></Tr>
</Table>

<P>В этой формуле числа <I>X<sub>m</sub></I>, <I>Y<sub>m</sub></I>, <I>Z<sub>m</sub></I> являются также модельными
координатами точки. В матричной форме:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<Tr><Td><Center><Img src="images/formuly/6.2.png"></Td><Td Width=40px><P Class=r>(6.2)</P></Td></Tr></Table>

<Table Border=0 CellPadding=0 CellSpacing=0 Style="FLOAT: right; MARGIN: 0px 0px 0px 0px"><Tbody><Tr BgColor=#E6E6E6><Td>
  <Center>&nbsp;<Img Src="images/024.png" Alt="Рис. 6.1. Трансляция объекта"><Br><P Class=c>Рис. 6.1. Трансляция объекта</P></Center></Td></Tr></Tbody></Table>

<P>Формулы (2) и (1) эквивалентны друг другу: для этого достаточно записать (2) в развёрнутом виде. Операцию сложения в (1)
удалось записать через умножение в (2) благодаря использованию однородных координат, в которых трёхмерный вектор
записывается через четыре скаляра вместо трёх (Любой вектор (<I>x</I>, <I>y</I>, <I>z</I>)<sup>T</sup> трёхмерного
пространства может быть записан в соответствующих однородных координатах в виде (<I>x<sub>w</sub></I>,
<I>y<sub>w</sub></I>, <I>z<sub>w</sub></I>, <I>w</I>)<sup>T</sup>, где верхний индекс Т обозначает операцию
транспонирования. Поскольку значение <I>w</I> может быть произвольным, для каждого вектора существует множество вариантов
записи в однородных координатах. В формуле (2) используется значение <I>w</I> = 1). Полученная матрица называется
<I>матрицей однородного преобразования (homogeneous transformation matrix</I>). Если бы преобразование (в частности,
трансляцию) нужно было применить к точке в двумерном пространстве, однородная матрица преобразования редуцировалась бы до
матрицы размерностью 3<Font Face=Symbol>&acute;</Font>3 удалением третьей строки и третьего столбца из матрицы
размерностью 4<Font Face=Symbol>&acute;</Font>4. Новая матрица действовала бы на вектор координат размерностью
3<Font Face=Symbol>&acute;</Font>1, полученный из вектора 4<Font Face=Symbol>&acute;</Font>1 удалением
<I>z</I>-координаты.</P>



<br>
<A Name="#6.2."><P Class=h3>Вращение</P></A>

<P>Пусть объект поворачивается на угол <Span Class="symtext">&#952;</span> вокруг оси х мировой системы координат вместе
со своей модельной системой, которая, как и в предыдущем случае, изначально совпадает с мировой (рис. 25). Мировые
координаты точки объекта в новом положении (<I>X<sub>w</sub></I>, <I>Y<sub>w</sub></I>, <I>Z<sub>w</sub></I>) могут быть
получены из исходных мировых координат этой точки (<I>X<sub>m</sub></I>, <I>Y<sub>m</sub></I>, <I>Z<sub>m</sub></I>),
совпадающих с её текущими координатами в модельной системе.</P>

<P>Соотношение между (<I>X<sub>w</sub></I>, <I>Y<sub>w</sub></I>, <I>Z<sub>w</sub></I>) и (<I>X<sub>m</sub></I>,
<I>Y<sub>m</sub></I>, <I>Z<sub>m</sub></I>) становится очевидным после проецирования рис. 25а на плоскость <I>yz</I>.
Результат проецирования показан на рис. 25б.</P>

<Center><Table>
<Tr><Td><Img src="images/025a.png"></Td><Td><Img src="images/025b.png"></Td></Tr>
<Tr><Td><P Class=c>a</P></Td><Td><P Class=c>б</P></Td></Tr>
</Table>

<Center><P Class=c>Рис. 6.2. Вращение вокруг оси х: а) – пространственное положение объекта,
б) – проекция на плоскость yz.<I>X</I></P></Center>

<P>Из рис. 6.2. можно легко получить следующие равенства:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td>
<Center><Img src="images/formuly/6.3.png"></Center>
</td>
<td Width=40px align =right Class=r>(6.3)</td>
</tr>
<tr><td><br>
<Center><Img src="images/formuly/6.4.png"></Center>
</td>
<td Width=40px align =right Class=cf>(6.4)</td>
</tr>
<tr><td><br>
<Center><Img src="images/formuly/6.5.png"></Center>
</td>
<td Width=40px align =right Class=cf>(6.5)</td>
</tr></Table>

<P>Равенства (6.3), (6.4) и (6.5) могут быть записаны в матричной форме:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td>
<Center><Img src="images/formuly/6.6.png"></Center>
</Td>
<td Width=40px align=right Class=cf>(6.6)</Td> </tr> </Table>

<P>Матрица в правой части формулы (6.6) – это однородная матрица преобразования вращения вокруг оси <I>X</I>, которая
кратко обозначается <I>Rot</I>(<I>x</I>,<I>Q</I>). Подобно матрице трансляции, для двумерного объекта однородная матрица
вращения редуцируется до размера 3x3.</P>

<P>Однородные матрицы вращения вокруг осей <I>Y</I> и <I>Z</I> получаются аналогичным образом и записываются так:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td>
<Center><Img src="images/formuly/6.7.png"></Center></Td>
<td Width=40px align=right Class=cf>(6.7)</Td></tr>
<tr><td><br>
<Center><Img src="images/formuly/6.8.png"></Center></Td>
<td Width=40px align=right Class=cf>(6.8)</Td></tr></Table>
<P>Мы получили матрицы преобразования, описывающие поворот вокруг мировых осей координат. Поворот вокруг любой произвольной оси раскладывается
 на повороты вокруг осей <I>X</I>, <I>Y</I> и <I>Z</I>. Таким образом, матрица преобразования для произвольной оси получается перемножением матриц (6.6)-(6.8).
</P>


<br>
<A Name="#6.3."><P Class=h3>Отображение</P></A>

<P><I>Отображение (mapping)</I> состоит в вычислении координат точки в некоторой системе координат по известным координатам той же 
точки в другой системе координат.
</P>
<P>Рассмотрим две системы координат (рис. 6.3.). Предположим, что координаты (<I>X</I><sub>2</sub>, <I>Y</I><sub>2</sub>, <I>Z</I><sub>2</sub>)
 точки <I>P</I> в системе координат <I>x</I><sub>2</sub><I>y</I><sub>2</sub><I>z</I><sub>2</sub> должны быть вычислены по координатам 
 (<I>X</I><sub>1</sub>, <I>Y</I><sub>1</sub>, <I>Z</I><sub>1</sub>) той же точки в системе <I>x</I><sub>1</sub><I>y</I><sub>1</sub><I>z</I><sub>1</sub>.
  Далее, предположим, что вычисление производится применением матрицы преобразования <I>T</I><sub>1-2</sub> к известным координатам:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td>
<Center><Img src="images/formuly/6.9.png"></Center>
</td><td Width=40px align=right Class=cf>(6.9)</td>
</tr><tr><td colspan=2 align=center><br>
<Img src="images/6.3.png"></Td></tr>
<tr><td colspan=2 align =center class ="c">Рис. 6.3. Отображение из одной системы координат в другую</td></tr>
</Table>
<P>Записав матрицу <I>T</I><sub>1-2</sub> в явном виде, мы получим из формулы (6.9) следующее выражение:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/6.10.png"></Td>
<td Width=40px align =right Class=cf>(6.10)</td></tr></Table>
<P>Чтобы найти неизвестные в уравнении (6.10), подставим в него конкретные значения <I>X</I><sub>1</sub> = 0, <I>Y</I><sub>1</sub> = 0 и <I>Z</I><sub>1</sub> = 0,
 в результате чего получим:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/6.11.png"></Td>
<td Width=40px align =right Class=cf>(6.11)</td></tr></Table>
<P>Можно сказать, что <I>p<sub>x</sub></I>, <I>p<sub>y</sub></I> и <I>p<sub>z</sub></I> определяют координаты начала отсчета системы
 <I>x</I><sub>1</sub><I>y</I><sub>1</sub><I>z</I><sub>1</sub> в системе координат <I>x</I><sub>2</sub><I>y</I><sub>2</sub><I>z</I><sub>2</sub>.
</P>
<P>Теперь подставим в уравнение (6.10) значения <I>X</I><sub>1</sub> = 1, <I>Y</I><sub>1</sub> = 0 и <I>Z</I><sub>1</sub> = 0 и получим:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/6.12.png"></Td>
<td Width=40px align =right Class=cf>(6.12)</td></tr></Table>
<P>Вычитая формулы (6.11) из (6.12), можно заключить, что <I>n<sub>x</sub></I>, <I>n<sub>y</sub></I> и <I>n<sub>z</sub></I> – компоненты 
<I>x</I><sub>2</sub>, <I>y</I><sub>2</sub> и <I>z</I><sub>2</sub> единичного вектора, направленного вдоль оси <I>x</I><sub>1</sub> системы координат 
<I>x</I><sub>1</sub><I>y</I><sub>1</sub><I>z</I><sub>1</sub>. Следовательно, коэффициенты nх, nу и nz легко вычислить с учётом взаимной ориентации систем координат.
</P>
<P>Аналогичным образом, <I>o<sub>x</sub></I>, <I>o<sub>y</sub></I> и <I>o<sub>z</sub></I> представляют собой компоненты 
<I>x<sub>2</sub></I>, <I>y<sub>2</sub></I> и <I>z<sub>2</sub></I> единичного вектора оси <I>y</I><sub>1</sub> а компоненты
 <I>a<sub>x</sub></I>, <I>a<sub>y</sub></I> и <I>a<sub>z</sub></I> – вектора оси <I>z</I><sub>1</sub>.
</P>

<br>
<A Name="#6.4."><P Class=h3>Масштабирование и зеркльное отображение</P></A>

<P>Помимо матриц преобразования, рассмотренных в предыдущих разделах, часто используются матрицы масштабирования и зеркального отображения.
</P>
<P>Для масштабирования объекта с коэффициентом <I>s<sub>x</sub></I> по оси <I>x</I>, <I>s<sub>y</sub></I> по оси <I>y</I>, 
<I>s<sub>z</sub></I> по оси <I>z</I> применяется следующая матрица преобразования:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/6.13.png"></Td>
<td Width=40px align =right Class=cf>(6.13)</td></tr></Table>
<P>Для двумерных объектов матрица масштабирования редуцируется до размера 3x3, как это было с матрицами трансляции и поворота. Эффекта 
масштабирования можно достичь, изменив размеры видового экрана или окна, не меняя значений координат.
</P>
<P>Матрица преобразования (6.13) используется при масштабировании объекта относительно начала координат. Часто бывает необходимо масштабировать 
объект относительно одной из его точек <I>P</I> с координатами (<I>X<sub>p</sub></I>, <I>Y<sub>p</sub></I>, <I>Z<sub>p</sub></I>). В этом случае 
сначала к точке <I>P</I> применяется преобразование трансляции <I>Trans</I>(-<I>X<sub>p</sub></I>, -<I>Y<sub>p</sub></I>, -<I>Z<sub>p</sub></I>), 
которое перемещает эту точку в начало координат, затем применяется матрица масштабирования из (6.13), после чего объект возвращается в исходное 
положение действием <I>Trans</I>(<I>X<sub>p</sub></I>, <I>Y<sub>p</sub></I>, <I>Z<sub>p</sub></I>).
</P>
<P>Отражение относительно зеркальной плоскости <I>xy</I> может быть достигнуто при помощи приведённой ниже матрицы преобразования. Преобразование 
заключается в изменении знака координаты <I>z</I>.
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/6.14.png"></Td>
<td Width=40px align =right Class=cf>(6.14)</td></tr></Table>
<P>Матрицы преобразования для других отражений (относительно плоскостей <I>xz</I> и <I>yz</I>) выводятся аналогичным образом.
</P><Br>




<A Name="#7."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=97% BgColor=#ABB3D5>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif></Td><Td align=left><span Class=h>7.Представление кривых и работа с ними</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table><br>
<P>Для каждого криволинейного ребра в компьютере хранится либо уравнение кривой, либо эквивалентные характеристические параметры (центр, радиус и вектор
 нормали к плоскости, в которой лежит окружность, – примеры характеристических параметров, эквивалентных уравнению окружности.). Эти сведения важны как 
 для систем автоматизированной разработки чертежей, так и для систем объемного моделирования. Расчёт точек пересечения кривых необходим для определения
 границ ксегментов (ксегментом называется часть кривой, по которой пересекаются две грани, относящиеся к разным объемным телам. Ксегмент принадлежит 
 обеим граням.) при применении булевских операций. Границы ксегмента получаются путем вычисления точек пересечения кривой, ограничивающей 
 пересекающиеся поверхности, с кривой, по которой пересекаются эти поверхности (относящиеся к разным телам). После получения границ ксегмента нужно
  разделить кривую пересечения в точках пересечения. Аналогичная процедура выполняется при создании и модифицировании кривых в системах
   автоматизированной разработки чертежей и системах поверхностного моделирования. Рассмотрим методы представления уравнений кривых и методы работы 
   с ними.
</P>

<br>
<A Name="#7.1."><P Class=h3>Типы уравнений</P></A>

<P>Уравнения кривых могут быть разделены на два основных типа. К первому типу относятся параметрические уравнения, описывающие связь координат
 <I>x</I>, <I>y</I> и <I>z</I> точки кривой с параметром. Ко второму типу относятся непараметрические уравнения, связывающие координаты 
 <I>x</I>, <I>y</I> и <I>z</I> некоторой функцией. Проще всего продемонстрировать различие между ними на примере. Рассмотрим окружность радиуса 
 <I>R</I>, расположенную в начале системы координат. Если окружность лежит в плоскости <I>XY</I>, её параметрическое уравнение может быть, например, таким:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.1.png"></Td>
<td Width=40px align =right Class=cf>(7.1)</td></tr></Table>
<P>Ту же окружность можно описать уравнением и без параметра <Img src="images/formuly/7.1.1.gif">&#0032:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.2.gif"></Td>
<td Width=40px align =right Class=cf>(7.2)</td></tr></Table>
<P>или</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.3.gif"></Td>
<td Width=40px align =right Class=cf>(7.3)</td></tr></Table>
<P>Уравнение (7.2) задает окружность в неявной непараметрической форме, а уравнение (7.3) – в явной непараметрической форме.
</P>
<P>У каждого типа уравнений, примеры которых приведены выше, есть свои преимущества и недостатки, определяющие удобство их применения для различных 
целей. Мы сосредоточим внимание на применении уравнений к отображению кривых, поскольку интерактивная графика является одной из важнейших функций САПР.
 Кривая, отображаемая на экране, в действительности представляет собой набор коротких отрезков. Поэтому постоянно возникает необходимость вычислять
  координаты точек кривой, находящихся на равном расстоянии друг от друга. Это называется <I>вычислением кривой (curve evaluation)</I>. Можно ожидать, что 
  точки окружности, заданной уравнением (7.1), могут быть получены подстановкой последовательных значений параметра, отличающихся друг от друга на 
  небольшую величину. При использовании уравнения (7.2), однако, мы не знаем, какую переменную следует выбрать в качестве независимой и последовательно
   увеличивать от точки к точке. Даже если мы выберем независимую переменную, для каждого ее значения мы будем получать два значения зависимой 
   переменной. Это означает, что нам придется выбирать одну из них таким образом, чтобы она располагалась по соседству с предыдущей найденной нами 
   точкой. Уравнение (7.3) обладает тем же недостатком, несмотря на то, что в нем независимая переменная уже выделена.
</P>
<P>Из-за перечисленных недостатков непараметрического представления в системах автоматизированного проектирования чаще всего используются 
параметрические уравнения кривых и поверхностей, поэтому в данной главе мы будем обсуждать только их.
</P>

<br>
<A Name="#7.2."><P Class=h3>Конические сечения</P></A>

<P>Кривые или части кривых, получаемые сечением конуса плоскостью, называются <I>коническими сечениями (conic sections)</I>. В зависимости от положения 
и ориентации секущей плоскости по отношению к конусу кривая сечения может быть окружностью, эллипсом, параболой или гиперболой. В большинстве случаев
 профили деталей могут быть представлены в виде конических сечений, поскольку детали машин чаще всего обладают осевой симметрией.
</P>

<br>
<A Name="#7.3."><P Class=h3>Окружность и дуга окружности</P></A>

<P>Окружность или дуга окружности, лежащие в плоскости <I>xy</I>, с заданным радиусом <I>R</I> и координатами центра <I>X<sub>c</sub></I>, 
<I>Y<sub>c</sub></I> могут быть представлены уравнениями:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.4.png"></Td>
<td Width=40px align =right Class=cf>(7.4)</td></tr></Table>
<P>Как уже отмечалось, вычисление кривой может выполняться путем последовательной подстановки в уравнение значений Q с шагом &#0136Q. Значение Q может
 достигать 2&#0136 для полной окружности или меньшего числа для дуги окружности. Значение &#0136Q должно быть подобрано таким образом, чтобы вычисление было 
 достаточно быстрым, но окружность не получилась бы похожей на многоугольник. Уравнение окружности, лежащей в другой плоскости, может быть получено 
 применением матриц преобразования к уравнению (7.4).
</P> 
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align = center><Img src="images/7.1.png"><Br><P Class=c>Рис. 7.1. Вычисление окружности</P>&nbsp;</td>



<td><P>Пример.</P>
<P>Окружность единичного радиуса с центром в точке (0, 1, 1) лежит в плоскости <I>yz</I>, как показано на рисунке (Уравнение этой кривой может 
храниться в памяти в виде характеристических параметров, таких как вектор нормали (1,0, 0), координаты центра (0, 1, 1) и радиус 1. Как уже отмечалось,
 задание этих параметров эквивалентно написанию уравнения.). Выведите параметрическое уравнение этой окружности, применив соответствующие матрицы преобразований к уравнению (7.4).

<P>Решение</P>

<P>Исходная единичная окружность, лежащая в плоскости <I>xy</I>, изображена на рисунке пунктиром, а интересующая нас
окружность – сплошной линией. Сплошная окружность получается из пунктирной поворотом на угол -90<sup>o</sup> вокруг оси
<I>y</I> и последующей трансляцией на 1 в направлениях <I>y</I> и <I>z</I>. Обозначим координаты точек сплошной окружности
буквами <I>x</I><sup>*</sup>, <I>y</I><sup>*</sup> и <I>z</I><sup>*</sup>, а координаты точек пунктирной окружности буквами
<I>x</I>, <I>y</I> и <i>z</i>. Тогда преобразования запишутся следующим образом:<Br></P>
</td></tr>
</Table> 

<P><Center><Img src="images/formuly/7.4.1.png"></Center></P>

<P>Отсюда</P>

<Center><Img src="images/formuly/7.4.2.gif"></Center>

<br>
<A Name="#7.4."><P Class=h3>Эллипс и эллиптическая дуга</P></A>

<P>Эллипс, как и окружность, может быть задан параметрическим уравнением. Запишем такое уравнение для эллипса, лежащего в
плоскости <I>xy</I>, с центром в начале координат. Положим, что большая ось эллипса направлена вдоль оси <I></I> и имеет
длину <I>a</I>, а малая ось направлена вдоль оси <I>y</I> и имеет длину <I>b</I>. Параметрическое уравнение эллипса будет
таким:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.5.png"></Td>
<td Width=40px align =right Class=cf>(7.5)</td></tr></Table>

<P>Диапазон значений параметра для эллипса составляет [0, 2], а для дуги эллипса может быть более узким. Произвольный эллипс на произвольной
 плоскости с произвольными направлениями большой и малой осей получается в результате применения матриц преобразования, подобно тому, как мы делали это с окружностью.</P> 

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align = center><Img src="images/7.2.png"><Br><P Class=c>Рис. 7.2. Вычисление эллипса</P></td>
<td>&nbsp;&nbsp;</td>
<td>

<P>Пример.</P>

<P>Получить параметрическое уравнение эллипса, лежащего в плоскости <I>xy</I>, с координатами центра <I>X<sub>c</sub></I>, <I>Y<sub>c</sub></I>. Оси 
эллипса направлены так, как показано на приведенном ниже рисунке.
</P>
 <P>Решение</P>
<P>Требуемый эллипс может быть получен поворотом исходного эллипса на угол вокруг оси <I>z</I> и трансляцией его на величину <I>X<sub>c</sub></I> в 
направлении <I>x</I> и на величину <I>Y<sub>c</sub></I> в направлении <I>y</I>. Обозначим координаты точек интересующего нас эллипса буквами 
<I>x</I><sup>*</sup>, <I>y</I><sup>*</sup> и <I>z</I><sup>*</sup>, а координаты точек исходного эллипса буквами <I>x</I>, <I>y</I> и <I>z</I>. Тогда 
преобразования запишутся следующим образом:<Br><Br></P>
</td></tr>
</Table>  

<Center><Img src="images/formuly/7.5.1.png"></Center>

<P>Следовательно</P>

<Center><Img src="images/formuly/7.5.2.png"></Center>

<br>
<A Name="#7.5."><P Class=h3>Гипербола</P></A>

<P>Известно, что неявное уравнение гиперболы (рис. 7.3.) имеет следующий вид:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.6.png"></Td>
<td Width=40px align =right Class=cf>(7.6)</td></tr></Table>
<P>Уравнение (7.6) может быть записано в параметрической форме (Напомним, что <I>chu</I> = (е<I><sup>u</sup></I> + е<sup>-<i>u</i></sup>)/2 и 
<I>shu</I> = (е<I><sup>u</sup></I> – е<sup>-<i>u</i></sup>)/2. Из уравнения (7.6) можно получить и другие параметрические уравнения.):
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.7.png"></Td>
<td Width=40px align =right Class=cf>(7.7)</td></tr></Table><br>
<Center><Img src="images/7.3.png"><Br><P Class=c>Рис. 7.3. Гипербола</P></Center>
<P>Здесь используется известное тождество <I>ch</I><sup>2</sup><i>u</i> – <I>sh</I><sup>2</sup><i>u</i> = 1. Диапазон значений параметра и для 
уравнения (7.7) определяется исходя из координат конечных точек описываемой гиперболы. Применение соответствующих матриц преобразований к
уравнению (7.7) позволяет получить уравнение гиперболы с центром в любой точке пространства, ориентированной произвольным образом.
</P>

<br>
<A Name="#7.6."><P Class=h3>Парабола</P></A>

<P>Парабола, симметричная относительно оси <I>x</I> и проходящая через начало координат, может быть задана следующим явным уравнением:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.8.gif"></Td>
<td Width=40px align =right Class=cf>(7.8)</td></tr></Table>
<P>Это уравнение может быть преобразовано к параметрическому виду:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.9.gif"></Td>
<td Width=40px align =right Class=cf>(7.9)</td></tr></Table>
<P>Параметрическое уравнение (7.9) не является уникальным по отношению к уравнению 7.8): вы можете выбрать любое удобное параметрическое уравнение. Диапазон значений параметра и в уравнении (7.9) выбирается исходя из координат концов описываемой параболы. Уравнение произвольной параболы с произвольными координатами центра и ориентацией может быть получено применением соответствующих матриц преобразований к уравнению (7.9).
</P>

<br>
<A Name="#7.7."><P Class=h3>Эрмитовы кривые</P></A>

<P>Чаще всего для описания кривых, используемых в программах CAD, используются уравнения третьего порядка, потому что они обладают важным свойством:
 две кривые, описываемые такими уравнениями, могут быть соединены таким образом, что вторые производные в точке соединения будут равны друг другу. Это
  означает, что кривизна в точке соединения остается постоянной, отчего две кривые кажутся одним целым. Ту же непрерывность можно получить и для кривых
   более высоких порядков, однако работа с ними требует интенсивных вычислений.</P>
<P>Простейшее параметрическое уравнение третьего порядка выглядит следующим образом:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.10.png"></Td>
<td Width=40px align =right Class=cf>(7.10)</td></tr></Table>
<P>В формуле (7.10) <B>a</B><sub>0</sub>, <B>a</B><sub>1</sub>, <B>a</B><sub>2</sub>, <B>a</B><sub>3</sub> – векторные коэффициенты параметрического 
уравнения, то есть векторы-строки с компонентами <I>x</I>, <I>y</I> и <I>z</I> (Координаты точки мы представляли вектором-столбцом, следуя соглашениям,
 принятым создателями OpenGL. Здесь же мы используем векторы-строки, потому что это делает более удобным представление матрицы геометрических коэффициентов, приведенной на рис. 7.4.). Эти коэффициенты являются обычными алгебраическими коэффициентами (уравнение (7.10) называется,
  соответственно, алгебраическим) уравнения, поэтому их изменение не приводит к интуитивно понятному изменению формы кривой.</P>
<P>Чтобы преодолеть этот недостаток алгебраических коэффициентов, мы заменим их векторами, обладающими конкретным геометрическим значением. Один из 
возможных вариантов – использование радиус-векторов конечных точек кривой <B>P</B><sub>0</sub> и <B>P</B><sub>1</sub> а также векторов 
P0 и P1 , задающих направление касательных в этих точках. Добавление граничных условий в виде векторов Р0, Р1,  ,   к формуле (7.10) даёт:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.11.png"></Td>
<td Width=40px align =right Class=cf>(7.11)</td></tr></Table>
<P>Уравнения (7.11) могут быть решены относительно <B>a</B><sub>0</sub>, <B>a</B><sub>1</sub>, <B>a</B><sub>2</sub>, <B>a</B><sub>3</sub>:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.12.png"></Td>
<td Width=40px align =right Class=cf>(7.12)</td></tr></Table>
<P>Подстановка (7.12) в (7.10) даст нам уравнение кривой в новом виде:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.13.png"></Td>
<td Width=40px align =right Class=cf>(7.13)</td></tr></Table>
<P>Теперь в уравнение кривой уже не входят алгебраические коэффициенты – вместо них стоят векторы <B>P</B><sub>0</sub>, <B>P</B><sub>1</sub>, P1 , P0 . 
Новые векторные коэффициенты 
называются геометрическими (<I>geometric coefficients</I>), а уравнение (7.13) называется уравнением <I>эрмитовой кривой </I>(<I>Hermite curve</I>
 – определяется четырьмя векторами, поэтому они вводятся при её создании и сохраняются в качестве задающих ее параметров.). Преимущество эрмитовой кривой в том, 
что изменение ее формы может быть интуитивно предсказано по изменению геометрических коэффициентов. Например, изменение <B>P</B><sub>0</sub> или <B>P</B><sub>1</sub> вызовет такое 
изменение кривой, что ее концы переместятся в новое положение, задаваемое измененными векторами <B>P</B><sub>0</sub> и <B>P</B><sub>1</sub>.Точно так же изменение  <B>P</B><sub>0</sub> или <B>P</B><sub>1</sub>  приведет к тому,
 что касательные к кривой на ее концах станут совпадать с новыми векторами <B>P</B><sub>0</sub> , и  <B>P</B><sub>1</sub> (рис. 7.4).
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/7.4.png"></td></tr>
<tr><td align =center class ="c">Рис. 7.4. Влияние касательных на форму кривой</td></tr></table>
<P>Матрица геометрических коэффициентов обозначается буквой <b>[B]</b> и включает векторы <B>P</B><sub>0</sub>, <B>P</B><sub>1</sub>,  P0,  P1. Каждый 
вектор записывается в своей строке, в той последовательности, в которой они перечислены выше. Рисунок демонстрирует только влияние изменения векторов, определяющих направление и длину касательных. Обратите внимание на то, что происходит с кривой, если меняется только длина, но не направление вектора касательной. Можно заключить, что длина вектора определяет, насколько далеко вдоль кривой по направлению к ее середине распространяется влияние этого вектора.
</P>
<P>Формулу (7.13) можно интерпретировать и так, как это сделано ниже. Векторы <B>P</B><sub>0</sub>, <B>P</B><sub>1</sub>,  P0, P1  влияют на форму 
кривой, причем относительная степень их влияния определяется функциями:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.14.png"></Td>
<td Width=40px align =right Class=cf>(7.14)</td></tr></Table>
<P>Можно сказать, что эти функции «сопрягают» граничные условия <B>P</B><sub>0</sub>, <B>P</B><sub>1</sub>, P0, P1  друг с другом, поэтому и называют их <I>функциями сопряжения</I> (<I>blending functions</I>).
</P>

<br>
<A Name="#7.8."><P Class=h3>Кривая Безье</P></A>

<P>Хотя преобразование алгебраического уравнения кривой в форму эрмитова уравнения позволяет работать с кривой на интуитивном уровне, эрмитова форма 
не полностью удовлетворяет требованиям разработчикам. Как мы показали, предсказать форму кривой по величине векторов касательных P0 и P1 не так-то просто (рис. 7.4).
</P>
<P>В 60-х годах XX века независимо друг от друга Пьером Безье из автомобилестроительной компании «Рено» и Полем де Кастельжо из компании «Ситроен» были разработаны кривые Безье или кривые Бернштейна-Безье, где применялись для проектирования кузовов автомобилей. Несмотря на то, что открытие де Кастельжо было сделано несколько ранее Безье (1959), его исследования не публиковались и скрывались компанией как производственная тайна до конца 1960-х. Кривая Безье является частным случаем многочленов Бернштейна, описанных Сергеем Натановичем Бернштейном в 1912 году. Впервые кривые были представлены широкой публике в 1962 году Пьером Безье в системе поверхностного моделирования UNISURF, и были названы его именем, а именем де Кастельжо назван разработанный им рекурсивный способ определения кривых (алгоритм де Кастельжо). Эта кривая строится по вершинам многоугольника, заключающего ее в себе. Вершины сопрягаются соответствующими функциями подобно тому, как это делается при построении эрмитовой кривой. Безье выбрал функции сопряжения таким образом, чтобы получающаяся кривая удовлетворяла следующим требованиям:
</P>
<P><UL type=disc>
<li>Кривая проходит через первую и последнюю вершины многоугольника.
</li>
<li>Направление вектора касательной в первой точке кривой совпадает с направлением первого отрезка многоугольника (рис. 7.5). Аналогичным образом, 
последний отрезок многоугольника определяет направление касательной в конечной точке кривой.
</li>
<LI>Производная степени <i>n</i> в начальной (или конечной) точке кривой определяется положением первых (или последних) <i>n</i> + 1 вершин 
многоугольника. Это свойство очень удобно при соединении двух кривых Безье, если требуется удовлетворить требованию непрерывности высших производных в 
точке соединения. Вообще говоря, второе свойство есть частный случай данного свойства. При изменении порядка вершин многоугольника на противоположный
 получается та же самая кривая.
</LI>
</UL>
</P>
<P>Задавшись этими требованиями, Безье выбрал в качестве функций сопряжения полином Бернштейна:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.15.gif"></Td>
<td Width=40px align =right Class=cf>(7.15)</td></tr></Table>
<Table align=left><tr><td valign=middle Class=c> где </td> <td><Img src="images/formuly/7.15.1.png"></Td></tr></Table> 
<br>
<br><br><br><P>Если функцию сопряжения (7.15) применить к вершинам многоугольника, получается уравнение кривой Безье:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.16.png"></Td>
<td Width=40px align =right Class=cf>(7.16)</td></tr></Table>
<P>где <B>P</B><i><sub>i</sub></i> – радиус-вектор i-й вершины. Вершины многоугольника называются <I>задающими</I> (<I>control vertices</I>), как и сам 
многоугольник (<I>control polygon</I>). Из формулы (7.16) видно, что для кривой, заданной <i>n</i> + 1 точками, максимальная степень будет
 <i>u<sup>n</sup></i>. Таким образом, степень кривой Безье определяется количеством задающих точек. Кривые Безье разных степеней с разным количеством задающих точек показаны на рис. 7.5.
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/7.5.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 7.5. Кривые Безье различных степеней</Td></tr></Table>
<P>Покажем теперь, что кривая Безье, заданная уравнением (7.16), удовлетворяет требованиям, перечисленным в начале раздела. Для начала проверим, что кривая проходит через первую и последнюю задающие точки. В этом легко убедиться, подставив в уравнение значения 0 и 1 параметра и. Раскроем суммирование следующим образом:
</P><br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.16.1.png"></Td>
</Table>
<P>Рассчитаем значения <B>P</B>(0) и <B>P</B>(1):
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.16.2.png"></Td>
</Table>
<P>Таким образом, кривая проходит через первую и последнюю задающие точки.
</P>
<P>Второе и третье свойства можно проверить дифференцированием уравнения кривой Безье, чем мы займемся в следующем разделе. Четвертое свойство 
проверяется путём рассмотрения двух кривых, определяемых уравнениями:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.17.png"></Td>
<td Width=40px align =right Class=cf>(7.17)</td></tr></Table>
<P>и</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.18.png"></Td>
<td Width=40px align =right Class=cf>(7.18)</td></tr></Table>
<P>Уравнения (7.17) и (7.18) можно интерпретировать следующим образом: кривая <B>P</B>(<I>u</I>) проводится от точки <B>P</B><sub>0</sub> к точке 
<B>P</B><i><sub>n</sub></i>, тогда как <B>P</B><sup>*</sup>(<I>v</I>) проводится от <B>P</B><i><sub>n</sub></i>(=<B>Q</B><sub>0</sub>) 
к <B>P</B><sub>0</sub>(=<B>Q</B><i><sub>n</sub></i>). Если мы введем новый параметр <i>u</i><sup>*</sup> и заменим <I>v</I> на (1 – <i>u</i><sup>*</sup>), 
направление <b>P</b><sup>*</sup> изменится на противоположное (то есть кривая будет идти от <B>P</B><sub>0</sub> к <B>P</B><i><sub>n</sub></i> при 
изменении <i>u</i><sup>*</sup> от 0 до 1). Поэтому мы сможем сказать, что кривые <B>P</B> и <b>P</b><sup>*</sup> идентичны, если
<b>P</b><sup>*</sup>(1 – <i>u</i><sup>*</sup>) при разложении даст нам то же выражение, что и <B>P</B>(<I>u</I>) с точностью до названий параметров.
Мы получим выражение для <b>P</b><sup>*</sup>(1 – <i>u</i><sup>*</sup>), подставив (1 – <I>u</I>) вместо <i>v</i> в формулу (7.18).
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.19.png"></Td>
<td Width=40px align =right Class=cf>(7.19)</td></tr></Table>
<P>Перепишем выражение (7.19), подставив в него <I>i</I> вместо (<I>n</I> – <I>j</I>):
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.20.png"></Td>
<td Width=40px align =right Class=cf>(7.20)</td></tr></Table>
<Table align=left>
<tr><td valign=middle Class=c>Поскольку</td><td><Img src="images/formuly/7.20.1.png"></td><td valign=middle Class=c>эквивалентно</td><td><Img src="images/formuly/7.20.2.png"></td><td valign=middle>,</td>
<td Class=c>можно заключить, что формула (7.20) совпадает с (7.17).</td>
</tr>
</Table><br><br><br>
<p>Кривая Безье обладает еще одним важным свойством, помимо перечисленных выше, – <i>выпуклостью оболочки </i>(<i>convex hull property</I>). 
Выпуклой оболочкой кривой Безье является выпуклый многоугольник, получаемый соединением задающих точек (рис. 7.6). Обратите внимание, что на этом рисунке все кривые Безье полностью лежат внутри своих выпуклых оболочек.
</p>
<P>Выпуклость оболочки кривой Безье обеспечивается тем, что значения сопрягающих функций лежат на отрезке [0,1], а их сумма равна 1 для любого и.
 Это утверждение легко проверить для кривой Безье, определяемой двумя задающими точками. Кривая, заданная точками <B>P</B><sub>0</sub> и 
 <B>P</B><sub>1</sub> будет отрезком прямой, а её выпуклой оболочкой будет тот же самый отрезок. Любую точку этой кривой можно получить сложением 
 <B>P</B><sub>0</sub><I>B</I><sub>0,1</sub> + <B>P</B><sub>1</sub><I>B</I><sub>1,1</sub>. Поскольку функции сопряжения <i>B</i><sub>0,1</sub> и 
 <I>B</I><sub>1,1</sub> положительны и их сумма равна единице для любого <I>u</I>, <I>точка</I>, <I>определяемая выражением</I> <B>P</B><sub>0</sub><I>B</I><sub>0,1</sub> + 
 <B>P</B><sub>1</sub><I>B</I><sub>1,1</sub> будет лежать на отрезке <B>P</B><sub>0</sub><B>P</B><sub>1</sub> и делить его в отношении 
 <I>B</I><sub>1,1</sub>:<I>B</I><sub>0,1</sub>. Отрезок <B>P</B><sub>0</sub><B>P</B><sub>1</sub> в нашем случае представляет собой вырожденную 
 выпуклую оболочку, поэтому мы можем сказать, что все точки кривой лежат внутри этой оболочки. Аналогичным образом можно проверить высказанное выше 
 утверждение для кривой Безье, заданной тремя и более точками, как показал Фарин. Выпуклость оболочки полезно использовать при вычислении точек 
 пересечения кривых Безье. Оболочка кривой содержит её целиком, поэтому кривые Безье не могут пересекаться, если не перекрываются их оболочки. В этом 
 случае трудоёмкое вычисление точки пересечения кривых Безье можно сразу же пропустить. Проверка перекрытия выпуклых оболочек требует гораздо меньших
  вычислительных затрат.
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/7.6.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 7.6. Примеры выпуклых оболочек</Td></tr></Table><br>

<br>
<A Name="#7.9."><P Class=h3>B-сплайн</P></A>

<P>Известно, что степень кривой Безье определяется количеством задающих точек, причём все они влияют на форму всей кривой. Эти особенности кривых Безье создают определённые неудобства. Во-первых, при аппроксимации кривой сложной формы при помощи кривой Безье неизбежно используется множество задающих точек, в результате чего получается кривая высокого порядка. Такая кривая может осциллировать, создавая большую вычислительную нагрузку на компьютер. В таком случае можно попытаться представить ту же исходную кривую множеством кривых Безье низших порядков. Однако при этом возникает проблема, которая заключается в том, что соединение кривых с обеспечением непрерывности производных нужных порядков оказывается довольно сложной процедурой.
</P>
<P>Во-вторых, трудоёмким оказывается локальное изменение формы кривой. Кажется естественным переместить задающие точки вблизи изменяемого участка
 кривой, и действительно, это приводит к модификации нужной области, но вместе с ней изменяется вся кривая целиком. Эта особенность называется
  <I>свойством глобальности изменений</I> (<I>global modification property</I>). Глобальность изменений нежелательна при создании кривых заданной
   формы, поскольку кривые всегда создаются или проектируются путем непрерывной модификации грубой формы начального приближения. В системах 
   автоматизированного проектирования желательно наличие прямо противоположного свойства – <I>локальности изменений</I> (<I>local modification 
   property</I>).
</P>
<P>Описанные недостатки кривых Безье связаны с выбором функций сопряжения. Таким образом, нам нужно выбрать новый набор функций сопряжения, 
обладающих определёнными свойствами. Во-первых, в определение новой функции сопряжения не должно входить число точек <i>n</i>, в отличие от функции
 <I>B<sub>i</sub></I>,<i>n</i>(<I>u</I>). Степень функции сопряжения, а значит, и степень кривой, должны быть независимы от числа задающих точек <I>n</I>.
  Во-вторых, все функции сопряжения должны быть отличны от нуля только на ограниченных подмножествах значений параметра, причём для каждой функции 
  такое подмножество должно быть уникальным. В этом случае форма сегмента будет определяться только теми задающими точками, которые учитываются 
  функциями сопряжения, имеющими ненулевые значения на данном сегменте.
</P>
<P>В 1972 г. Кокс и де Бур предложили использовать функции <I>N<sub>i</sub></I>,<I><sub>k</sub></I>(<I>u</I>), определяемые рекурсивно. 
Кривая, которая строится таким образом, называется <I>В-сплайном</i> (<I>В-spline</I>) и записывается в следующем виде:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.21.png"></Td>
<td Width=40px align =right Class=cf>(7.21)</td></tr></Table>
<P>где</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.22.png"></Td>
<td Width=40px align =right Class=cf>(7.22)</td></tr></Table>
<br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<td align =center><Img src="images/formuly/7.23.png"></Td>
<td Width=40px align =right Class=cf>(7.23)</td></Table>
<P>Значения <I>t<sub>i</sub></I>, называются узловыми – они ограничивают отрезки значений параметра, внутри которых функции сопряжения имеют ненулевые 
значения (Когда и совпадает с границей интервала, следует быть аккуратным, поскольку для любого значения и только одна функция 
<I>N<sub>i</sub></I>,<sub>1</sub>(<i>u</i>) может быть отличной от нуля. Это предполагается в определении (7.22). Например, когда <i>u</i> = <I>t<sub>1</sub></I>, 
только одна из функций <I>N</I><sub>0</sub>,<sub>1</sub>(<i>t</i><sub>1</sub>) и <I>N</I><sub>0</sub>,<sub>1</sub>(<i>t</i><sub>1</sub>) может быть
равна единице, хотя из уравнения (7.23) следует, что они обе могли бы иметь это значение. В любом случае значение <B>P</B>(<I>t</I><sub>1</sub>)
окажется одним и тем же.). В формуле (7.22) неопределенность 0/0 считается равной нулю. Как следует из этого уравнения, для определения <i>n</i> + 1
функций сопряжения необходимо задать <i>n</i> + <i>k</i> + 1 узловых значений от <I>t</I><sub>0</sub> до <I>t</I><sub>1+<i>k</i></sub>. 
Разные методы задания узловых значений позволяют получить разные функции сопряжения и, соответственно, разные кривые. Ниже мы расскажем, как это
 делается. Из формулы (7.22) следует, что одновременный сдвиг всех узловых значений на одно и то же число не приводит к изменению формы кривой. 
 При этом происходит лишь изменение диапазона значений параметра для уравнения (7.21).
</P>
<P>Проверим, удовлетворяют ли функции сопряжения, заданные уравнениями (7.22) и (7.23), требованиям, изложенным в начале раздела. Из
 уравнения (7.22) следует, что степень <I>N<sub>i</sub></I><sub>,<i>k</i></sub>(<i>u</i>) на единицу выше, чем у
 <I>N<sub>i</sub></I><sub>,<i>k</i>-1</sub>(<i>u</i>) и <I>N<sub>i</sub></I><sub>+1</sub><sub>,<i>k</i>-1</sub>(<i>u</i>). Следовательно, 
 <I>N<sub>i</sub></I><sub>,2</sub>(<i>u</i>) имеет степень 1, поскольку <I>N<sub>i</sub></I><sub>,1</sub>(<i>u</i>) – константа, а 
 <I>N<sub>i</sub></I><sub>,3</sub>(<i>u</i>) по той же причине имеет степень 2. Продолжая в том же духе, можно прийти к выводу, что функция 
 <I>N<sub>i</sub></I><sub>,<i>k</i></sub>(<i>u</i>) имеет степень <I>k</I> – 1. Таким образом, степень <I>В-сплайна</I> определяется не числом задающих
 точек, а значением <I>k</I>, которое должно быть на единицу больше желаемого значения степени кривой. Значение <I>k</I> называется <I>порядком 
 В-сплайна</I> (<I>order of the B-spline curve</I>).
</P>
<P>Чтобы показать, что любой участок В-сплайна определяется лишь конечным числом задающих точек, рассмотрим сегмент кривой, соответствующий значениям 
параметра из отрезка [<I>t<sub>i</sub></I>, <I>t<sub>i</sub></I><sub>+1</sub>]. Влиять на этот сегмент будут те задающие точки, функции 
сопряжения которых (порядка <I>k</I>) отличны от нуля на отрезке [<I>t<sub>i</sub></I>, <I>t<sub>i</sub></I><sub>+1</sub>]. Среди функций первого порядка от нуля отлична только Ni,1(u). Подставив <I>N<sub>i</sub></I><sub>,1</sub>(<i>u</i>) в правую часть формулы (7.22), мы получим ненулевые на рассматриваемом отрезке функции <I>N<sub>i</sub></I><sub>,2</sub>(<i>u</i>) и <I>N<sub>i</sub></I><sub>-1,2</sub>(<i>u</i>). Первая функция получается подстановкой <I>N<sub>i</sub></I><sub>,1</sub>(<i>u</i>) в первое слагаемое, а вторая функция – подстановкой во второе слагаемое. Затем по ненулевым функциям <I>N<sub>i</sub></I><sub>,2</sub>(<i>u</i>) и <I>N<sub>i</sub></I><sub>-1,2</sub>(<i>u</i>) мы получаем функции третьего порядка и т. д., пока не будут получены функции порядка <I>k</I>. Распространение ненулевых значений иллюстрирует рис. 7.7.
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/7.7.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 7.7. Распространение значений <I>N<sub>i</sub></I><sub>,1</sub>(<i>u</i>)</Td></tr></Table><br>
<P>По рис. 7.7 видно, что ненулевые значения на отрезке [<I>t<sub>i</sub></I>, <I>t<sub>i</sub></I><sub>+1</sub>] будут иметь только функции
 <I>N<sub>i</sub></I>-<i>k</i>+1<sub>,<i>k</i></sub>, <I>N<sub>i</sub></I>-<i>k</i>+1<sub>,<i>k</i></sub>, … , <I>N<sub>i</sub></I><sub>,<i>k</i></sub>.
 Поэтому и влиять на форму отрезка кривой будут только точки <B>P</B><sub><i>i</i>-<i>k</i>+1</sub>, 
 <B>P</B><sub><i>i</i>-<i>k</i>+2</sub>, … , <B>P</B><i><sub>i</sub></i>. (всего <I>k</I> штук). Например, если взять кривую четвёртого порядка, 
 то на форму отрезка будут влиять четыре задающие точки, а все остальные не будут.
</P>
<P>Займемся теперь определением <I>n</I> + <I>k</I> + 1 узловых значений от <I>t</I><sub>0</sub> до <I>t</I><sub><i>n</i>+<i>k</i></sub>. Узлы 
бывают двух основных типов: периодические и непериодические. Периодические узлы определяются из равенства:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.24.png"></Td>
<td Width=40px align =right Class=cf>(7.24)</td></tr></Table>
<P>Непериодические узлы задаются формулой:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.25.png"></Td>
<td Width=40px align =right Class=cf>(7.25)</td></tr></Table>
<P>Главное отличие узлов разных типов состоит в том, что первый и последний непериодические узлы повторяются <I>k</I> раз. Повторение узлов приводит к
 тому, что В-сплайн проходит через первую и последнюю задающие точки подобно кривой Безье. В периодическом В-сплайне первая и последняя точки влияют 
 на форму кривой точно в той же степени, что и все остальные точки, а потому кривая не проходит через них. Вообще говоря, функция сопряжения для 
 периодических узлов повторяется через равные промежутки значений параметра, почему узлы и называются периодическими. Непериодические кривые чаще 
 используются в САПР, поскольку большинству конструкторов привычнее работать с кривыми, проходящими через первую и последнюю точки.
</P>
<P>Выражения (7.24) и (7.25) показывают, что расстояние между соседними узлами всегда одинаково и равно единице. Такие узлы называются
 <I>однородными</I> (<I>uniform knots</I>), как и В-сплайн, через них проходящий. Однородный В-сплайн может быть как периодическим, так и 
 непериодическим. При изменении формы кривой конструкторы часто добавляют и удаляют узлы, в результате чего В-сплайн становится неоднородным.
 Поскольку однородность является частным случаем неоднородности, неоднородные В-сплайны считаются обобщением однородных. Таким образом, большинство
 САПР позволяют создавать и модифицировать неоднородные и непериодические В-сплайны.
</P>

<br>
<A Name="#7.10."><P Class=h3>Неоднородный рациональный В-сплайн (NURBS)</P></A>

<P><I>Неоднородный рациональный В-сплайн</I>, или попросту <I>NURBS</I> (<I>nonuniform rational B-spline curve</I>), подобен обычному неоднородному
 В-сплайну, поскольку основан на тех же функциях сопряжения, получаемых для неоднородных узлов. Однако задающие точки, рационального В-сплайна 
 указываются с использованием однородных координат, к которым применяются функции сопряжения. Координаты точки на кривой NURBS в однородном 
 пространстве вычисляются по формулам:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center ><Img src="images/formuly/7.26.png"></Td>
<td Width=40px align =right Class=cf>(7.26)</td></tr>
<tr><td align =center><br><Img src="images/formuly/7.27.png"></Td>
<td Width=40px align =right Class=cf>(7.27)</td></tr>
<tr><td align =center><br><Img src="images/formuly/7.28.png"></Td>
<td Width=40px align =right Class=cf>(7.28)</td></tr>
<tr><td align =center><br><Img src="images/formuly/7.29.png"></Td>
<td Width=40px align =right Class=cf>(7.29)</td></tr></Table>
<P>Координаты точки в трёхмерном пространстве <I>x</I>, <I>y</I> и <I>z</I> получаются делением <I>xh</I>, <I>yh</I> и <I>zh</I> на <I>h</I>, поэтому 
уравнение кривой NURBS в векторном виде может быть записано следующим образом (здесь мы поделили уравнения (7.26), (7.27) и (7.28) на (7.29)):
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/7.30.png"></Td>
<td Width=40px align =right Class=cf>(7.30)</td></tr></Table>
<P>где <B>P</B><I><sub>i</sub></I>, – вектор (<I>x<sub>i</sub></I>, <I>y<sub>i</sub></I>, <I>z<sub>i</sub></I>), объединяющий координаты <I>i</I>-й 
задающей точки в трёхмерном пространстве, как и для нерациональных В-сплайнов. Диапазон значений параметра <I>t<sub>k</sub></I><sub>-1</sub> и 
<I>t<sub>k</sub></I><sub>+1</sub> как и для В-сплайна.</P>

<P>Уравнение (7.30) отражает следующие свойства кривой NURBS:</P>

<Ul>
 <Li>Подобно нерациональному В-сплайну, кривая NURBS, представленная уравнением (7.30), обязательно проходит через первую и последнюю задающие точки,
 если используются непериодические узлы. Это утверждение можно доказать следующим образом. Числитель формулы (7.30) может считаться В-сплайном с 
 задающими точками <I>h<sub>i</sub></I><B>P</B><I><sub>i</sub></I>. Граничным значениям параметра будут соответствовать координаты 
 <I>h</I><sub>0</sub><b>P</b><sub>0</sub> и <I>h<sub>n</sub></I><B>P</B><I><sub>n</sub></I>, поскольку В-сплайн с непериодическими узлами проходит
  через первую и последнюю задающие точки. Знаменатель (7.30) также может считаться В-сплайном с задающими точками <I>h<sub>i</sub></I>. Граничным 
  значениям параметра для этого В-сплайна будут соответствовать координаты <I>h</I><sub>0</sub> и <I>h<sub>n</sub></I>. Следовательно, граничным 
  значениям параметра для <B>P</B>(<I>u</I>) в целом будут отвечать координаты <B>P</B><sub>0</sub> и <b>P</b><i><sub>n</sub></i>, то есть граничные
  задающие точки.</Li>
<li>Касательная в начальной точке совпадает по направлению с вектором <B>P</B><sub>1</sub> – <B>P</B><sub>0</sub>, а касательная в конечной точке – с 
вектором <B>P</B><I><sub>n</sub></I> – <B>P</B><sub><i>n</i>-1</sub>.
</li>
<li>Знаменатель (7.30) становится равным 1, когда все <I>h<sub>i</sub></I>-<I>e</I> становятся равными 1. Уравнение (7.30) при этом превращается в
уравнение В-сплайна. Поэтому можно сказать, что уравнение NURBS может описывать не только NURBS-кривые, но и обычные В-сплайны. Кривая Безье является 
частным случаем В-сплайна, поэтому уравнение NURBS может также описывать кривые Безье и рациональные кривые Безье (уравнение рациональной кривой Безье 
получается подстановкой <I>B<sub>in</sub></I>(<i>u</i>) вместо <I>N<sub>jk</sub></I>(<i>u</i>) в уравнение (7.30). Другими словами, функции сопряжения
Безье используются с задающими точками в однородных координатах.).
<p>Уравнение NURBS-кривой обладает определенными преимуществами перед уравнением В-сплайна.</p>
</li>
<li>Форма В-сплайна изменяется при изменении координат <I>x</I>,<I>y</I> u <I>z</I> задающих точек. Для каждой задающей точки, таким образом, имеется 
три степени свободы. Кривая NURBS позволяет изменять четвертую координату для каждой точки – <I>h<sub>i</sub></I>. Появляется возможность работать с
кривой на более тонком уровне. Увеличение значения однородной координаты задающей точки приводит к тому, что NURBS-кривая притягивается ближе к этой
точке.
</li>
<li>Уравнение NURBS позволяет точно воспроизвести все конические сечения – окружность, эллипс, параболу и гиперболу. В-сплайны, напротив, допускают 
лишь приближение к коническим сечениям. Таким образом, в NURBS-представлении можно работать с коническими сечениями, кривыми Безье, рациональными 
кривыми Безье и В-сплайнами. Преобразование всех этих кривых к NURBS может значительно сократить объем программирования. Например, можно написать 
одну-единственную программу для расчета точки пересечения кривых NURBS и использовать ее для расчета пересечений кривых любых типов, поскольку эти 
кривые всегда могут быть преобразованы к соответствующим NURBS-представлениям.
</li>
</UL>
<br>

<A Name="#8."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=97% BgColor=#ABB3D5>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif></Td><Td align=left><span Class=h>8. Представление поверхностей и работа с ними</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br><br>
<P>Системам геометрического моделирования приходится хранить уравнения кривых (или эквивалентные характеристические параметры) для всех рёбер и
 уравнения поверхностей (или эквивалентные параметры) для всех граней. Полезно знать, какими бывают уравнения поверхностей, и какими параметрами они
 характеризуются. Мы говорили, что для реализации булевских операций необходимо рассчитывать точки пересечения кривых. В системах поверхностного 
 моделирования с той же целью приходится определять кривые, по которым пересекаются поверхности. Например, если поверхность в процессе моделирования
 отсекается другой поверхностью, это требует вычисления кривой, по которой они пересекаются. Эта задача требует вычисления координат точек на 
 поверхностях, а также производных в этих точках.
</P>

<br>
<A Name="#8.1."><P Class=h3>Типы уравнений поверхностей</P></A>

<P>Уравнения поверхностей, как и уравнения кривых, делятся на два основных типа. К первому типу относятся <I>параметрические уравнения</I>,
 связывающие значения координат <I>x</I>, <I>y</I> и <I>z</I> со значениями параметра. Ко второму относятся <I>непараметрические уравнения</I>, 
 связывающие координаты <I>x</I>, <I>y</I> и <I>z</I> непосредственно друг с другом какой-либо функцией. Поясним эти определения на простом примере. 
 Рассмотрим сферу радиуса <I>R</I> с центром в начале координат. Параметрическое уравнение этой сферы будет иметь вид:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.1.png"></Td>
<td Width=40px align =right Class=cf>(8.1)</td></tr></Table>

<P>где параметр <I>u</I> может рассматриваться как долгота, a <I>v</I> – как широта. Ту же сферу можно описать и без параметров <I>u</I> и <I>v</I>:</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.2.png"></Td>
<td Width=40px align =right Class=cf>(8.2)</td></tr></Table>
<P>или</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.3.png"></Td>
<td Width=40px align =right Class=cf>(8.3)</td></tr></Table>

<P>Уравнение (8.2) называется <I>неявным непараметрическим</I>, а уравнение (8.3) – <I>явным непараметрическим</I>.</P>

<P>У каждого типа уравнений есть свои преимущества и недостатки, но нас интересуют только параметрические уравнения. Параметрическое уравнение позволяет эффективно вычислять точки на поверхности или кривой, отстоящие друг от друга на небольшие расстояния, что облегчает интерактивное отображение объекта и работу с ним. Это одна из главных причин, по которым параметрические уравнения используются для представления поверхностей в большинстве САПР. Кривые, по которым пересекаются поверхности, в некоторых случаях бывает удобно рассчитывать, представляя одну из этих поверхностей параметрическим уравнением, а другую – непараметрическим. Поэтому в некоторых системах могут использоваться и непараметрические уравнения поверхностей, хотя и не как основной тип уравнений для хранения сведений о кривых. В этом случае возникает потребность в процедуре преобразования из параметрической формы в непараметрическую и обратно.</P>

<br>
<A Name="#8.2."><P Class=H3>Билинейная поверхность</P></A>

<P><I>Билинейная поверхность</I> строится по четырём заданным точкам и описывается линейными уравнениями с параметрами <I>u</I> и <I>v</I>. Эти точки оказываются в углах построенной поверхности. Обозначим их буквами <B>Р</B><sub>0,0</sub>, <B>Р</B><sub>1,0</sub>, <B>Р</B><sub>0,1</sub>,<B> Р</B><sub>1,1</sub> (рис. 8.1). Вывести уравнение билинейной поверхности – это значит найти выражение для координат произвольной точки по значениям параметров <I>u</I> и <I>v</I>. Предположим, что эта точка делит отрезок [<B>Р</B><sub>0,v</sub>, <B>Р</B><sub>1,v</sub>] в отношении <I>u</I>:(1 – <I>u</I>). Точки <B>Р</B><sub>0,v</sub> и <B>Р</B><sub>1,v</sub> делят отрезки <B>Р</B><sub>0,0</sub><B>Р</B><sub>0,1</sub> и <B>Р</B><sub>1,0</sub><B>Р</B><sub>1,1</sub> соответственно в отношении <I>v</I>:(1 – <I>v</I>). Определённая таким образом точка <B>Р</B>(<I>u</I>, <I>v</I>) будет перемещаться по всей поверхности при изменении параметров <I>u</I> и <I>v</I> от 0 до 1. С учётом сделанных предположений координаты точек <B>Р</B><sub>0,v</sub> и <B>Р</B><sub>1,v</sub> запишутся следующим образом:
</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.4.png"></Td>
<td Width=40px align =right Class=cf>(8.4)</td></tr></Table><br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.5.png"></Td>
<td Width=40px align =right Class=cf>(8.5)</td></tr></Table><br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100% align=center>
<tr><td align=center><img src="images/8.1.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 8.1. Билинейная поверхность и её опорные точки</Td></tr></Table><br>
<P>Аналогичным образом получаются координаты точки <B>P</B>(<I>u,v</I>):</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.6.png"></Td>
<td Width=40px align =right Class=cf>(8.6)</td></tr></Table>

<P>Подстановка уравнений (8.4) и (8.5) в (8.6) даст приведённое ниже уравнение билинейной поверхности:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.7.png"></Td>
<td Width=40px align =right Class=cf>(8.7)</td></tr></Table>

<P>Можно убедиться, что заданные точки расположены по углам билинейной поверхности, подставив соответствующие комбинации нулей и единиц в уравнение (8.7). Это уравнение говорит также о том, что билинейная поверхность представляет собой сопряжение угловых точек при помощи функций сопряжения (1 – <I>u</I>)(1 – <I>v</I>), <I>u</I>(1 – <I>v</I>), (1 – <I>u</I>)<I>v</I>, <I>uv</I>. Из-за того что эти функции сопряжения линейны по соответствующим параметрам, билинейная поверхность обычно оказывается плоской.</P>

<br>
<A Name="#8.3."><P Class=h3>Лоскут Куна</P></A>

<P>Сопряжение углов даёт билинейную поверхность. Сопряжение граничных кривых произвольной формы даёт поверхность, называемую <I>лоскутом Куна</I>. Слово «лоскут» указывает на то, что описываемая поверхность представляет собой сегмент, соответствующий значениям параметров 0 &le; <I>u</I> < 1, 0 &le; <I>v</I> < 1. Комбинирование лоскутов позволяет образовать поверхность произвольной формы и размеров.</P>
<P>Выведем уравнение лоскута Куна. Предположим, что известны уравнения четырёх граничных кривых: <B>P</B><sub>0</sub>(<I>v</I>), <B>P</B><sub>1</sub>(<I>v</I>), <B>Q</B><sub>0</sub>(<I>u</I>) и <B>Q</B><sub>1</sub>(<I>u</I>) (рис. 8.2). Предположим также, что направление кривых <B>Q</B><sub>0</sub>(<I>u</I>) и <B>Q</B><sub>1</sub>(<I>u</I>) совпадает (на рис. 8.2 эти кривые направлены вправо, что обозначено стрелкой). То же предположение выскажем и относительно <B>P</B><sub>0</sub>(<I>v</I>) и <B>P</B><sub>1</sub>(<I>v</I>).</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/8.2.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 8.2. Граничные кривые, определяющие лоскут Куна</Td></tr></Table><br>
<P>Если граничные кривые не удовлетворяют этим требованиям, то придётся выполнить преобразование их к описанному выше виду. Направление и интервал изменения параметра легко изменить инверсией или масштабированием. Удовлетворяющие описанным требованиям кривые интерполируются следующим образом.</P>
<P>Выберем две кривые, расположенные друг напротив друга, например <B>P</B><sub>0</sub>(<I>v</I>) и <B>P</B><sub>1</sub>(<I>v</I>). Интерполяция этих кривых в направлении и осуществляется линейным уравнением</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.8.png"></Td>
<td Width=40px align =right Class=cf>(8.8)</td></tr></Table>

<P>Поверхность, определённая уравнением (8.8), будет ограничена кривой <B>P</B><sub>0</sub>(<I>v</I>) при <I>u</I> = 0 и кривой <B>P</B><sub>1</sub>(<I>v</I>) при <I>u</I> = 1. Однако две другие границы будут отрезками прямых, соединяющих угловые точки. Убедиться в этом можно, подставив в уравнение (8.8) <I>v</I> = 0 или <I>v</I> = 1. Таким образом, полученная поверхность не ограничивается кривыми <B>Q</B><sub>0</sub>(<I>u</I>), <B>Q</B><sub>1</sub>(<I>u</I>).</P>
<P>Определим вторую поверхность, интерполируя <B>Q</B><sub>0</sub>(<I>u</I>) и <B>Q</B><sub>0</sub>(<I>v</I>) в направлении <I>v</I>:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.9.png"></Td>
<td Width=40px align =right Class=cf>(8.9)</td></tr></Table>

<P>Подставляя граничные значения <I>u</I> и <I>v</I> в уравнение (8.9), можно убедиться, что новая поверхность ограничивается кривыми <B>Q</B><sub>0</sub>(<I>u</I>), <B>Q</B><sub>0</sub>(<I>v</I>), но не <B>P</B><sub>0</sub>(<I>v</I>) или <B>P</B><sub>1</sub>(<I>v</I>). Попробуем определить ещё одну поверхность <B>P</B><sub>3</sub>(<I>u, v</I>), сложив <B>P</B><sub>1</sub>(<I>u, v</I>) и <B>P</B><sub>2</sub>(<I>u, v</I>), и проверим, не будет ли она ограничиваться требуемыми кривыми.</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.10.png"></Td>
<td Width=40px align =right Class=cf>(8.10)</td></tr></Table>

<P>Подстановка граничных значений <I>u</I> и <I>v</I> в (8.10) даёт:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.11.png"></Td>
<td Width=40px align =right Class=cf>(8.11)</td></tr></Table><br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.12.png"></Td>
<td Width=40px align =right Class=cf>(8.12)</td></tr></Table><br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.13.png"></Td>
<td Width=40px align =right Class=cf>(8.13)</td></tr></Table><br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.14.png"></Td>
<td Width=40px align =right Class=cf>(8.14)</td></tr></Table>

<P>Если <B>P</B><sub>3</sub>(<I>u, v</I>) удовлетворяет поставленным требованиям к граничным кривым, правые два слагаемых в уравнениях (8.11) – (8.14) должны быть равны нулю. Заметив, что эти слагаемые представляют собой интерполяцию конечных точек соответствующих граничных кривых. Другими словами, слагаемые, которые должны быть равны нулю, описывают границы билинейной поверхности. Следовательно, правильное выражение для лоскута Куна получается вычитанием уравнения билинейной поверхности из <B>P</B><sub>3</sub>(<I>u, v</I>):</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.15.png"></Td>
<td Width=40px align =right Class=cf>(8.15)</td></tr></Table>

<P>Здесь <B>P</B><sub>0,0</sub>=<B>P</B><sub>0</sub>(0)=<B>Q</B><sub>0</sub>(0), <B>P</B><sub>1,0</sub>=<B>P</B><sub>1</sub>(0)=<B>Q</B><sub>0</sub>(1), <B>P</B><sub>0,1</sub>=<B>P</B><sub>0</sub>(1)=<B>Q</B><sub>1</sub>(0), <B>P</B><sub>1,1</sub>=<B>P</B><sub>1</sub>(1)=<B>Q</B><sub>1</sub>(1).</P>
<P>Благодаря простоте концепции и уравнений лоскут Куна использовался достаточно широко. Однако он непригоден для точного моделирования поверхностей, поскольку форма поверхности не может задаваться одними лишь её границами.</P>

<br>
<A Name="#8.4."><P Class=h3>Бикубический лоскут</P></A>

<P><I>Бикубический лоскут (bicubic patch)</I> – это поверхность, определяемая полиномиальным уравнением третьего порядка по параметрам <I>u</I> и <I>v</I>:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.16.png"></Td>
<td Width=40px align =right Class=cf>(8.16)</td></tr></Table>

<P>Уравнение (8.16) можно переписать в матричной форме:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.17.png"></Td>
<td Width=40px align =right Class=cf>(8.17)</td></tr></Table>

<P>В уравнениях (8.17) <B>а</B><sub>ij</sub> – алгебраические векторные коэффициенты с компонентами <I>х</I>, <I>у</I> и <I>z</I>. Влияние этих коэффициентов на форму поверхности не является интуитивно понятным, точно так же, как по алгебраическим коэффициентам уравнения (7.10) нельзя было представить себе форму кривой. Возникает желание заменить алгебраические коэффициенты на геометрические, что было сделано ранее при выводе эрмитовой кривой. Поскольку для поверхности насчитывается 16 алгебраических коэффициентов, необходимо ввести 16 граничных условий.</P>
<P>Первый набор граничных условий получим, потребовав, чтобы четыре граничные точки <B>Р</B>(0,0), <B>Р</B>(0,1), <B>Р</B>(1,0), <B>Р</B>(1,1) удовлетворяли уравнению (8.17). Чтобы получить второй набор граничных условий, зададим векторы касатель¬ных к граничным кривым поверхности в угловых точках по параметрам <I>u</I> и <I>v</I>: <B>P</B><sub>u</sub>(0,0), <B>Р</B><sub>u</sub>(0,1), <B>Р</B><sub>u</sub>(1,0), <B>Р</B><sub>u</sub>(1,1) и <B>Р</B><sub>v</sub>(0,0), <B>Р</B><sub>v</sub>(0,1), <B>Р</B><sub>v</sub>(1,0), <B>Р</B><sub>v</sub>(1,1). Перечисленные граничные условия определяют форму граничных кривых поверхности, поскольку они определяют конечные точки этих кривых и векторы касательных в этих точках. Через заданные граничные кривые можно провести бесконечно много поверхностей, поэтому необходимо добавить граничные условия, которые определяли бы форму внутренней области поверхности. Потребуем, чтобы вторая производная в угловых точках имела определенные значения <B>P</B><sub>uv</sub>(0,0), <B>P</B><sub>uv</sub>(0,l), <B>P</B><sub>uv</sub>(l,0), <B>P</B><sub>uv</sub>(1,1). Под второй производной необходимо понимать следующее выражение, называемое <I>вектором кручения (twist vector)</I>:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.17.1.png"></Td>
</tr></Table>

<P>Далее рассмотрим влияние векторов кручения в угловых точках на форму внутренней области поверхности.</P>
<P>Подстановка 16 граничных условий в уравнение (8.17) даст 16 линейных по <B>а</B><sub>ij</sub> уравнений. Эти уравнения образуют систему, результат решения которой подставляется обратно в уравнение (8.17) (уравнение эрмитовой кривой получается при помощи аналогичной процедуры), в результате чего получаем приведённое ниже уравнение бикубического лоскута:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.18.png"></Td>
<td Width=40px align =right Class=cf>(8.18)</td></tr></Table>

<P>где функции сопряжения <I>F</I><sub>1</sub> <I>F</I><sub>2</sub>, <I>F</I><sub>3</sub> и <I>F</I><sub>4</sub> определяются следующим образом:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.19.png"></Td>
<td Width=40px align =right Class=cf>(8.19)</td></tr></Table>

<P>Это те же функции сопряжения, что и в уравнении эрмитовой кривой. Вообще говоря, уравнение (8.18) представляет собой попросту расширение уравнения эрмитовой кривой для описания поверхности. Уравнение (8.18) может быть редуцировано до уравнения кривой путём подстановки конкретного значения одного из параметров, например <I>v</I> = <I>v</I><sub>0</sub>. Произведение последних двух матриц в правой части уравнения (8.18) даёт вектор-столбец. Это умножение может быть интерпретировано следующим образом. Первая строка дает уравнение левой граничной кривой между <b>Р</B>(0,0) и <B>Р</B>(0,1), а вторая строка дает уравнение правой граничной кривой между <B>Р</B>(1,0) и <B>Р</B>(1,1) (рис. 8.3).</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/8.3.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 8.3. Изопараметрическая кривая <I>v</I> = <I>v</I><sub>0</sub></Td></tr></Table><br>
<P>При подстановке конкретного значения <I>v</I><sub>0</sub> первые две строки дают конечные точки <I>А</I> и <I>В</I>. Последние две строки столбца для <I>v</I> = <I>v</I><sub>0</sub> задают векторы касательных в направлении и в точках <I>А</I> и <I>В</I>. Последнее утверждение проверим позже. Следовательно, уравнение (8.18) представляет собой объединение уравнений эрмитовых кривых, соответствующих разным значениям <I>v</I>. Граничные кривые, определяемые условиями <I>v</I> = 0 и <I>v</I> = 1, будут эрмитовыми кривыми. Аналогичным образом можно показать, что и граничные кривые для <I>u</I> = 0, <I>u</I> = 1 тоже будут эрмитовыми.</P>

<P>Если воспользоваться уравнением (8.18), то можно столкнуться с проблемой задания векторов кручения, влияние которых на форму поверхности не является интуитивно понятным. Иногда для простоты им присваивают нулевые значения. Получаемая таким способом поверхность называется <I>лоскутом Фергюсона</I>, или <I>F-лоскутом (Ferguson's patch</I>, или <I>F-patch)</I>. Поскольку нулевые векторы кручения делают поверхность более плоской,
F-лоскут не может использоваться для моделирования поверхностей с большой кривизной. Однако он хорошо описывает поверхности с нулевой кривизной по крайней мере в одном направлении во всех точках.</P>

<P>Покажем теперь, как векторы кручения влияют на форму внутренней области поверхности. Если показать, что векторы кручения определяют форму изопараметрической кривой <I>v</I> = <I>v</I><sub>0</sub> на рис. 8.3, то можно утверждать, что эти векторы влияют на любую внутреннюю изопараметрическую кривую, а значит, и на всю внутреннюю область лоскута. Точки <I>А</I> и <I>В</I> определяются граничными кривыми – эрмитовыми кривыми, которые не зависят от векторов кручения. Следовательно, необходимо показать, что векторы касательных в точках <I>А</I> и <I>В</I> определяются векторами кручения. Сделаем это, продифференцировав уравнение (8.18) по параметру <I>u</I>:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.20.png"></Td>
<td Width=40px align =right Class=cf>(8.20)</td></tr></Table>

<P>Произведение второй и третьей матриц записано в виде вектора-столбца с элементами <B>G</B><sub>1</sub>(<I>v</I>), <B>G</B><sub>2</sub>(<I>v</I>), <B>G</B><sub>3</sub>(<I>v</I>), <B>G</B><sub>4</sub>(<I>v</I>). Чтобы вычислить производную по <I>u</I> в точке <I>А</I>, необходимо подставить в уравнение (8.20) значения <I>u</I> = 0, <I>v</I> = <I>v</I><sub>0</sub>. Подстановка <I>u</I> = 0 в вектор-строку делает её равной [0 0 1 0], благодаря чему получается, что <B>P</B><sub><I>u</I></sub>(A) = <B>G</B><sub>3</sub>(<I>v</I><sub>0</sub>). Поскольку <B>G</B><sub>3</sub>(<I>v</I><sub>0</sub>) определяется векторами <B>P</B><sub><I>u</I></sub>(0,0), <B>P</B><sub><I>u</I></sub>(0,1), <B>P</B><sub><I>uv</I></sub>(0,0) и <B>P</B><sub><I>uv</I></sub>(0,1), векторы кручения <B>P</B><sub><I>uv</I></sub>(0,0) и <B>P</B><sub><I>uv</I></sub>(0,1) определяют <B>P</B><sub><I>u</I></sub>(<I>A</I>).</P>
<P>Подставим <I>u</I> = 1, <I>v</I> = <I>v</I><sub>0</sub> в уравнение (8.20), чтобы выяснить, от чего зависит <B>P</B><sub>u</sub>(<I>В</I>):</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.21.png"></Td>
<td Width=40px align =right Class=cf>(8.21)</td></tr></Table>

<P>Таким образом, вектор касательной в точке <I>В</I> зависит от векторов кручения <B>Р</B><sub><I>uv</I></sub>(1,0) и <B>Р</B><sub><I>uv</I></sub>(1,1). Отсюда следует вывод, что векторы кручения влияют на любую внутреннюю изопараметрическую кривую, а следовательно, определяют форму бикубического лоскута.</P>

<br>
<A Name="#8.5."><P Class=h3>Поверхность Безье</P></A>

<P>Можно расширить концепцию кривой Безье, определяемой задающим многоугольником, на одно измерение, в результате чего получится поверхность Безье, определяемая задающим многогранником. Уравнение поверхности Безье выглядит следующим образом:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.22.png"></Td>
<td Width=40px align =right Class=cf>(8.22)</td></tr></Table>

<P>где <B>P</B><sub>jj</sub> – радиус-векторы задающих точек, находящихся в вершинах задающего многогранника (рис. 8.4), а <I>В</I><sub><I>i,n</I></sub> и <I>B</I><sub><I>j,m</I></sub> – функции сопряжения, обычные для кривых Безье. Таким образом, степень уравнения поверхности по <I>u</I> и <I>v</I> определяется количеством задающих точек в соответствующих направлениях.</P>
<P>Уравнение (8.22) можно раскрыть, записав сумму по <I>j</I> в явном виде:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.23.png"></Td>
<td Width=40px align =right Class=cf>(8.23)</td></tr></Table>

<P>Уравнение (8.23) иллюстрирует, что поверхность Безье получается сопряжением <I>n</I> + 1 кривых Безье, каждая из которых определяется задающими точками Р<sub><I>i</I>,0</sub>, Р<sub><I>i</I>,1</sub>, Р<sub><I>i</I>,2</sub>, … Р<sub><I>i,m</I></sub>, сопрягаемыми функциями B<sub><I>i,n</I></sub>(<I>u</I>). Можно показать, что та же поверхность Безье получается при сопряжении <I>m</I> + 1 кривых Безье, определяемых задающими точками Р<sub>0,<I>j</I></sub>, Р<sub>1,<I>j</I></sub>, Р<sub>2,<I>j</I></sub>, … Р<sub><I>n,j</I></sub>, и функциями B<sub><I>j,m</I></sub>(<I>v</I>). <I>Итак, поверхность Безье получается, если задающие точки кривой Безье заменить кривыми Безье.</I></P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/8.4.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 8.4. Поверхность Безье с задающим многогранником</Td></tr></Table><br>

<P>Как известно, степень поверхности Безье определяется количеством задающих точек. Уравнения поверхностей высоких степеней страдают теми же недостатками, что и уравнения кривых высоких степеней, поэтому при моделировании поверхностей обычно используются поверхности Безье степени 3 по <I>u</I> и <I>v</I>, точно так же как при моделировании кривых использовались кривые Безье степени 3. При моделировании сложной поверхности создают несколько поверхностей Безье третьей степени и соединяют их друг с другом. Поверхности должны соединяться таким образом, чтобы обеспечивалась непрерывность на границе, по которой осуществляется соединение. Это достигается наложением ограничений на задающие точки, расположенные слева и справа от границы. Ограничение состоит в том, что эти точки должны лежать на прямой линии, проходящей через задающую точку, лежащую на общей границе (рис. 8.5). Если это требование выполняется, первая производная оказывается непрерывной во всех точках границы.</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/8.5.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 8.5. Объединение лоскутов Безье</Td></tr></Table>

<br>
<A Name="#8.6."><P Class=h3><I>В</I>-сплайновая поверхность</P></A>

<P>Подобно тому, как от уравнения кривой Безье был осуществлён переход к уравнению поверхности Безье, можно перейти и от уравнения <I>В</I>-сплайна к уравнению <I>В</I>-сплайновой поверхности:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.24.png"></Td>
<td Width=40px align =right Class=cf>(8.24)</td></tr></Table>

<P>где <B>P</B><sub><I>i,j</I></sub> – задающие точки, расположенные в вершинах задающего многогранника, как и для поверхности Безье, a <I>N</I><sub><I>ik</I></sub>(<I>u</I>) и <I>N</I><sub><I>jl</I></sub>(<I>v</I>) – функции сопряжения, используемые для построения <I>В</I>-сплайнов. Эти функции сопряжения определяются узловыми значениями <I>s</I><sub>0</sub>, <I>s</I><sub>1</sub>, …, <I>s<sub>n + k</sub></I>, и <I>t</I><sub>0</sub>, <I>t</I><sub>1</sub>, ..., <I>t</I><sub><I>l</I> + <I>m</I></sub> соответственно. Диапазоны параметров используются в определении
<I>В</I>-сплайна, поскольку функции сопряжения <I>N<sub>ik</sub></I>(<I>u</I>) и <I>N<sub>jl</sub></I>(<I>v</I>) определены только на этих интервалах (см. раздел 7). Это верно как для периодических узлов, так и для непериодических. Далее будем рассматривать только непериодические узлы по тем же причинам, что и раньше. В этом случае функции сопряжения
<I>В</I>-сплайна будут совпадать с функциями сопряжения поверхности Безье, если <I>k</I> = <I>n</I> + 1, <I>l</I> = <I>m</I> + 1. Поэтому можно утверждать, что поверхность Безье является лишь частным случаем <I>В</I>-сплайновой поверхности, а уравнение (8.24) описывает как поверхности Безье, так и <I>В</I>-сплайновые. Чаще всего порядки <I>k</I> и <I>l</I> принимаются равными 4, поскольку степени уравнений, описывающих поверхности, не должны превышать 3.</P>

<P><I>В</I>-сплайновая поверхность с непериодическими узлами обладает свойствами, напоминающими поверхность Безье (например, четыре угла задающего многогранника лежат на поверхности, а граничные кривые представляют собой <I>В</I>-сплайны, определяемые соответствующими подмножествами задающих точек). Покажем, что значению параметра <I>u</I> = 0 соответствует граничная кривая, являющаяся В-сплайном. Подстановка <I>u</I> = 0 в уравнение (8.24) даёт</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.25.png"></Td>
<td Width=40px align =right Class=cf>(8.25)</td></tr></Table>

<P>В соответствии с формулой (8.23), граничная кривая при <I>u</I> = 0 является <I>В</I>-сплайном с задающими точками <B>Р</B><sub>0,0</sub>, <B>Р</B><sub>0,1</sub>, ..., <B>Р</B><sub>0,<I>m</I></sub>. Аналогичным образом можно показать, что и остальные граничные кривые являются <I>В</I>-сплайнами, а их задающие точки являются крайними вершинами задающего многогранника.</P>

<br>
<A Name="#8.7."><P Class=h3>Поверхность NURBS</P></A>

<P>Перейдя к однородным координатам задающих точек, из уравнения <I>В</I>-сплайна получено уравнение NURBS-кривой. Точно так же уравнение поверхности NURBS получается из <I>В</I>-сплайновой поверхности:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.26.png"></Td>
<td Width=40px align =right Class=cf>(8.26)</td></tr></Table>

<P>где <B>P</B><sub><I>ij</I></sub> – векторы задающих точек с компонентами <I>х, у</I> и <I>z</I>, а <I>h<sub>ij</sub></I> – однородные координаты задающих точек. Узловые значения и диапазоны значений параметров совпадают с указанными в формуле (8.24).</P>
<P>Уравнение (8.26) становится уравнением <I>В</I>-сплайновой поверхности при <I>h<sub>ij</sub></I> = 1, следовательно, уравнение <I>В</I>-сплайновой поверхности является частным случаем уравнения NURBS-поверхности. Поверхность NURBS к тому же позволяет точно описать квадратичные поверхности, такие как цилиндр, конус, сфера, параболоид и гиперболоид. Эти поверхности называются квадратичными, потому что их уравнения имеют степень 2 по <I>u</I> и <I>v</I>. Уравнение NURBS-поверхности часто используется для внутреннего представления квадратичных поверхностей в системах геометрического моделирования.</P>
<P>Проиллюстрируем использование уравнений NURBS-поверхности в системах объемного моделирования на примере поверхности, полученной трансляцией кривой (рис. 8.6). Предположим, что транслируемая кривая задана NURBS-уравнением. Это предположение не накладывает никаких ограничений, поскольку уравнение любой кривой из рассмотренных выше может быть преобразовано к форме NURBS. Пусть порядок этой кривой <I>l</I>, узловые значения <I>t<sub>p</sub></I> (<I>р</I> = 0, 1, ..., <I>m + l</I>), задающие точки <B>Р</B><sub><I>j</I></sub> (<I>m + 1</I> штук).</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.27.png"></Td>
<td Width=40px align =right Class=cf>(8.27)</td></tr></Table><br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/8.6.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 8.6. Поверхность трансляции</Td></tr></Table><br>

<P>Граничная кривая поверхности NURBS представляет собой NURBS-кривую с соответствующими задающими точками, которые являются крайними вершинами задающего многогранника поверхности. Порядок и узловые значения граничной кривой совпадают с теми же характеристиками поверхности в соответствующем направлении. Этим же свойством обладают <I>В</I>-сплайновые поверхности. Следовательно, задающие точки, порядок и узловые значения поверхности в одном из направлений, совпадающем с направлением изменения параметра кривой, получаются из характеристик транслируемой кривой, поскольку она является одной из граничных кривых. В частности, задающими точками на одном из краев поверхности будут точки <B>Р</B><sub><I>j</I></sub> (см. рис. 8.6). Далее, порядок поверхности в направлении <I>v</I> будет равен <I>l</I>, а узловые значения будут равны <I>t<sub>p</sub></I> (если направления параметров выбрать так, как показано на рис. 8.6).</P>
<P>Однако необходима информация о характеристиках поверхности в направлении <I>u</I>. Предполагается, что направление <I>u</I> совпадает с направлением трансляции (см. рис. 8.6), а значит, в этом направлении достаточно линейного уравнения. Следовательно, порядок NURBS-кривой в этом направлении будет равен 2 и задающих точек тоже будет две. Узловые значения в направлении <I>u</I> будут равны 0, 0, 1, 1, а наборов узловых точек будет два. Один набор, как уже отмечалось, получается из <B>Р</B><sub><I>j</I></sub>, а второй – трансляцией <B>Р</B><sub><I>j</I></sub>на расстояние <I>d</I> в направлении трансляции. Однородные координаты для обоих наборов будут совпадать с <I>h<sub>j</sub></I> транслируемой кривой. Итак, координаты <I>х, у</I> и <I>z</I> задающих точек <B>Р</B><sub><I>i,j</I></sub> и однородные координаты <I>h<sub>jj</sub></I> описываются следующими выражениями:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.27.1.png"></Td>
</tr></Table>

<P>где <I>d</I> – расстояние трансляции, а <B>а</B> – единичный вектор в направлении трансляции.</P>
<P>Уравнение NURBS-поверхности может быть записано так, как показано ниже. Вычисление осуществляется подстановкой нужных значений параметров:</P>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/8.28.png"></Td>
<td Width=40px align =right Class=cf>(8.28)</td></tr></Table>

<P>Обратим внимание на то, что <I>N<sub>j,l</sub></I>(<I>v</I>) в уравнении (8.28) определяется узловыми значениями <I>t<sub>p</sub></I>.</P><br>
<A Name="#9."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=97% BgColor=#ABB3D5>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif></Td><Td align=left><span Class=h>Структуры для хранения данных о 3D-объектах</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br><br>

<P>Рассмотрим, каким образом и в каких форматах хранится математическое описание, отражающее однозначное описание объемных тел. 
Структуры данных, используемые для описания объемных тел, делятся на три типа.</P>
<P>Первая структура представляет собой дерево, описывающее историю применения булевских операций к примитивам. 
Журнал операций называется конструктивным представлением объемной геометрии <I>(Constructive Solid Geometry – CSG representation)</I>. 
Дерево называется деревом <I>CSG (GSG tree)</I>.</P>
<P>Вторая структура содержит сведения о границах объема (вершинах, ребрах, гранях и их соединении друг с другом). 
Это представление называется граничным представлением <I>(boundary representation – В-rep)</I>, 
а структура данных – <I>структурой B-rep (B-rep data structure)</I>.</P>
<P>Третья структура представляет объем в виде комбинации элементарных объемов (например кубов).</P>
<br>
<A Name="#9.1."><P Class=h3>Дерево CSG</P></A>

<P>Дерево CSG содержит историю применения булевских операций к примитивам.
 Рассмотрим тело, изображенное на рис. 9.1, <I>а</I>. Его историю булевских операций можно представить в виде дерева так, как показано на рис. 9.1, <I>б</I>. 
 Это дерево может быть представлено взаимосвязанными элементами данных (рис. 9.1, <I>в</I>).</P>
 <br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/9.1.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 9.1. Пример дерева CSG</Td></tr></Table><br>
<P>Дерево CSG обладает следующими преимуществами:</P>
<Ul>
 <Li>	структура данных проста, а их представление компактно;</Li>
 <Li>	внутренний объём тела однозначно отделен от внешнего. Примером некорректного объемного тела является тело с лишним ребром;</Li>
 <Li>	представление CSG всегда может быть преобразовано к соответствующему представлению B-Rep. 
 Это позволяет взаимодействовать с программами, ориентированными на использование B-Rep;</Li>
 <Li>	легко реализуется параметрическое моделирование.</Li>
 </Ul>
 
<P>Есть у этого дерева и недостатки:</P>
<Ul>
<Li>в процессе моделирования может использоваться только история применения булевских операций, что жестко ограничивает диапазон моделируемых объектов. 
Более того, исключается использование удобных функций локального изменения, таких как поднятие и скругление;</Li>
<Li>для получения сведений о граничных поверхностях, их рёбрах и связях между этими элементами из дерева CSG требуются сложные вычисления (в частности для отображения тел). 
Чтобы отобразить затушеванное изображение или чертеж объемного тела,
 нужно иметь информацию о гранях или вершинах этого тела, а получить эти сведения из дерева CSG очень непросто.</Li>
</Ul>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/9.2.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 9.2. Изменение параметров тела</Td></tr></Table><br>
<P>Из-за этих недостатков разработчики программ, основанных на представ¬лении CSG, стараются добавить соответствующие сведения о границах. 
Такое комбинированное математическое представление называется гибридным и требует поддержания согласованности между двумя структурами данных.</P>
<br>
<A Name="#9.2."><P Class=h3>Структура данных B-Rep</P></A>

<P>Границы объемных тел состоят из элементарных геометрических объектов: вершин, ребер и граней.</P>
<P><I>Грань</I> – часть граничной поверхности, граница которой состоит из криволинейных сегментов, при пересечении которых происходит существенное изменение вектора нормали к поверхности.
Криволинейные сегменты, ограничивающие грань, называются <I>рёбрами</I>. Точки, в которых встречаются соседние рёбра, называются <I>вершинами</I>.</P>
<P>В структуре данных B-Rep хранятся все эти элементы вместе со сведениями о том, как они соединены друг с другом.
 Одна из простейших структур данных приведена в табл. 9.1. Структура данных представляет объёмное тело, изображенное на рис. 9.3. 
 В таблице граней хранится список ограничивающих рёбер для каждой грани. 
 Последовательность рёбер для каждой грани дается обходом против часовой стрелки, если смотреть на тело снаружи.
 Благодаря тому что рёбра хранятся согласованно, вместе с каждой гранью сохраняется информация о том, с какой стороны от неё находится внутренний объём тела. 
 Другими словами, имея сведения о гранях, можно определить, где расположена конкретная точка: снаружи или внутри тела. 
 Вершины, рёбра и грани, изображенные на рис. 9.3, нумеруются системой геометрического моделирования в произвольном порядке в момент сохранения сведений из табл. 9.1.</P>
 <div align=right class="cf">Таблица 9.1</div>
 <div align=right class="cf">Три таблицы представления B-Rep</div><br>
 
 <Center>
<Table Border="1" CellPadding="2" CellSpacing="1">
 <Tr BgColor="#D1D6E9">
   <Td><P Class=tcb>Таблица<Br> граней</P></Td>
  <Td><P Class=tcb>Таблица<Br> рёбер</P></Td>
  <Td colspan="4"><P Class=tcb>Таблица вершин</P></Td>
 </Tr>
 <Tr BgColor=#DCDCDC>
	<Td>Грань</Td>
	<Td>Рёбра</Td>
	<Td>Ребро</Td>
	<Td>Вершина</Td>
	<Td>Вершина</Td>
	<Td>Координаты</Td>
 </Tr>
  <Tr BgColor=#EAEAEA>
<Td><P Class=tcb></P>F<sub>1</sub></Td>
	<Td>E<sub>1</sub>,E<sub>5</sub>,E<sub>6</sub></Td>
	<Td>E<sub>1</sub></Td>
	<Td>V<sub>1</sub>,V<sub>2</sub></Td>
	<Td>V<sub>1</sub></Td>
	<Td>x<sub>1</sub>,y<sub>1</sub>,z<sub>1</sub></Td>
  </Tr>
   <Tr BgColor=#DCDCDC>
<Td>F<sub>2</sub></Td>
	<Td>E<sub>2</sub>,E<sub>6</sub>,E<sub>7</sub></Td>
	<Td>E<sub>2</sub></Td>
	<Td>V<sub>2</sub>,V<sub>3</sub></Td>
	<Td>V<sub>2</sub></Td>
	<Td>x<sub>2</sub>,y<sub>2</sub>,z<sub>2</sub></Td>
  </Tr>
  <Tr BgColor=#EAEAEA>
<Td><P Class=tcb></P>F<sub>3</sub></Td>
	<Td>E<sub>3</sub>,E<sub>7</sub>,E<sub>8</sub></Td>
	<Td>E<sub>3</sub></Td>
	<Td>V<sub>3</sub>,V<sub>4</sub></Td>
	<Td>V<sub>3</sub></Td>
	<Td>x<sub>3</sub>,y<sub>3</sub>,z<sub>3</sub></Td>
  </Tr>
  <Tr BgColor=#DCDCDC>
<Td><P Class=tcb></P>F<sub>4</sub></Td>
	<Td>E<sub>4</sub>,E<sub>8</sub>,E<sub>5</sub></Td>
	<Td>E<sub>4</sub></Td>
	<Td>V<sub>4</sub>,V<sub>1</sub></Td>
	<Td>V<sub>4</sub></Td>
	<Td>x<sub>4</sub>,y<sub>4</sub>,z<sub>4</sub></Td>
  </Tr>
  <Tr BgColor=#EAEAEA>
<Td><P Class=tcb></P>F<sub>5</sub></Td>
	<Td>E<sub>1</sub>,E<sub>2</sub>,E<sub>3</sub>,E<sub>4</sub></Td>
	<Td>E<sub>5</sub></Td>
	<Td>V<sub>1</sub>,V<sub>5</sub></Td>
	<Td>V<sub>5</sub></Td>
	<Td>x<sub>5</sub>,y<sub>5</sub>,z<sub>5</sub></Td>
  </Tr>
  <Tr BgColor=#DCDCDC>
<Td></Td>
	<Td></Td>
	<Td>E<sub>6</sub></Td>
	<Td>V<sub>2</sub>,V<sub>5</sub></Td>
	<Td></Td>
	<Td></Td>
  </Tr>
  <Tr BgColor=#EAEAEA>
<Td></Td>
	<Td></Td>
	<Td>E<sub>7</sub></Td>
	<Td>V<sub>3</sub>,V<sub>5</sub></Td>
	<Td></Td>
	<Td></Td>
  </Tr>
  <Tr BgColor=#DCDCDC>
<Td></Td>
	<Td></Td>
	<Td>E<sub>8</sub></Td>
	<Td>V<sub>4</sub>,V<sub>5</sub></Td>
	<Td></Td>
	<Td></Td>
  </Tr> 
 </Table>
 <Br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/9.3.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 9.2. Изменение параметров тела</Td></tr></Table><br>
 <P>В каждой строке таблицы ребер хранятся вершины, находящиеся на концах соответствующего ребра, а в строках таблицы вершин хранятся координаты всех вершин. 
 Эти координаты обычно определяются в модельной системе координат, связанной с данным телом. 
 Если убрать отсюда таблицу граней, эту структуру данных можно будет использовать для хранения форм, созданных в системах каркасного моделирования. 
 Структура данных для каркасной модели может использоваться в качестве базовой для систем автоматизированной разработки чертежей, если допустить указание 
 двумерных координат для точек. Структура данных B-Rep выглядит очень простой и компактной. Однако она не используется в развитых системах твердотельного
 моделирования из-за следующих недостатков:</P>
 <Ul>
<Li>B-Rep ориентирована на хранение плоских многогранников. Если потребуется сохранить данные о теле с криволинейными гранями и ребрами, строки таблиц граней 
и ребер придется изменять таким образом, чтобы в них можно было включить уравнения поверхности и кривой;</Li>
<Li>грань с внутренними и внешними границами (рис. 9.4, <I>а</I>) не может быть сохранена в таблице граней, поскольку для нее нужно два списка ребер вместо одного. 
Такие грани появляются, например, при моделировании объемных тел со сквозными отверстиями. Простым решением этой проблемы является добавление ребра, соединяющего
 внешнюю и внутреннюю границы (рис. 9.4, <I>б</I>). В этом случае два списка вершин могут быть объединены. Соединительное ребро называется <I>мостиком</I>, 
 или <I>перемычкой (bridge edge)</I>, и попадает в список ребер в двух экземплярах;</Li>
</Ul>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/9.4.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 9.4. Поверхность с двумя границами и метод их обхода</Td></tr></Table><br>
 <Ul>
<Li>количество рёбер у разных граней может быть различно (см. табл. 9.1). Невозможно заранее определить количество столбцов, необходимых для кон¬кретной грани, 
поскольку это количество может меняться в процессе моделирования, а работа с таблицей переменного размера создаёт неудобства;</Li>
<Li>получать сведения о связности непосредственно из данных, сохранённых в трёх таблицах, может быть довольно утомительно. Представим себе поиск двух граней 
с общим ребром в случае граничного представления тела в трёх таблицах. Для этого придётся просмотреть всю таблицу граней, чтобы найти строки, в которых присутствует 
нужное ребро. Если нужно найти все рёбра, соединяющиеся в конкретной вершине, опять-таки придется просматривать всю таблицу рёбер. При больших размерах таблиц поиск 
в них становится крайне неэффективным.</Li>
</Ul>
<br>
<A Name="#9.3."><P Class=h3>Структура декомпозиционной модели</P></A>

<P>Объёмная модель может быть приближенно представлена в виде совокупности простых тел, например кубов. 
Такая модель называется <I>декомпозиционной (decomposition model)</I>. Можно предложить много декомпозиционных моделей описания одного и того же тела. 
Модель включает в себя простейшее тело и метод объединения в совокупность. К типичным декомпозиционным моделям с соответствующими структурами данных относятся
 воксельное представление, представление октантного дерева и ячеечное представление.</P>
<br>
<A Name="#9.4."><P Class=h3>Воксельное представление</P></A>

<P><I>Воксельное представление (voxel representation)</I> объёмного тела – это просто трёхмерный аналог растрового представления плоской фигуры. 
Чтобы рассказать о воксельном представлении, придётся вспомнить процедуру получения растрового изображения. Растровое изображение двумерного объекта формируется 
следующим образом. Сначала создаётся квадрат, размер которого соответствует интересующей нас области двумерного пространства. Затем квадрат делится на много 
маленьких квадратиков путём нанесения на него линий сетки. Расстояние между линиями сетки определяется желаемой точностью растрового представления. 
Другими словами, если это расстояние будет очень маленьким, то растровое изображение будет очень точно воспроизводить форму исходного двумерного объекта.
 В противном случае получится лишь грубое приближение. Квадрат, содержащий много маленьких квадратиков, представляется в компьютере в виде двумерного массива,
 количество элементов в котором совпадает с количеством квадратиков. Наконец, большой квадрат накладывается на двумерный объект, и элементы массива, соответствующие 
 квадратикам, находящимся над объектом, получают значение 1, а остальные элементы – значение 0. Получившийся массив нулей и единиц становится растровым 
 представлением двумерного объекта.</P>
<P>Воксельное представление объёмного тела получается при помощи той же процедуры, что и растровое представление. 
Однако начинается она не с большого квадрата и маленьких квадратиков, а с большого куба и маленьких кубиков, называемых <I>вокселами</I>. 
Деление на вокселы осуществляется сеткой плоскостей, расположенных на равном расстоянии друг от друга перпендикулярно осям <I>х</I>, <I>у</I> и <I>z</I>. Исходный куб представляется в 
виде трёхмерного массива, количество элементов которого совпадает с количеством кубиков, и каждому элементу массива присваивается значение 0 или 1 в зависимости от 
положения элемента в теле. Несмотря на то что эта процедура практически идентична процедуре формирования растра, проверка пересечения тела и кубика требует больших 
вычислений, чем аналогичная двумерная задача. Воксельное представление объёмного тела, имеющего форму бублика, демонстрирует рис. 9.5.</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/9.5.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 9.5. Визуализация воксельного представления</Td></tr></Table><br>
<P>Воксельное представление обладает следующими преимуществами:</P>
<Ul>
<Li>позволяет точно или по крайней мере приблизительно описать объёмное тело совершенно произвольной формы. 
Например, модели человеческих костей и органов часто являются вексельными представлениями данных цифровой томографии.
 Моделировать такие формы при помощи обычных функций очень сложно. Даже применение сложных процедур всё равно не позволяет построить точную модель;</Li>
<Li>позволяет с лёгкостью рассчитывать такие параметры тела, как масса и моменты инерции. Расчёт осуществляется путём суммирования параметров отдельных вокселов. 
Также легко получить результат булевской операции. Для этого достаточно всего лишь применить булевскую операцию к целочисленным значениям соответствующих вокселов 
двух тел;</Li>
<Li>хотя воксельное представление предназначено для описания тела в пространстве, оно автоматически описывает и пространство вне тела.
 Поэтому оно удобно для расчёта объёма полых структур и расчёта траекторий движения роботов, уклоняющихся от препятствий;</Li>
 </Ul>
 <P>Есть у воксельного представления и некоторые недостатки:</P>
 <Ul>
<Li>Объём памяти, требуемый для хранения воксельного представления тела, резко возрастает с уменьшением размеров вокселов. 
Размер вокселов определяет точность приближения исходного тела, поэтому моделирование может потребовать предельного его снижения.</Li>
<Li>воксельное представление по определению является приближенным описанием исходного тела. Поэтому систем твердотельного моделирования, в которых оно является основным математическим описанием объектов, довольно мало. 
Вокселы часто используются в качестве внешнего представления, повышающего эффективность вычислений.</Li>
</Ul>
<br>
<A Name="#9.5."><P Class=h3>Представление октантного дерева</P></A>

<P><I>Представление октантного дерева (octree representation)</I> аналогично воксельному в том плане, что тело рассматривается как совокупность шестигранников 
(куб – это правильный шестигранник). Однако это представление предъявляет значительно менее серьёзные требования к памяти благодаря иной схеме деления пространства.
 В воксельном представлении исходный куб делится сеткой плоскостей, находящихся на равном расстоянии друг от друга по осям <I>х</I>, <I>у</I> и <I>z</I>. 
 В представлении октантного дерева исходный куб делится каждый раз на восемь равных кубов поперечными плоскостями (рис. 9.6, <I>а</I>). 
 Объём маленького куба в восемь раз меньше объема исходного, отсюда и название представления. Более того, если кубики представить в виде узлов дерева, то от 
 каждого узла будет отходить восемь ветвей (рис. 9.6, <I>б</I>). Такое дерево и называется <I>октантным</I>. Если бы каждый кубик всегда делился на восемь меньших вне зависимости 
 от формы моделируемого тела, то результат был бы полностью аналогичен воксельному представлению с кубиками постоянного размера. Однако в представлении октантного 
 дерева некоторые кубики делятся на восемь частей, тогда как другие кубики того же уровня остаются целыми. Определяется это положением кубиков по отношению
 к представляемому телу.</P>
 <Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/9.6.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 9.6. Пример формирования октантного дерева</Td></tr></Table><br>
<P>Процедура построения представления октантного дерева выглядит следующим образом. Сначала создается шестигранник, в который моделируемое тело помещается целиком. 
Этот шестигранник называется <I>корневым октантом (root octant)</I>. Затем корневой октант делится на восемь октантов, после чего анализируется их положение в пространстве
 по отношению к моделируемому телу. Если октант находится полностью внутри тела, он считается «черным»; если снаружи – «белым». Если же октант частично лежит внутри 
 тела, а частично – снаружи, то он считается «серым» и делится на восемь октантов меньшего размера. Черные и белые октанты дальше не делятся. Процедура повторяется 
 до тех пор, пока не будет достигнут заданный минимальный размер октанта. После этого октанты, окрашенные в черный цвет, считаются относящимися к исходному телу.</P>
<P>На рис. 9.6, <I>в</I> показано октантное дерево для тела с рис. 9.6, <I>б</I>. Количество октантов, под которые приходится отводить память, много меньше количества вокселов 
для тела того же объема, поскольку белые и черные октанты дальше не делятся. Октантное дерево с рис. 9.6, <I>в</I> хранится в компьютере в виде структуры данных. 
Несмотря на относительно простой вид процедуры формирования октантного дерева на языке С, подпрограмма требует сложных геометрических вычислений, поскольку 
она определяет, где находится конкретный октант: внутри тела, снаружи его или на границе. Серые октанты преобразуются в чёрные после окончания процесса деления. 
Поэтому объём модели, полученной в результате применения этой процедуры, будет заведомо большим объёма исходного тела.</P>
<br>
<A Name="#9.6."><P Class=h3>Ячеечное представление</P></A>

<P><I>Ячеечное представление (cell representation)</I> – это ещё один метод представления объёмного тела в виде комбинации простых элементов, подобный воксельному 
представлению. Однако, как следует из названия представления, ячеечный метод не накладывает жёстких ограничений на форму этих элементов. 
Практически любое объёмное тело можно представить при помощи небольшого набора простых ячеек. Пример ячеечного представления представлен на рис. 9.7. 
Как видно из этого рисунка, формирование сетки конечных элементов для конечно-элементного анализа является частным случаем ячеечного представления.</P>
 <Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/9.7.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 9.7. Пример ячеечного представления</Td></tr></Table><br>
<br>
<A Name="#9.7."><P Class=h3>Булевы операторы</P></A>

<P>Из всех функций моделирования булевы операторы являются наиболее сложными с точки зрения реализации, однако они предоставляют наиболее широкие возможности 
пользователю системы моделирования. К булевым операциям относятся объединение, пересечение и разность объёмных тел. Результат операции сохраняется в структуре 
данных, характерной для используемой системы твердотельного моделирования. Если эта система основана на дереве CSG или декомпозиционном представлении, результат 
булевой операции легко будет представить в той же структуре. Дерево CSG результата любой булевой операции получается простым комбинированием деревьев исходных тел 
при помощи соответствующей операции булевой алгебры. То же относится и к декомпозиционной модели: там булевы операции применяются к пространственным элементам тел. 
Например, воксельное представление результата булевой операции может быть получено применением соответствующей операции (побитовой булевой операции) к значениям 
вокселов двух тел, попадающих в одну и ту же точку пространства.</P>
<P>Если же система твердотельного моделирования использует структуру
B-Rep, ситуация оказывается принципиально иной. В этом случае структуру
B-Rep исходного тела приходится вычислять по структурам B-Rep исходных тел, к которым применяется булева операция. 
Этот процесс называется <I>вычислением границ (boundary evaluation)</I>.
</P>
<P>Алгоритм вычисления границ реализуется в три этапа. Воспользуемся плоским рисунком (рис. 9.8), но тот же подход применим и к трёхмерным телам. 
Сначала обозначим две грани (два тела в трёхмерном случае), к которым должна быть применена булева операция, буквами А и Б, а результат операции назовём буквой В 
(рис. 9.8, <I>а</I>). На первом этапе все рёбра А и Б, а также рёбра, получаемые пересечением этих граней, помещаются в единый пул рёбер. Подмножеством пула рёбер, 
очевидно, являются все рёбра грани В. На втором этапе все рёбра пула классифицируются по их положению относительно граней А и Б. Любое ребро может находиться,
 во-первых, внутри, на границе или снаружи грани а, во-вторых, внутри, на границе или снаружи грани Б
(рис. 9.8, <I>б</I>). На третьем этапе ребра группируются по их относительному положению в соответствии с применяемой булевой операцией.
 Заметим, что для операции «А объединить с Б» нужно отбросить все рёбра, находящиеся «внутри А» и «внутри Б» (см. рис. 9.8, <I>б</I>). Аналогичным образом для операции
 «А пересечь с Б» отбрасываются рёбра, лежащие «вне А» и «вне Б». Собранные рёбра формируют грань. Для этого в структуру заносятся все необходимые сведения 
 о вершинах, рёбрах, кольцах и прочих элементах. Для объёмных тел такой подход требует серьёзных геометрических вычислений, поскольку требуется определить, 
 где именно находятся рёбра, а конструирование структуры B-Rep получившегося тела по собранным рёбрам представляет сложную топологическую задачу.
</P>
 <Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/9.8.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 9.8. Классификация рёбер</Td></tr></Table><br>
<br>
<A Name="#9.8."><P Class=h3>Расчёт объёмных параметров</P></A>

<P>Одним из преимуществ объемной модели является возможность расчёта объёмных параметров тела непосредственно исходя из его математического описания.
 Первые системы твердотельного моделирования использовались главным образом для визуализации формы объекта, так что расчёт объёмных параметров был одной из немногих 
 инженерных функций, поддерживавшихся этими системами. 
К объёмным параметрам объекта относятся его объём, центр тяжести, моменты инерции и центробежные моменты инерции, которые определяются следующим образом.</P>
<P>Объем:</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/9.8.1.png"></Td>
<td Width=1px align =right Class=cf></td></tr></Table>
<P>Центр тяжести:</P>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/9.8.2.png"></Td>
<td Width=1px align =right Class=cf></td></tr></Table>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/9.8.3.png"></Td>
<td Width=1px align =right Class=cf></td></tr></Table>

<Table Border=0 CellPadding=0 CellSpacing=0 Width=100%>
<tr><td align =center><Img src="images/formuly/9.8.4.png"></Td>
<td Width=1px align =right Class=cf></td></tr></Table>

<br>
<A Name="#10."></A>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=97% BgColor=#ABB3D5>
<Tr><Td Bgcolor=#000000 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
<Tr><Td Width=30><Img Src=../Оболочка/images/raspor.gif></Td><Td align=left><span Class=h>Удаление невидимых линий и поверхностей</span></Td></Tr>
 <Tr><Td Bgcolor=#000000 Width=25 ColSpan=2><Img Src=../Оболочка/images/raspor.gif Height=1></Td></Tr>
</Table>
<Br><br>
<P>Проекция на экран станет более наглядной, если будет содержать только видимые линии и поверхности.
 <I>Удаление невидимых линий</I> заключается в блокировании отображения отрезков, скрытых от наблюдателя,
 а <I>удаление невидимых поверхностей</I> есть то же самое по отношению к поверхностям (рис. 10.1 <I>б</I>). Эта процедура облегчает восприятие объекта.</P>
  <Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/10.1.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 10.1 Изображение: а) – до удаления невидимых линий,
б) – после удаления невидимых линий.
</Td></tr></Table><br>
<P>Существует множество алгоритмов удаления невидимых линий и поверхностей. С точки зрения вычислительной эффективности наилучшим образом
 удаление реализуется посредством <I>z</I>-буфера – области памяти, 
аналогичной буферу кадра, в которой хранятся данные о <I>Z</I>-координатах объектов (проекциям пикселов). 
Координата <I>Z</I> является мерой расстояния от наблюдателя до объекта.</P>
<br>
<A Name="#10.1."><P Class=h3>Алгоритм удаления невидимых граней</P></A>

<P>Данный алгоритм основан на том, что грань объекта может быть видимой только в том случае, если вектор внешней нормали к этой грани направлен 
в сторону наблюдателя. В противном случае грань будет невидима. Например, верхняя грань бруска, изображенного на рис. 10.3, 
считается видимой, если вектор внешней нормали <B>N</B> имеет положительную составляющую в направлении вектора <B>М</B>, проведённого из точки на грани к наблюдателю.
 Математически это записывается так: если <B>М</B>•<B>N</B> > 0, поверхность видима;
если <B>М</B>•<B>N</B> = 0, поверхность проецируется в отрезок;
если <B>М</B>•<B>N</B> < 0, поверхность невидима.
</P>
  <Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/10.3.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 10.3. Векторы, определяющие видимость грани</Td></tr></Table><br>
<P>Этот алгоритм легко применить к объекту, ограниченному плоскими поверхностями, поскольку вектор нормали <B>N</B> постоянен в пределах поверхности. 
Однако к вогнутому объекту (вогнутым называется объект, если по крайней мере две его грани смыкаются под внутренним углом, большим 180°. Если меньшим 180°, 
то объект называется выпуклым.) алгоритм неприменим, поскольку грань, направленная к наблюдателю, может быть закрыта другой гранью того же объекта (см. рис. 10.3).
Та же проблема возникает в случае нескольких выпуклых объектов, которые могут закрывать грани друг друга. Следовательно, алгоритм удаления невидимых граней применим 
только к одному выпуклому объекту. Более того, алгоритм неприменим к объектам, для которых вектор внешней нормали определяется неоднозначно (рис. 10.4).</P>
<P>Если поверхности объекта не являются плоскими, значение <B>N</B> будет меняться в пределах одной грани в зависимости от выбранной точки. Одновременно может меняться 
и знак произведения <B>М</B>•<B>N</B>. Это означает, что у одной и той же грани будут как видимые, так и невидимые участки. Поэтому грань должна быть разделена на две части вдоль 
кривой, на которой выполняется равенство <B>М</B>•<B>N</B> = 0. Эта кривая называется <I>силуэтной линией (silhouette line)</I>. 
После разделения грани вдоль силуэтной линии знак <B>М</B>•<B>N</B> будет постоянным на каждой из частей грани. Процедура может показаться легкой, но рассчитать силуэтную линию 
очень сложно, а из-за этого теряется главное преимущество алгоритма удаления невидимых граней – простота реализации.</P>
  <Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/10.4.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 10.4. Пример вогнутого объекта</Td></tr></Table><br>
<P>После того как все грани классифицируются как видимые или невидимые, на экран выводятся ребра видимых граней, в результате чего получается рисунок без 
невидимых линий. Если же нужно получить рисунок без невидимых поверхностей, видимые поверхности заливаются выбранными цветами.</P>
<br>
<A Name="#10.2."><P Class=h3>Алгоритм художника</P></A>

<P>Основной принцип алгоритма сортировки по глубине, или алгоритма художника, можно представить так. Поверхности объектов сортируются по удалённости 
от наблюдателя и заполняются соответствующими цветами, начиная с самой дальней. В результате закрашивания поверхностей дальние поверхности автоматически
скрываются ближними, если они проецируются в одну и ту же область экрана. Расстояние от поверхности до наблюдателя определяется z-координатами точек на
 этой поверхности в наблюдательской системе координат. Точка с большей координатой <I>Z</I><sub>V</sub> считается находящейся ближе к наблюдателю. 
Значит, остается только сравнить координаты <I>Z</I><sub>P</sub> всех поверхностей и отобразить их, начиная с поверхности с наименьшим значением <I>Z</I><sub>V</sub>.</P>
<P>Легко сравнивать координаты <I>Z</I><sub>V</sub> поверхностей, если максимальное значение <I>Z</I><sub>V</sub> одной из них меньше минимального значения <I>Z</I><sub>V</sub> другой. Однако в большинстве 
случаев диапазон значений <I>Z</I><sub>V</sub> точек одной поверхности перекрывается с диапазоном <I>Z</I><sub>V</sub> другой поверхности. Неоднозначности можно избежать, разбивая все поверхности 
на отдельные части до тех пор, пока диапазоны <I>Z</I><sub>V</sub> не перестанут перекрываться. Есть и другой, более простой в реализации способ решения проблемы. Все поверхности 
преобразуются в наборы небольших треугольников таким образом, чтобы диапазоны <I>Z</I><sub>V</sub> разных треугольников не перекрывались один с другим, после чего треугольники 
окрашиваются в соответствующие цвета в нужной последовательности. Чем меньше размер треугольников, тем меньше шансов, что их диапазоны <I>Z</I><sub>V</sub> перекроются. 
Такое приближение поверхности объекта называется <I>триангуляцией (triangulation)</I>, или <I>фасетированием</I>.</P>
<br>
<A Name="#10.3."><P Class=h3>Алгоритм удаления невидимых линий</P></A>

<P>Алгоритм сортировки по глубине используется для удаления невидимых <I>поверхностей</I>. Алгоритм невидимых <I>граней</I> позволяет построить рисунок со скрытыми линиями, 
но имеет множество ограничений в общем случае. При применении алгоритма невидимых граней к множеству объектов удалено будет лишь около 50% невидимых линий.
 Поэтому нужен алгоритм, который удалял бы все невидимые линии независимо от количества объектов, их выпуклости и наличия криволинейных поверхностей.</P>
<P>Один из таких алгоритмов действует следующим образом. Для каждого ребра (ребро – кривая пересечения соседних поверхностей, ограничивающих внутренний 
объём объекта) каждого объекта производится проверка, не закрыто ли оно гранями (грани – поверхности, ограничивающие объем объекта) каких-либо объектов.
 Закрытые части рёбер последовательно исключаются до тех пор, пока не останется непроверенных поверхностей. Оставшиеся части всех рёбер выводятся на экран.</P>
<P>Реализация алгоритма включает несколько этапов.</P>
<Ol>
<Li>Поверхности, направленные к наблюдателю, выделяются из всех остальных в отдельную группу при помощи алгоритма <Br> невидимых граней. 
Выделенные поверхности сохраняются в массив FAСE-TABLE. Грани, направленные от наблюдателя, учитывать не требуется, поскольку они сами по себе скрыты, 
а потому не скрывают ребра других граней. Для каждой грани сохраняется максимальное и минимальное значение <I>Z</I><sub>V</sub>. Криволинейные поверхности разделяются по 
силуэтным линиям (как в алгоритме невидимых граней), а видимые части этих поверхностей также сохраняются в массиве FACE-TABLE вместе с плоскими гранями.</Li>
<Li>Рёбра граней из массива FACE-TABLE выделяются из всех прочих ребер и собираются в отдельный список. 
Ребра других граней, <Br> не входящих в FACE-TABLE, можно не рассматривать, поскольку они невидимы. Затем для каждого ребра из списка производится проверка,
не закрывается ли это ребро гранью из FACE-TABLE.</Li>
<br>
 <Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/10.6.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 10.6. Три возможных положения грани и ребра</Td></tr></Table><br>
<Li>Скрытие ребра гранью можно обнаружить, сравнивая диапазоны значений <I>Z</I>, ребра и грани. Возможны три случая (рис. 10.6). <Br> В случае рис. 10.6, 
а все значения <I>Z</I><sub>V</sub> ребра меньше минимального значения <I>Z</I><sub>V</sub> грани, то есть грань находится перед ребром. В случае рис. 10.6, б значения <I>Z</I><sub>V</sub> ребра больше 
максимального значения <I>Z</I><sub>V</sub> грани, то есть грань находится за ребром. В случае рис. 10.6, в диапазоны значений <I>Z</I><sub>V</sub> грани и ребра перекрываются, то есть часть 
ребра находится за гранью, а другая часть – перед ней. Если ребро находится перед проверяемой гранью, из массива FACE-TABLE выбирается следующая грань и ребро
 сравнивается уже с ней. Если ребро оказывается за гранью, или проходит её насквозь, приходится выполнять дополнительное действие.</Li>
 <Li>Ребро и грань проецируются на экран, после чего производится проверка перекрытия проекций. Если перекрытия нет, из этого следует, <Br> 
 что ребро не закрывает проверяемую грань. Из массива FACE-TABLE выбирается следующая грань и проверяется согласно пункту 3. Если проекции перекрываются, 
 ребро делится на две части в той точке, где она проходит сквозь проверяемую грань (рис. 10.7). Закрытая часть ребра отбрасывается, а видимые части добав¬ляются 
 в список. Затем пункт 3 повторяется для новых элементов списка. Исходное ребро из списка удаляется.</Li>
  <Li>Рёбра, прошедшие проверку со всеми гранями из FACE-TABLE, считаются видимыми и выводятся на экран.</Li>
 <br> 
  <Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/10.7.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 10.7. Разбиение ребра</Td></tr></Table><br>
</Ol>
<P>Метод <I>z</I>-буфера основан на том же принципе, что и алгоритм сортировки по глубине: на любом участке экрана оказывается проекция элемента, 
расположенного ближе всех прочих к наблюдателю. Здесь под элементами понимаются точки, кривые или поверхности. Данный метод требует использования области памяти,
 называемой <I>z</I>-буфером. В этом буфере для каждого пиксела хранится значение координаты <I>Z</I><sub>V</sub> того элемента, проекция которого изображается данным пикселом. 
 Как уже говорилось, значение <I>Z</I><sub>V</sub> (то есть координата <I>z</I> в наблюдательской системе) есть мера удалённости объекта от наблюдателя. Объём <I>z</I>-буфера определяется 
 количеством пикселов, для каждого из которых требуется сохранить вещественное число.</P>
<P>Грани, векторы нормали которых направлены от наблюдателя, невидимы для него, поэтому на экран проецируются только те грани, 
векторы нормали которых направлены к наблюдателю. Однако в отличие от метода сортировки по глубине в данном случае порядок проецирования значения не имеет. 
Причина станет очевидной при рассмотрении алгоритма работы.</P>
<Ol>
<Li>Сначала проецируется произвольно выбранная поверхность, и в ячейки памяти <I>z</I>-буфера, соответствующие пикселам проекции <Br> поверхности, 
записываются значения координат <I>Z</I><sub>V</sub> точек поверхности, являющихся прообразами данных пикселов. Пикселы окрашиваются в цвет первой поверхности.</Li>
<Li>Затем проецируется следующая поверхность, и все неокрашенные пикселы, относящиеся к её проекции, окрашиваются в цвет <Br> второй поверхности. Если пикселы уже были 
окрашены, соответствующие им значения <I>Z</I><sub>V</sub> сравниваются со значениями <I>Z</I><sub>V</sub> точек текущей поверхности. Если сохраненное значение <I>Z</I><sub>V</sub> какого-то пиксела оказывается больше 
текущего (то есть точка на предыдущей поверхности ближе к наблюдателю, чем точка на текущей поверхности), цвет пиксела не меняется. 
В противном случае пиксел окрашивается в цвет текущей поверхности. Изначально <I>z</I>-буфер инициализируется координатами <I>Z</I><sub>V</sub>, соответствующими дальней плоскости, 
поэтому пикселы проекции первой поверхности автоматически окрашиваются в её цвет.</Li>
<Li>При повторении этой процедуры для всех имеющихся плоскостей, все пикселы экрана окрасятся в цвета ближайших поверхностей <Br> (рис. 10.8).</Li>
</Ol>
<br>
<Table Border=0 CellPadding=0 CellSpacing=0 Width=96% align=center>
<tr><td align=center><img src="images/10.8.png"></Td></tr>
<tr><td align=center class="c"><BR >Рис. 10.8. Основы метода z-буфера</Td></tr></Table><br>
<P>Как следует из предшествующего описания, метод <I>z</I>-буфера предназначен главным образом для удаления скрытых поверхностей, как и метод сортировки по глубине. 
Однако метод <I>z</I>-буфера с небольшими изменениями позволяет реализовать и построение рисунков со скрытыми линиями. Сначала все поверх¬ности проецируются на экран, 
причем пикселы окрашиваются в цвет фона (на экране ничего не появляется). При этом <I>z</I>-буфер заполняется правильными значениями <I>Z</I><sub>V</sub>. Затем на экран проецируются ребра 
поверхностей. При этом значения <I>Z</I><sub>V</sub> рёбер сравниваются со значениями <I>Z</I><sub>V</sub> ближайших к наблюдателю поверхностей, уже найденными на предыдущем этапе.</P>
<P>Окрашиваются только те пикселы, для которых новые значения <I>Z</I><sub>V</sub> больше исходных. Таким образом, участки ребер, скрытые поверхностями, на экране не появляются. 
Эта процедура даёт правильный рисунок без скрытых линий, но некоторые граничные линии могут оказаться слишком тонкими, потому что некоторые пикселы этих линий 
будут относиться к поверхностям, ограниченным соответствующими ребрами. Эту проблему легко решить, пододвинув весь объект поближе в момент проецирования рёбер.</P>

<Hr Width="90%" Color="#7685C6" Align="Right"><Br><Br>
</Div>

 </Td>
</Tr>
<Tr>
  <Td>&nbsp;</Td>
</Tr>
<Tr>
 <Td ColSpan=2>

<Table Border=0 CellSpacing=0 CellPadding=0>
 <Tr>
  <Td BackGround=../Оболочка/images/bg09.gif Width=458 Height=100 Valign=Bottom>
   <P Class=co>Copyright &copy; БГУИР, Кафедра Систем управления, 2016<Br>
   <Img Src=../Оболочка/images/raspor.gif Width=1 Height=8></P></Td>
  <Td BackGround=../Оболочка/images/bg10.gif Width=159 Height=100>
   <A Href=#Top onMouseOver="mOver(6)" onMouseOut="mOut(6)"><Img Src=../Оболочка/images/06a.gif Width=159 Height=46 Border=0 Alt="К началу документа" name="link6"></A><Br>
   <A Href=!zadanie.html onMouseOver="mOver(7)" onMouseOut="mOut(7)"><Img Src=../Оболочка/images/07a.gif Width=159 Height=54 Border=0 Alt="К первой странице" name="link7"></A></Td>
 </Tr>
</Table>

 </Td>
</Tr>
</Table>

</Body>
</HTML>